/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MultiPropPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian8 = require("obsidian");

// src/AddPropModal.ts
var import_obsidian2 = require("obsidian");

// node_modules/svelte/src/runtime/internal/utils.js
function noop() {
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a && typeof a === "object" || typeof a === "function";
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}

// node_modules/svelte/src/runtime/internal/globals.js
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : (
  // @ts-ignore Node typings have this
  global
);

// node_modules/svelte/src/runtime/internal/ResizeObserverSingleton.js
var ResizeObserverSingleton = class _ResizeObserverSingleton {
  /** @param {ResizeObserverOptions} options */
  constructor(options) {
    /**
     * @private
     * @readonly
     * @type {WeakMap<Element, import('./private.js').Listener>}
     */
    __publicField(this, "_listeners", "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0);
    /**
     * @private
     * @type {ResizeObserver}
     */
    __publicField(this, "_observer");
    /** @type {ResizeObserverOptions} */
    __publicField(this, "options");
    this.options = options;
  }
  /**
   * @param {Element} element
   * @param {import('./private.js').Listener} listener
   * @returns {() => void}
   */
  observe(element2, listener) {
    this._listeners.set(element2, listener);
    this._getObserver().observe(element2, this.options);
    return () => {
      this._listeners.delete(element2);
      this._observer.unobserve(element2);
    };
  }
  /**
   * @private
   */
  _getObserver() {
    var _a;
    return (_a = this._observer) != null ? _a : this._observer = new ResizeObserver((entries) => {
      var _a2;
      for (const entry of entries) {
        _ResizeObserverSingleton.entries.set(entry.target, entry);
        (_a2 = this._listeners.get(entry.target)) == null ? void 0 : _a2(entry);
      }
    });
  }
};
ResizeObserverSingleton.entries = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;

// node_modules/svelte/src/runtime/internal/dom.js
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node) return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && /** @type {ShadowRoot} */
  root.host) {
    return (
      /** @type {ShadowRoot} */
      root
    );
  }
  return node.ownerDocument;
}
function append_stylesheet(node, style) {
  append(
    /** @type {Document} */
    node.head || node,
    style
  );
  return style.sheet;
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i]) iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function prevent_default(fn) {
  return function(event) {
    event.preventDefault();
    return fn.call(this, event);
  };
}
function attr(node, attribute, value) {
  if (value == null) node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);
}
function get_binding_group_value(group, __value, checked) {
  const value = /* @__PURE__ */ new Set();
  for (let i = 0; i < group.length; i += 1) {
    if (group[i].checked) value.add(group[i].__value);
  }
  if (!checked) {
    value.delete(__value);
  }
  return Array.from(value);
}
function init_binding_group(group) {
  let _inputs;
  return {
    /* push */
    p(...inputs) {
      _inputs = inputs;
      _inputs.forEach((input) => group.push(input));
    },
    /* remove */
    r() {
      _inputs.forEach((input) => group.splice(group.indexOf(input), 1));
    }
  };
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.data === data) return;
  text2.data = /** @type {string} */
  data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function select_option(select, value, mounting) {
  for (let i = 0; i < select.options.length; i += 1) {
    const option = select.options[i];
    if (option.__value === value) {
      option.selected = true;
      return;
    }
  }
  if (!mounting || value !== void 0) {
    select.selectedIndex = -1;
  }
}
function select_value(select) {
  const selected_option = select.querySelector(":checked");
  return selected_option && selected_option.__value;
}
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
  return new CustomEvent(type, { detail, bubbles, cancelable });
}
function get_custom_elements_slots(element2) {
  const result = {};
  element2.childNodes.forEach(
    /** @param {Element} node */
    (node) => {
      result[node.slot || "default"] = true;
    }
  );
  return result;
}

// node_modules/svelte/src/runtime/internal/lifecycle.js
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component) throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function createEventDispatcher() {
  const component = get_current_component();
  return (type, detail, { cancelable = false } = {}) => {
    const callbacks = component.$$.callbacks[type];
    if (callbacks) {
      const event = custom_event(
        /** @type {string} */
        type,
        detail,
        { cancelable }
      );
      callbacks.slice().forEach((fn) => {
        fn.call(component, event);
      });
      return !event.defaultPrevented;
    }
    return true;
  };
}
function bubble(component, event) {
  const callbacks = component.$$.callbacks[event.type];
  if (callbacks) {
    callbacks.slice().forEach((fn) => fn.call(this, event));
  }
}

// node_modules/svelte/src/runtime/internal/scheduler.js
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = /* @__PURE__ */ Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function tick() {
  schedule_update();
  return resolved_promise;
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
function add_flush_callback(fn) {
  flush_callbacks.push(fn);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length) binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
  targets.forEach((c) => c());
  render_callbacks = filtered;
}

// node_modules/svelte/src/runtime/internal/transitions.js
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block)) return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2) block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}

// node_modules/svelte/src/runtime/internal/each.js
function ensure_array_like(array_like_or_iterator) {
  return (array_like_or_iterator == null ? void 0 : array_like_or_iterator.length) !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
}
function outro_and_destroy_block(block, lookup) {
  transition_out(block, 1, 1, () => {
    lookup.delete(block.key);
  });
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block8, next, get_context) {
  let o = old_blocks.length;
  let n = list.length;
  let i = o;
  const old_indexes = {};
  while (i--) old_indexes[old_blocks[i].key] = i;
  const new_blocks = [];
  const new_lookup = /* @__PURE__ */ new Map();
  const deltas = /* @__PURE__ */ new Map();
  const updates = [];
  i = n;
  while (i--) {
    const child_ctx = get_context(ctx, list, i);
    const key = get_key(child_ctx);
    let block = lookup.get(key);
    if (!block) {
      block = create_each_block8(key, child_ctx);
      block.c();
    } else if (dynamic) {
      updates.push(() => block.p(child_ctx, dirty));
    }
    new_lookup.set(key, new_blocks[i] = block);
    if (key in old_indexes) deltas.set(key, Math.abs(i - old_indexes[key]));
  }
  const will_move = /* @__PURE__ */ new Set();
  const did_move = /* @__PURE__ */ new Set();
  function insert2(block) {
    transition_in(block, 1);
    block.m(node, next);
    lookup.set(block.key, block);
    next = block.first;
    n--;
  }
  while (o && n) {
    const new_block = new_blocks[n - 1];
    const old_block = old_blocks[o - 1];
    const new_key = new_block.key;
    const old_key = old_block.key;
    if (new_block === old_block) {
      next = new_block.first;
      o--;
      n--;
    } else if (!new_lookup.has(old_key)) {
      destroy(old_block, lookup);
      o--;
    } else if (!lookup.has(new_key) || will_move.has(new_key)) {
      insert2(new_block);
    } else if (did_move.has(old_key)) {
      o--;
    } else if (deltas.get(new_key) > deltas.get(old_key)) {
      did_move.add(new_key);
      insert2(new_block);
    } else {
      will_move.add(old_key);
      o--;
    }
  }
  while (o--) {
    const old_block = old_blocks[o];
    if (!new_lookup.has(old_block.key)) destroy(old_block, lookup);
  }
  while (n) insert2(new_blocks[n - 1]);
  run_all(updates);
  return new_blocks;
}

// node_modules/svelte/src/shared/boolean_attributes.js
var _boolean_attributes = (
  /** @type {const} */
  [
    "allowfullscreen",
    "allowpaymentrequest",
    "async",
    "autofocus",
    "autoplay",
    "checked",
    "controls",
    "default",
    "defer",
    "disabled",
    "formnovalidate",
    "hidden",
    "inert",
    "ismap",
    "loop",
    "multiple",
    "muted",
    "nomodule",
    "novalidate",
    "open",
    "playsinline",
    "readonly",
    "required",
    "reversed",
    "selected"
  ]
);
var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);

// node_modules/svelte/src/runtime/internal/Component.js
function bind(component, name, callback) {
  const index = component.$$.props[name];
  if (index !== void 0) {
    component.$$.bound[index] = callback;
    callback(component.$$.ctx[index]);
  }
}
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  add_render_callback(() => {
    const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
    if (component.$$.on_destroy) {
      component.$$.on_destroy.push(...new_on_destroy);
    } else {
      run_all(new_on_destroy);
    }
    component.$$.on_mount = [];
  });
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance8, create_fragment8, not_equal, props, append_styles2 = null, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance8 ? instance8(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);
      if (ready) make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro) transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor($$componentCtor, $$slots, use_shadow_dom) {
      super();
      /** The Svelte component constructor */
      __publicField(this, "$$ctor");
      /** Slots */
      __publicField(this, "$$s");
      /** The Svelte component instance */
      __publicField(this, "$$c");
      /** Whether or not the custom element is connected */
      __publicField(this, "$$cn", false);
      /** Component props data */
      __publicField(this, "$$d", {});
      /** `true` if currently in the process of reflecting component props back to attributes */
      __publicField(this, "$$r", false);
      /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
      __publicField(this, "$$p_d", {});
      /** @type {Record<string, Function[]>} Event listeners */
      __publicField(this, "$$l", {});
      /** @type {Map<Function, Function>} Event listener unsubscribe functions */
      __publicField(this, "$$l_u", /* @__PURE__ */ new Map());
      this.$$ctor = $$componentCtor;
      this.$$s = $$slots;
      if (use_shadow_dom) {
        this.attachShadow({ mode: "open" });
      }
    }
    addEventListener(type, listener, options) {
      this.$$l[type] = this.$$l[type] || [];
      this.$$l[type].push(listener);
      if (this.$$c) {
        const unsub = this.$$c.$on(type, listener);
        this.$$l_u.set(listener, unsub);
      }
      super.addEventListener(type, listener, options);
    }
    removeEventListener(type, listener, options) {
      super.removeEventListener(type, listener, options);
      if (this.$$c) {
        const unsub = this.$$l_u.get(listener);
        if (unsub) {
          unsub();
          this.$$l_u.delete(listener);
        }
      }
      if (this.$$l[type]) {
        const idx = this.$$l[type].indexOf(listener);
        if (idx >= 0) {
          this.$$l[type].splice(idx, 1);
        }
      }
    }
    async connectedCallback() {
      this.$$cn = true;
      if (!this.$$c) {
        let create_slot = function(name) {
          return () => {
            let node;
            const obj = {
              c: function create() {
                node = element("slot");
                if (name !== "default") {
                  attr(node, "name", name);
                }
              },
              /**
               * @param {HTMLElement} target
               * @param {HTMLElement} [anchor]
               */
              m: function mount(target, anchor) {
                insert(target, node, anchor);
              },
              d: function destroy(detaching) {
                if (detaching) {
                  detach(node);
                }
              }
            };
            return obj;
          };
        };
        await Promise.resolve();
        if (!this.$$cn || this.$$c) {
          return;
        }
        const $$slots = {};
        const existing_slots = get_custom_elements_slots(this);
        for (const name of this.$$s) {
          if (name in existing_slots) {
            $$slots[name] = [create_slot(name)];
          }
        }
        for (const attribute of this.attributes) {
          const name = this.$$g_p(attribute.name);
          if (!(name in this.$$d)) {
            this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, "toProp");
          }
        }
        for (const key in this.$$p_d) {
          if (!(key in this.$$d) && this[key] !== void 0) {
            this.$$d[key] = this[key];
            delete this[key];
          }
        }
        this.$$c = new this.$$ctor({
          target: this.shadowRoot || this,
          props: {
            ...this.$$d,
            $$slots,
            $$scope: {
              ctx: []
            }
          }
        });
        const reflect_attributes = () => {
          this.$$r = true;
          for (const key in this.$$p_d) {
            this.$$d[key] = this.$$c.$$.ctx[this.$$c.$$.props[key]];
            if (this.$$p_d[key].reflect) {
              const attribute_value = get_custom_element_value(
                key,
                this.$$d[key],
                this.$$p_d,
                "toAttribute"
              );
              if (attribute_value == null) {
                this.removeAttribute(this.$$p_d[key].attribute || key);
              } else {
                this.setAttribute(this.$$p_d[key].attribute || key, attribute_value);
              }
            }
          }
          this.$$r = false;
        };
        this.$$c.$$.after_update.push(reflect_attributes);
        reflect_attributes();
        for (const type in this.$$l) {
          for (const listener of this.$$l[type]) {
            const unsub = this.$$c.$on(type, listener);
            this.$$l_u.set(listener, unsub);
          }
        }
        this.$$l = {};
      }
    }
    // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
    // and setting attributes through setAttribute etc, this is helpful
    attributeChangedCallback(attr2, _oldValue, newValue) {
      var _a;
      if (this.$$r) return;
      attr2 = this.$$g_p(attr2);
      this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, "toProp");
      (_a = this.$$c) == null ? void 0 : _a.$set({ [attr2]: this.$$d[attr2] });
    }
    disconnectedCallback() {
      this.$$cn = false;
      Promise.resolve().then(() => {
        if (!this.$$cn && this.$$c) {
          this.$$c.$destroy();
          this.$$c = void 0;
        }
      });
    }
    $$g_p(attribute_name) {
      return Object.keys(this.$$p_d).find(
        (key) => this.$$p_d[key].attribute === attribute_name || !this.$$p_d[key].attribute && key.toLowerCase() === attribute_name
      ) || attribute_name;
    }
  };
}
function get_custom_element_value(prop, value, props_definition, transform) {
  var _a;
  const type = (_a = props_definition[prop]) == null ? void 0 : _a.type;
  value = type === "Boolean" && typeof value !== "boolean" ? value != null : value;
  if (!transform || !props_definition[prop]) {
    return value;
  } else if (transform === "toAttribute") {
    switch (type) {
      case "Object":
      case "Array":
        return value == null ? null : JSON.stringify(value);
      case "Boolean":
        return value ? "" : null;
      case "Number":
        return value == null ? null : value;
      default:
        return value;
    }
  } else {
    switch (type) {
      case "Object":
      case "Array":
        return value && JSON.parse(value);
      case "Boolean":
        return value;
      // conversion already handled above
      case "Number":
        return value != null ? +value : value;
      default:
        return value;
    }
  }
}
var SvelteComponent = class {
  constructor() {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$");
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1) callbacks.splice(index, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(props) {
    if (this.$$set && !is_empty(props)) {
      this.$$.skip_bound = true;
      this.$$set(props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/svelte/src/shared/version.js
var PUBLIC_VERSION = "4";

// node_modules/svelte/src/runtime/internal/disclose-version/index.js
if (typeof window !== "undefined")
  (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);

// node_modules/tslib/tslib.es6.js
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// src/AddPropInput.svelte
function add_css(target) {
  append_styles(target, "svelte-33qhuc", "input.svelte-33qhuc{max-height:25px;overflow-x:auto}select.svelte-33qhuc{height:21px}#name-input.svelte-33qhuc{flex-grow:0;width:auto}.modal-input-container.svelte-33qhuc{width:95%;display:flex;flex-direction:row;align-items:center;gap:10px;margin-top:10px}.btn-inactive.svelte-33qhuc{cursor:not-allowed;pointer-events:none;opacity:0.7}");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[19] = list[i];
  return child_ctx;
}
function create_each_block(ctx) {
  let option;
  let t_value = (
    /*key*/
    ctx[19] + ""
  );
  let t;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = option_value_value = /*options*/
      ctx[8][
        /*key*/
        ctx[19]
      ];
      set_input_value(option, option.__value);
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(option);
      }
    }
  };
}
function create_fragment(ctx) {
  let div;
  let button;
  let t0;
  let button_class_value;
  let button_tabindex_value;
  let t1;
  let select;
  let t2;
  let input0;
  let t3;
  let input1;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(Object.keys(
    /*options*/
    ctx[8]
  ));
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  return {
    c() {
      div = element("div");
      button = element("button");
      t0 = text("X");
      t1 = space();
      select = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t2 = space();
      input0 = element("input");
      t3 = space();
      input1 = element("input");
      attr(button, "type", "button");
      attr(button, "id", "del-btn");
      attr(button, "class", button_class_value = "btn-del " + /*isFirst*/
      (ctx[2] ? "btn-inactive" : "") + " svelte-33qhuc");
      attr(button, "tabindex", button_tabindex_value = /*isFirst*/
      ctx[2] ? -1 : 0);
      attr(select, "id", "type-input");
      attr(select, "class", "flex-obj svelte-33qhuc");
      if (
        /*optionVal*/
        ctx[7] === void 0
      ) add_render_callback(() => (
        /*select_change_handler*/
        ctx[12].call(select)
      ));
      attr(input0, "id", "name-input");
      attr(input0, "class", "name-input flex-obj svelte-33qhuc");
      attr(input0, "type", "text");
      attr(input0, "name", "name[]");
      attr(input0, "placeholder", "name");
      input0.required = true;
      attr(input1, "id", "value-input");
      attr(input1, "type", "text");
      attr(input1, "name", "value[]");
      attr(input1, "placeholder", "value");
      attr(input1, "class", "value-input flex-obj svelte-33qhuc");
      attr(div, "class", "modal-input-container svelte-33qhuc");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      append(button, t0);
      append(div, t1);
      append(div, select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select, null);
        }
      }
      select_option(
        select,
        /*optionVal*/
        ctx[7],
        true
      );
      append(div, t2);
      append(div, input0);
      ctx[14](input0);
      set_input_value(
        input0,
        /*nameVal*/
        ctx[0]
      );
      append(div, t3);
      append(div, input1);
      ctx[16](input1);
      set_input_value(
        input1,
        /*valueVal*/
        ctx[1]
      );
      if (!mounted) {
        dispose = [
          listen(
            button,
            "click",
            /*click_handler*/
            ctx[11]
          ),
          listen(
            select,
            "change",
            /*select_change_handler*/
            ctx[12]
          ),
          listen(
            select,
            "change",
            /*change_handler*/
            ctx[13]
          ),
          listen(
            input0,
            "input",
            /*input0_input_handler*/
            ctx[15]
          ),
          listen(
            input1,
            "input",
            /*input1_input_handler*/
            ctx[17]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*isFirst*/
      4 && button_class_value !== (button_class_value = "btn-del " + /*isFirst*/
      (ctx2[2] ? "btn-inactive" : "") + " svelte-33qhuc")) {
        attr(button, "class", button_class_value);
      }
      if (dirty & /*isFirst*/
      4 && button_tabindex_value !== (button_tabindex_value = /*isFirst*/
      ctx2[2] ? -1 : 0)) {
        attr(button, "tabindex", button_tabindex_value);
      }
      if (dirty & /*options, Object*/
      256) {
        each_value = ensure_array_like(Object.keys(
          /*options*/
          ctx2[8]
        ));
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*optionVal, options, Object*/
      384) {
        select_option(
          select,
          /*optionVal*/
          ctx2[7]
        );
      }
      if (dirty & /*nameVal*/
      1 && input0.value !== /*nameVal*/
      ctx2[0]) {
        set_input_value(
          input0,
          /*nameVal*/
          ctx2[0]
        );
      }
      if (dirty & /*valueVal*/
      2 && input1.value !== /*valueVal*/
      ctx2[1]) {
        set_input_value(
          input1,
          /*valueVal*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
      ctx[14](null);
      ctx[16](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let { isFirst } = $$props;
  let { removeInput } = $$props;
  let { id } = $$props;
  let { typeVal = "text" } = $$props;
  let { nameVal = "" } = $$props;
  let { valueVal = "" } = $$props;
  let inputEl;
  let valueEl;
  let optionVal;
  const options = {
    Text: "string",
    Number: "number",
    Checkbox: "checkbox",
    Date: "date",
    Datetime: "datetime-local"
  };
  const convertProps = {
    text: "Text",
    multitext: "Text",
    number: "Number",
    checkbox: "Checkbox",
    date: "Date",
    datetime: "Datetime"
  };
  onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    yield tick();
    inputEl.focus();
    inputEl.select();
    $$invalidate(7, optionVal = options[convertProps[typeVal]]);
  }));
  function changeType(type) {
    $$invalidate(6, valueEl.type = type, valueEl);
  }
  const click_handler = () => {
    if (!isFirst) {
      removeInput(id);
    }
  };
  function select_change_handler() {
    optionVal = select_value(this);
    $$invalidate(7, optionVal);
    $$invalidate(8, options);
  }
  const change_handler = () => changeType(optionVal);
  function input0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputEl = $$value;
      $$invalidate(5, inputEl);
    });
  }
  function input0_input_handler() {
    nameVal = this.value;
    $$invalidate(0, nameVal);
  }
  function input1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      valueEl = $$value;
      $$invalidate(6, valueEl);
    });
  }
  function input1_input_handler() {
    valueVal = this.value;
    $$invalidate(1, valueVal);
  }
  $$self.$$set = ($$props2) => {
    if ("isFirst" in $$props2) $$invalidate(2, isFirst = $$props2.isFirst);
    if ("removeInput" in $$props2) $$invalidate(3, removeInput = $$props2.removeInput);
    if ("id" in $$props2) $$invalidate(4, id = $$props2.id);
    if ("typeVal" in $$props2) $$invalidate(10, typeVal = $$props2.typeVal);
    if ("nameVal" in $$props2) $$invalidate(0, nameVal = $$props2.nameVal);
    if ("valueVal" in $$props2) $$invalidate(1, valueVal = $$props2.valueVal);
  };
  return [
    nameVal,
    valueVal,
    isFirst,
    removeInput,
    id,
    inputEl,
    valueEl,
    optionVal,
    options,
    changeType,
    typeVal,
    click_handler,
    select_change_handler,
    change_handler,
    input0_binding,
    input0_input_handler,
    input1_binding,
    input1_input_handler
  ];
}
var AddPropInput = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        isFirst: 2,
        removeInput: 3,
        id: 4,
        typeVal: 10,
        nameVal: 0,
        valueVal: 1
      },
      add_css
    );
  }
};
var AddPropInput_default = AddPropInput;

// src/helpers.ts
function parseValue(input, type) {
  switch (type) {
    case "number":
      return Number(input.value);
    case "checkbox":
      return Boolean(input.checked);
    default:
      return input.value;
  }
}
function removeExtraCommas(str) {
  return str.replace(/^,*(.*?),*$/g, "$1").replace(/,{2,}/g, ",");
}
function cleanTags(str) {
  let cleanStr = str;
  for (let index in KNOWN_BAD_CHARACTERS) {
    cleanStr = cleanStr.replaceAll(KNOWN_BAD_CHARACTERS[index], "");
  }
  return cleanStr;
}
var KNOWN_BAD_CHARACTERS = [
  "\u2012",
  "\u2013",
  "\u2014",
  "\u2015",
  "\u204F",
  "\u203D",
  "\u2018",
  "\u201A",
  "\u201B",
  "\u2039",
  "\u203A",
  "\u201C",
  "\u201D",
  "\u201E",
  "\u201F",
  "\u2045",
  "\u2046",
  "\u204B",
  "\u204E",
  "\u2051",
  "\u2044",
  "\u204A",
  "\u2030",
  "\u2031",
  "\u2052",
  "\u2020",
  "\u2021",
  "\u2022",
  "\u2023",
  "\u2043",
  "\u204C",
  "\u204D",
  "\u2032",
  "\u2035",
  "\u2038",
  "\u203B",
  "\u2050",
  "\u2041",
  "\u2042",
  "\u2016",
  "\u2011",
  "\u2033",
  "\u2034",
  "\u2057",
  "\u2036",
  "\u2037",
  "`",
  "^",
  "\u203E",
  "\u2017",
  "\u2053",
  ";",
  ":",
  "!",
  "\u203C",
  "\u2049",
  "?",
  "\u2048",
  "\u2047",
  ".",
  "\u2024",
  "\u2025",
  "\u2026",
  "'",
  '"',
  "(",
  ")",
  "[",
  "]",
  "{",
  "}",
  "@",
  "*",
  "&",
  "%",
  "\u2054",
  "+",
  "<",
  "=",
  ">",
  "|",
  "~",
  "$",
  "\u2055",
  "\u2056",
  "\u2058",
  "\u2059",
  "\u205A",
  "\u205B",
  "\u205C",
  "\u205D",
  "\u205E",
  "\u2E00",
  "\u2E01",
  "\u2E02",
  "\u2E03",
  "\u2E04",
  "\u2E05",
  "\u2E06",
  "\u2E07",
  "\u2E08",
  "\u2E09",
  "\u2E0A",
  "\u2E0B",
  "\u2E0C",
  "\u2E0D",
  "\u2E0E",
  "\u2E0F",
  "\u2E10",
  "\u2E11",
  "\u2E12",
  "\u2E13",
  "\u2E14",
  "\u2E15",
  "\u2E16",
  "\u2E17",
  "\u2E1C",
  "\u2E1D",
  " ",
  "#"
];

// src/AddPropForm.svelte
var { Map: Map_1 } = globals;
function add_css2(target) {
  append_styles(target, "svelte-1lpixw8", ".modal-inputs-container.svelte-1lpixw8{height:200px;width:100%;overflow-y:scroll;border-radius:5px;border-style:solid;display:flex;flex-direction:column;align-items:center}.modal-add-container.svelte-1lpixw8{margin-top:10px}.alert-container.svelte-1lpixw8{display:flex;flex-direction:column;align-items:center;justify-content:center;margin-bottom:10px;background-color:red;font-weight:bold}.hidden.svelte-1lpixw8{display:none}");
}
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i];
  child_ctx[24] = list;
  child_ctx[25] = i;
  return child_ctx;
}
function create_each_block2(key_1, ctx) {
  let first;
  let propinput;
  let updating_typeVal;
  let updating_nameVal;
  let updating_valueVal;
  let current;
  function propinput_typeVal_binding(value) {
    ctx[15](
      value,
      /*input*/
      ctx[23]
    );
  }
  function propinput_nameVal_binding(value) {
    ctx[16](
      value,
      /*input*/
      ctx[23]
    );
  }
  function propinput_valueVal_binding(value) {
    ctx[17](
      value,
      /*input*/
      ctx[23]
    );
  }
  let propinput_props = {
    isFirst: (
      /*input*/
      ctx[23].isFirst
    ),
    id: (
      /*input*/
      ctx[23].id
    ),
    removeInput: (
      /*removeInput*/
      ctx[8]
    )
  };
  if (
    /*input*/
    ctx[23].typeDef !== void 0
  ) {
    propinput_props.typeVal = /*input*/
    ctx[23].typeDef;
  }
  if (
    /*input*/
    ctx[23].nameDef !== void 0
  ) {
    propinput_props.nameVal = /*input*/
    ctx[23].nameDef;
  }
  if (
    /*input*/
    ctx[23].valueDef !== void 0
  ) {
    propinput_props.valueVal = /*input*/
    ctx[23].valueDef;
  }
  propinput = new AddPropInput_default({ props: propinput_props });
  binding_callbacks.push(() => bind(propinput, "typeVal", propinput_typeVal_binding));
  binding_callbacks.push(() => bind(propinput, "nameVal", propinput_nameVal_binding));
  binding_callbacks.push(() => bind(propinput, "valueVal", propinput_valueVal_binding));
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(propinput.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(propinput, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const propinput_changes = {};
      if (dirty & /*inputEls*/
      32) propinput_changes.isFirst = /*input*/
      ctx[23].isFirst;
      if (dirty & /*inputEls*/
      32) propinput_changes.id = /*input*/
      ctx[23].id;
      if (!updating_typeVal && dirty & /*inputEls*/
      32) {
        updating_typeVal = true;
        propinput_changes.typeVal = /*input*/
        ctx[23].typeDef;
        add_flush_callback(() => updating_typeVal = false);
      }
      if (!updating_nameVal && dirty & /*inputEls*/
      32) {
        updating_nameVal = true;
        propinput_changes.nameVal = /*input*/
        ctx[23].nameDef;
        add_flush_callback(() => updating_nameVal = false);
      }
      if (!updating_valueVal && dirty & /*inputEls*/
      32) {
        updating_valueVal = true;
        propinput_changes.valueVal = /*input*/
        ctx[23].valueDef;
        add_flush_callback(() => updating_valueVal = false);
      }
      propinput.$set(propinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(propinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(propinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(propinput, detaching);
    }
  };
}
function create_fragment2(ctx) {
  let div6;
  let div2;
  let div0;
  let t1;
  let div1;
  let t2;
  let t3;
  let p0;
  let t5;
  let p1;
  let t6;
  let t7;
  let t8;
  let t9;
  let p2;
  let t11;
  let form;
  let label;
  let input_1;
  let t12_value = "Overwrite existing properties";
  let t12;
  let t13;
  let div3;
  let each_blocks = [];
  let each_1_lookup = new Map_1();
  let t14;
  let div4;
  let button0;
  let t16;
  let div5;
  let button1;
  let current;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*inputEls*/
    ctx[5]
  );
  const get_key = (ctx2) => (
    /*input*/
    ctx2[23].id
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context2(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block2(key, child_ctx));
  }
  return {
    c() {
      div6 = element("div");
      div2 = element("div");
      div0 = element("div");
      div0.textContent = "ERROR";
      t1 = space();
      div1 = element("div");
      t2 = text(
        /*alertText*/
        ctx[4]
      );
      t3 = space();
      p0 = element("p");
      p0.textContent = "Type in a property name, then value. Use the dropbox to choose what type of\n    data you wish to store.";
      t5 = space();
      p1 = element("p");
      t6 = text('If you want to make a List property, use the Text data type and separate\n    each value with a "');
      t7 = text(
        /*delimiter*/
        ctx[1]
      );
      t8 = text('".');
      t9 = space();
      p2 = element("p");
      p2.textContent = 'If you want to add Tags, use the name "tags".';
      t11 = space();
      form = element("form");
      label = element("label");
      input_1 = element("input");
      t12 = text(t12_value);
      t13 = space();
      div3 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t14 = space();
      div4 = element("div");
      button0 = element("button");
      button0.textContent = "Add";
      t16 = space();
      div5 = element("div");
      button1 = element("button");
      button1.textContent = "Submit";
      attr(div1, "id", "alert-text");
      attr(div2, "id", "alert-container");
      attr(div2, "class", "alert-container hidden svelte-1lpixw8");
      attr(input_1, "type", "checkbox");
      input_1.checked = /*overwrite*/
      ctx[0];
      attr(div3, "class", "modal-inputs-container svelte-1lpixw8");
      attr(button0, "type", "button");
      attr(button0, "class", "a-btn");
      attr(div4, "class", "modal-add-container svelte-1lpixw8");
      attr(button1, "class", "btn-submit");
      attr(div5, "class", "modal-button-container");
      attr(div6, "id", "multi-properties-modal");
      attr(div6, "class", "modal-content");
    },
    m(target, anchor) {
      insert(target, div6, anchor);
      append(div6, div2);
      append(div2, div0);
      append(div2, t1);
      append(div2, div1);
      append(div1, t2);
      ctx[14](div2);
      append(div6, t3);
      append(div6, p0);
      append(div6, t5);
      append(div6, p1);
      append(p1, t6);
      append(p1, t7);
      append(p1, t8);
      append(div6, t9);
      append(div6, p2);
      append(div6, t11);
      append(div6, form);
      append(form, label);
      append(label, input_1);
      append(label, t12);
      append(form, t13);
      append(form, div3);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div3, null);
        }
      }
      append(form, t14);
      append(form, div4);
      append(div4, button0);
      append(form, t16);
      append(form, div5);
      append(div5, button1);
      ctx[19](form);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input_1,
            "change",
            /*onCheckboxChange*/
            ctx[6]
          ),
          listen(
            button0,
            "click",
            /*click_handler*/
            ctx[18]
          ),
          listen(
            button1,
            "click",
            /*onSubmit*/
            ctx[9]
          ),
          listen(form, "submit", prevent_default(
            /*submit_handler*/
            ctx[13]
          ))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*alertText*/
      16) set_data(
        t2,
        /*alertText*/
        ctx2[4]
      );
      if (!current || dirty & /*delimiter*/
      2) set_data(
        t7,
        /*delimiter*/
        ctx2[1]
      );
      if (!current || dirty & /*overwrite*/
      1) {
        input_1.checked = /*overwrite*/
        ctx2[0];
      }
      if (dirty & /*inputEls, removeInput*/
      288) {
        each_value = ensure_array_like(
          /*inputEls*/
          ctx2[5]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div3, outro_and_destroy_block, create_each_block2, null, get_each_context2);
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div6);
      }
      ctx[14](null);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      ctx[19](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let { submission } = $$props;
  let { overwrite } = $$props;
  let { delimiter } = $$props;
  let { defaultProps } = $$props;
  let { changeBool } = $$props;
  let countInputs = 0;
  let formEl;
  let errorEl;
  let alertText = ".";
  let inputEls = [];
  function onCheckboxChange() {
    $$invalidate(0, overwrite = !overwrite);
    changeBool(overwrite);
  }
  onMount(() => {
    defaultProps.length > 0 ? addInputs(defaultProps) : addInputs([{ type: "text", name: "", value: "" }]);
  });
  function addInputs(inputs = [{ type: "text", name: "", value: "" }]) {
    let arr = [];
    for (let input of inputs) {
      countInputs++;
      arr.push({
        id: countInputs,
        isFirst: countInputs === 1 ? true : false,
        typeDef: input.type,
        nameDef: input.name,
        valueDef: input.value
      });
    }
    $$invalidate(5, inputEls = [...inputEls, ...arr]);
  }
  function removeInput(id) {
    return __awaiter(this, void 0, void 0, function* () {
      $$invalidate(5, inputEls = inputEls.filter((input) => input.id !== id));
      yield tick();
      let inputs = formEl.querySelectorAll("input");
      if (!inputs) return;
      inputs[inputs.length - 2].focus();
    });
  }
  function checkDuplicateNames() {
    let set = /* @__PURE__ */ new Set();
    for (let input of inputEls) set.add(input.nameDef);
    if (set.size < inputEls.length) return true;
    else return false;
  }
  function runError(errorText) {
    $$invalidate(4, alertText = errorText);
    errorEl.classList.remove("hidden");
  }
  function onSubmit() {
    if (checkDuplicateNames()) {
      runError("Duplicate property names are not allowed.");
      return;
    }
    let obj = /* @__PURE__ */ new Map();
    let inputs = formEl.querySelectorAll('input[name^="name[]"]');
    inputs.forEach((input) => {
      var _a;
      if (!(input.nextElementSibling instanceof HTMLInputElement)) return;
      if (!(input.previousElementSibling instanceof HTMLSelectElement)) return;
      if (!(input.previousElementSibling.children[0] instanceof HTMLOptionElement)) return;
      let name = input.value;
      if (name === "") {
        input.reportValidity();
        return;
      }
      const selectEl = input.previousElementSibling;
      const htmlType = selectEl.value;
      const reverseOptions = {
        "string": "text",
        "number": "number",
        "checkbox": "checkbox",
        "date": "date",
        "datetime-local": "datetime"
      };
      const obsidianType = (_a = reverseOptions[htmlType]) !== null && _a !== void 0 ? _a : "text";
      let value = parseValue(input.nextElementSibling, input.nextElementSibling.type);
      if (typeof value === "string") {
        if (name === "tags") {
          value = cleanTags(value);
        }
        if (typeof value === "string" && value.includes(",")) {
          let str = removeExtraCommas(value);
          value = str.split(delimiter);
        }
      }
      if (value === "") value = null;
      let propObj = {
        type: obsidianType,
        data: value,
        overwrite: false,
        delimiter
      };
      obj.set(name, propObj);
    });
    if (obj.size < inputs.length) return;
    console.log(obj);
    submission(obj);
  }
  function submit_handler(event) {
    bubble.call(this, $$self, event);
  }
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      errorEl = $$value;
      $$invalidate(3, errorEl);
    });
  }
  function propinput_typeVal_binding(value, input) {
    if ($$self.$$.not_equal(input.typeDef, value)) {
      input.typeDef = value;
      $$invalidate(5, inputEls);
    }
  }
  function propinput_nameVal_binding(value, input) {
    if ($$self.$$.not_equal(input.nameDef, value)) {
      input.nameDef = value;
      $$invalidate(5, inputEls);
    }
  }
  function propinput_valueVal_binding(value, input) {
    if ($$self.$$.not_equal(input.valueDef, value)) {
      input.valueDef = value;
      $$invalidate(5, inputEls);
    }
  }
  const click_handler = () => addInputs([{ type: "text", name: "", value: "" }]);
  function form_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      formEl = $$value;
      $$invalidate(2, formEl);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("submission" in $$props2) $$invalidate(10, submission = $$props2.submission);
    if ("overwrite" in $$props2) $$invalidate(0, overwrite = $$props2.overwrite);
    if ("delimiter" in $$props2) $$invalidate(1, delimiter = $$props2.delimiter);
    if ("defaultProps" in $$props2) $$invalidate(11, defaultProps = $$props2.defaultProps);
    if ("changeBool" in $$props2) $$invalidate(12, changeBool = $$props2.changeBool);
  };
  return [
    overwrite,
    delimiter,
    formEl,
    errorEl,
    alertText,
    inputEls,
    onCheckboxChange,
    addInputs,
    removeInput,
    onSubmit,
    submission,
    defaultProps,
    changeBool,
    submit_handler,
    div2_binding,
    propinput_typeVal_binding,
    propinput_nameVal_binding,
    propinput_valueVal_binding,
    click_handler,
    form_binding
  ];
}
var AddPropForm = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance2,
      create_fragment2,
      safe_not_equal,
      {
        submission: 10,
        overwrite: 0,
        delimiter: 1,
        defaultProps: 11,
        changeBool: 12
      },
      add_css2
    );
  }
};
var AddPropForm_default = AddPropForm;

// src/AddConfirmModal.ts
var import_obsidian = require("obsidian");

// src/AddConfirmForm.svelte
function add_css3(target) {
  append_styles(target, "svelte-vt02cj", ".msg.svelte-vt02cj{font-weight:bold;padding-bottom:10px}");
}
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i][0];
  child_ctx[8] = list[i][1];
  return child_ctx;
}
function create_each_block3(ctx) {
  let li;
  let t0_value = (
    /*propName*/
    ctx[7] + ""
  );
  let t0;
  let t1;
  let t2_value = (
    /*prop*/
    ctx[8].data + ""
  );
  let t2;
  let t3;
  return {
    c() {
      li = element("li");
      t0 = text(t0_value);
      t1 = text(": ");
      t2 = text(t2_value);
      t3 = space();
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, t0);
      append(li, t1);
      append(li, t2);
      append(li, t3);
    },
    p(ctx2, dirty) {
      if (dirty & /*props*/
      1 && t0_value !== (t0_value = /*propName*/
      ctx2[7] + "")) set_data(t0, t0_value);
      if (dirty & /*props*/
      1 && t2_value !== (t2_value = /*prop*/
      ctx2[8].data + "")) set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
    }
  };
}
function create_fragment3(ctx) {
  let div;
  let form;
  let p0;
  let t1;
  let p1;
  let t3;
  let ul;
  let t4;
  let p2;
  let t6;
  let button0;
  let t8;
  let button1;
  let mounted;
  let dispose;
  let each_value = ensure_array_like([.../*props*/
  ctx[0]]);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  return {
    c() {
      div = element("div");
      form = element("form");
      p0 = element("p");
      p0.textContent = `${/*msg*/
      ctx[4]}`;
      t1 = space();
      p1 = element("p");
      p1.textContent = "The following props will be added:";
      t3 = space();
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t4 = space();
      p2 = element("p");
      p2.textContent = "Are you sure you wish to proceed?";
      t6 = space();
      button0 = element("button");
      button0.textContent = "Confirm";
      t8 = space();
      button1 = element("button");
      button1.textContent = "Cancel";
      attr(p0, "class", "msg svelte-vt02cj");
      attr(button0, "class", "mod-warning");
      attr(button0, "type", "submit");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, form);
      append(form, p0);
      append(form, t1);
      append(form, p1);
      append(form, t3);
      append(form, ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ul, null);
        }
      }
      append(form, t4);
      append(form, p2);
      append(form, t6);
      append(form, button0);
      append(form, t8);
      append(form, button1);
      ctx[6](button1);
      if (!mounted) {
        dispose = [
          listen(button1, "click", function() {
            if (is_function(
              /*cancel*/
              ctx[2]
            )) ctx[2].apply(this, arguments);
          }),
          listen(form, "submit", prevent_default(function() {
            if (is_function(
              /*submission*/
              ctx[1]
            )) ctx[1].apply(this, arguments);
          }))
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (dirty & /*props*/
      1) {
        each_value = ensure_array_like([.../*props*/
        ctx[0]]);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ul, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
      ctx[6](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance3($$self, $$props, $$invalidate) {
  let { props } = $$props;
  let { overwrite = true } = $$props;
  let { submission } = $$props;
  let { cancel } = $$props;
  let btnCancel;
  const msg = overwrite ? "Any pre-existing text props will have their values overwritten." : "Any pre-existing text props will have their values be appended to.";
  onMount(() => {
    btnCancel.focus();
  });
  function button1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      btnCancel = $$value;
      $$invalidate(3, btnCancel);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("props" in $$props2) $$invalidate(0, props = $$props2.props);
    if ("overwrite" in $$props2) $$invalidate(5, overwrite = $$props2.overwrite);
    if ("submission" in $$props2) $$invalidate(1, submission = $$props2.submission);
    if ("cancel" in $$props2) $$invalidate(2, cancel = $$props2.cancel);
  };
  return [props, submission, cancel, btnCancel, msg, overwrite, button1_binding];
}
var AddConfirmForm = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance3,
      create_fragment3,
      safe_not_equal,
      {
        props: 0,
        overwrite: 5,
        submission: 1,
        cancel: 2
      },
      add_css3
    );
  }
};
var AddConfirmForm_default = AddConfirmForm;

// src/AddConfirmModal.ts
var AddConfirmModal = class extends import_obsidian.Modal {
  constructor(app, props, overwrite, submission) {
    super(app);
    this.props = props;
    this.overwrite = overwrite;
    this.submission = submission;
  }
  async onSubmit() {
    await this.submission(true);
    this.close();
  }
  onCancel() {
    this.submission(false);
    this.close();
  }
  onOpen() {
    this.titleEl.createEl("h2", { text: "Add Properties" });
    this.component = new AddConfirmForm_default({
      target: this.contentEl,
      props: {
        props: this.props,
        overwrite: this.overwrite,
        submission: this.onSubmit.bind(this),
        cancel: this.onCancel.bind(this)
      }
    });
  }
};

// src/AddPropModal.ts
var PropModal = class extends import_obsidian2.Modal {
  constructor(app, submission, overwrite, delimiter, defaultProps, changeBool) {
    super(app);
    this.submission = submission;
    this.overwrite = overwrite;
    this.delimiter = delimiter;
    this.defaultProps = defaultProps;
    this.changeBool = changeBool;
  }
  //Run form submission if user clicks confirm.
  async onConfirm(bool) {
    if (bool) {
      await this.submission(this.props);
      this.close();
    }
  }
  updateBool(bool) {
    this.overwrite = bool;
    this.changeBool(bool);
  }
  //Pull up confirmation form when user submits base form.
  onSubmit(props) {
    this.props = props;
    new AddConfirmModal(
      this.app,
      this.props,
      this.overwrite,
      this.onConfirm.bind(this)
    ).open();
  }
  onOpen() {
    this.titleEl.createEl("h2", { text: "Add Properties" });
    this.component = new AddPropForm_default({
      target: this.contentEl,
      props: {
        submission: this.onSubmit.bind(this),
        overwrite: this.overwrite,
        delimiter: this.delimiter,
        defaultProps: this.defaultProps,
        changeBool: this.updateBool.bind(this)
      }
    });
  }
};

// src/AddValueModal.ts
var import_obsidian3 = require("obsidian");

// src/AddValueForm.svelte
function get_each_context4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list[i];
  return child_ctx;
}
function create_each_block4(ctx) {
  let option;
  let t_value = (
    /*prop*/
    ctx[9] + ""
  );
  let t;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = option_value_value = /*prop*/
      ctx[9];
      set_input_value(option, option.__value);
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*properties*/
      1 && t_value !== (t_value = /*prop*/
      ctx2[9] + "")) set_data(t, t_value);
      if (dirty & /*properties*/
      1 && option_value_value !== (option_value_value = /*prop*/
      ctx2[9])) {
        option.__value = option_value_value;
        set_input_value(option, option.__value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(option);
      }
    }
  };
}
function create_fragment4(ctx) {
  let form;
  let div2;
  let h2;
  let t1;
  let div0;
  let label0;
  let t3;
  let select;
  let option;
  let t5;
  let div1;
  let label1;
  let t7;
  let input;
  let t8;
  let div3;
  let button0;
  let t10;
  let button1;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*properties*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block4(get_each_context4(ctx, each_value, i));
  }
  return {
    c() {
      form = element("form");
      div2 = element("div");
      h2 = element("h2");
      h2.textContent = "Add Value to Property";
      t1 = space();
      div0 = element("div");
      label0 = element("label");
      label0.textContent = "Select Property";
      t3 = space();
      select = element("select");
      option = element("option");
      option.textContent = "Choose a property...";
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t5 = space();
      div1 = element("div");
      label1 = element("label");
      label1.textContent = "Value to Add";
      t7 = space();
      input = element("input");
      t8 = space();
      div3 = element("div");
      button0 = element("button");
      button0.textContent = "Add Value";
      t10 = space();
      button1 = element("button");
      button1.textContent = "Cancel";
      attr(label0, "for", "property-select");
      option.__value = "";
      set_input_value(option, option.__value);
      option.disabled = true;
      attr(select, "id", "property-select");
      select.required = true;
      if (
        /*selectedProperty*/
        ctx[1] === void 0
      ) add_render_callback(() => (
        /*select_change_handler*/
        ctx[6].call(select)
      ));
      attr(div0, "class", "form-group");
      attr(label1, "for", "value-input");
      attr(input, "id", "value-input");
      attr(input, "type", "text");
      input.required = true;
      attr(div1, "class", "form-group");
      attr(div2, "class", "modal-content");
      attr(button0, "type", "submit");
      attr(button0, "class", "mod-cta");
      attr(button1, "type", "button");
      attr(div3, "class", "modal-footer");
    },
    m(target, anchor) {
      insert(target, form, anchor);
      append(form, div2);
      append(div2, h2);
      append(div2, t1);
      append(div2, div0);
      append(div0, label0);
      append(div0, t3);
      append(div0, select);
      append(select, option);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select, null);
        }
      }
      select_option(
        select,
        /*selectedProperty*/
        ctx[1],
        true
      );
      append(div2, t5);
      append(div2, div1);
      append(div1, label1);
      append(div1, t7);
      append(div1, input);
      set_input_value(
        input,
        /*value*/
        ctx[2]
      );
      append(form, t8);
      append(form, div3);
      append(div3, button0);
      append(div3, t10);
      append(div3, button1);
      if (!mounted) {
        dispose = [
          listen(
            select,
            "change",
            /*select_change_handler*/
            ctx[6]
          ),
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[7]
          ),
          listen(
            button1,
            "click",
            /*click_handler*/
            ctx[8]
          ),
          listen(form, "submit", prevent_default(
            /*handleSubmit*/
            ctx[4]
          ))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*properties*/
      1) {
        each_value = ensure_array_like(
          /*properties*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context4(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block4(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*selectedProperty, properties*/
      3) {
        select_option(
          select,
          /*selectedProperty*/
          ctx2[1]
        );
      }
      if (dirty & /*value*/
      4 && input.value !== /*value*/
      ctx2[2]) {
        set_input_value(
          input,
          /*value*/
          ctx2[2]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(form);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance4($$self, $$props, $$invalidate) {
  let { properties } = $$props;
  let { onSubmit } = $$props;
  let selectedProperty = "";
  let value = "";
  const dispatch = createEventDispatcher();
  function handleSubmit() {
    if (selectedProperty && value) {
      onSubmit(selectedProperty, value);
      dispatch("submit");
    }
  }
  function select_change_handler() {
    selectedProperty = select_value(this);
    $$invalidate(1, selectedProperty);
    $$invalidate(0, properties);
  }
  function input_input_handler() {
    value = this.value;
    $$invalidate(2, value);
  }
  const click_handler = () => dispatch("cancel");
  $$self.$$set = ($$props2) => {
    if ("properties" in $$props2) $$invalidate(0, properties = $$props2.properties);
    if ("onSubmit" in $$props2) $$invalidate(5, onSubmit = $$props2.onSubmit);
  };
  return [
    properties,
    selectedProperty,
    value,
    dispatch,
    handleSubmit,
    onSubmit,
    select_change_handler,
    input_input_handler,
    click_handler
  ];
}
var AddValueForm = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance4, create_fragment4, safe_not_equal, { properties: 0, onSubmit: 5 });
  }
};
var AddValueForm_default = AddValueForm;

// src/AddValueModal.ts
var AddValueModal = class extends import_obsidian3.Modal {
  constructor(app, properties, onSubmit) {
    super(app);
    this.properties = properties;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    this.component = new AddValueForm_default({
      target: contentEl,
      props: {
        properties: this.properties,
        onSubmit: (selectedProperty, value) => {
          this.onSubmit(selectedProperty, value);
          this.close();
        }
      }
    });
    this.component.$on("cancel", () => {
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/SettingTab.ts
var import_obsidian4 = require("obsidian");
var SettingTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    let { containerEl } = this;
    containerEl.empty();
    new import_obsidian4.Setting(containerEl).setName("Overwrite existing text").setDesc(
      "When adding a property with a name that already exists, the text will overwrite the prop's existing value.  If left disabled, the new value will be appended to the old as a List."
    ).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.overwrite);
      toggle.onChange(async (value) => {
        this.plugin.settings.overwrite = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian4.Setting(containerEl).setName("Recursive Iteration").setDesc(
      "When toggled on, while looping through all files in a folder, you will also loop through any sub-folders."
    ).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.recursive);
      toggle.onChange(async (value) => {
        this.plugin.settings.recursive = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian4.Setting(containerEl).setName("List Delimiter").setDesc(
      "Set delimiter to use when creating a list.  Commas(,) are used by default."
    ).addText((text2) => {
      text2.setValue(this.plugin.settings.delimiter);
      text2.onChange(async (value) => {
        if (value.length > 1) {
          text2.setValue(value[0]);
          new import_obsidian4.Notice("Delimiter must be a single character.");
          return;
        }
        this.plugin.settings.delimiter = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian4.Setting(containerEl).setName("Default Props File").setDesc(
      "Select a file with properties that you want to load into the Multi Properties form by default.  Type in the full path of the desired file.(ex. Templates/PropFile 1)"
    ).addText((text2) => {
      text2.setValue(this.plugin.settings.defaultPropPath);
      text2.onChange(async (value) => {
        this.plugin.settings.defaultPropPath = value;
        await this.plugin.saveSettings();
      });
    });
  }
};

// src/RemoveModal.ts
var import_obsidian6 = require("obsidian");

// src/RemovePropForm.svelte
function add_css4(target) {
  append_styles(target, "svelte-zna8bm", ".name-container.svelte-zna8bm{display:flex;flex-direction:column;gap:5px;margin-top:10px;margin-bottom:20px}.alert-container.svelte-zna8bm{display:flex;flex-direction:column;align-items:center;justify-content:center;margin-bottom:10px;background-color:red;font-weight:bold}.button-container.svelte-zna8bm{display:flex;flex-direction:row;justify-content:space-between}.hidden.svelte-zna8bm{display:none}");
}
function get_each_context5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i];
  child_ctx[15] = list;
  child_ctx[16] = i;
  return child_ctx;
}
function create_each_block5(ctx) {
  let label;
  let input_1;
  let t0;
  let t1_value = (
    /*input*/
    ctx[14].name + ""
  );
  let t1;
  let t2;
  let mounted;
  let dispose;
  function input_1_change_handler() {
    ctx[12].call(
      input_1,
      /*each_value*/
      ctx[15],
      /*input_index*/
      ctx[16]
    );
  }
  return {
    c() {
      label = element("label");
      input_1 = element("input");
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      attr(input_1, "type", "checkbox");
    },
    m(target, anchor) {
      insert(target, label, anchor);
      append(label, input_1);
      set_input_value(
        input_1,
        /*input*/
        ctx[14].name
      );
      input_1.checked = /*input*/
      ctx[14].isChecked;
      append(label, t0);
      append(label, t1);
      append(label, t2);
      if (!mounted) {
        dispose = [
          listen(input_1, "change", input_1_change_handler),
          listen(
            input_1,
            "change",
            /*change_handler*/
            ctx[13]
          )
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*inputs*/
      8) {
        set_input_value(
          input_1,
          /*input*/
          ctx[14].name
        );
      }
      if (dirty & /*inputs*/
      8) {
        input_1.checked = /*input*/
        ctx[14].isChecked;
      }
      if (dirty & /*inputs*/
      8 && t1_value !== (t1_value = /*input*/
      ctx[14].name + "")) set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(label);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment5(ctx) {
  let div5;
  let div2;
  let div0;
  let t1;
  let div1;
  let t2;
  let t3;
  let p;
  let t5;
  let form;
  let div3;
  let t6;
  let div4;
  let button0;
  let t8;
  let button1;
  let t9_value = (
    /*isMaxChecked*/
    ctx[0] ? "Uncheck All" : "Check All"
  );
  let t9;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*inputs*/
    ctx[3]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block5(get_each_context5(ctx, each_value, i));
  }
  return {
    c() {
      div5 = element("div");
      div2 = element("div");
      div0 = element("div");
      div0.textContent = "ERROR";
      t1 = space();
      div1 = element("div");
      t2 = text(
        /*alertText*/
        ctx[2]
      );
      t3 = space();
      p = element("p");
      p.textContent = "Select the properties you wish to remove from the file selection.";
      t5 = space();
      form = element("form");
      div3 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t6 = space();
      div4 = element("div");
      button0 = element("button");
      button0.textContent = "Confirm";
      t8 = space();
      button1 = element("button");
      t9 = text(t9_value);
      attr(div1, "id", "alert-text");
      attr(div2, "id", "alert-container");
      attr(div2, "class", "alert-container hidden svelte-zna8bm");
      attr(div3, "class", "name-container svelte-zna8bm");
      attr(button0, "type", "submit");
      attr(div4, "class", "button-container svelte-zna8bm");
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div2);
      append(div2, div0);
      append(div2, t1);
      append(div2, div1);
      append(div1, t2);
      ctx[11](div2);
      append(div5, t3);
      append(div5, p);
      append(div5, t5);
      append(div5, form);
      append(form, div3);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div3, null);
        }
      }
      append(form, t6);
      append(form, div4);
      append(div4, button0);
      append(div4, t8);
      append(div4, button1);
      append(button1, t9);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*onSubmit*/
            ctx[6]
          ),
          listen(
            button1,
            "click",
            /*toggleAll*/
            ctx[5]
          ),
          listen(form, "submit", prevent_default(
            /*submit_handler*/
            ctx[10]
          ))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*alertText*/
      4) set_data(
        t2,
        /*alertText*/
        ctx2[2]
      );
      if (dirty & /*inputs, onCheckboxChange*/
      24) {
        each_value = ensure_array_like(
          /*inputs*/
          ctx2[3]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context5(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block5(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div3, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*isMaxChecked*/
      1 && t9_value !== (t9_value = /*isMaxChecked*/
      ctx2[0] ? "Uncheck All" : "Check All")) set_data(t9, t9_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div5);
      }
      ctx[11](null);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance5($$self, $$props, $$invalidate) {
  let isMaxChecked;
  let { names = [] } = $$props;
  let { submission } = $$props;
  let errorEl;
  let alertText = ".";
  let checkCount = 0;
  let inputs = [];
  for (let name of names) {
    inputs.push({ name, isChecked: false });
  }
  names.sort();
  function onCheckboxChange(event) {
    let checked = event.target.checked;
    checked ? $$invalidate(9, checkCount++, checkCount) : $$invalidate(9, checkCount--, checkCount);
  }
  function toggleAll() {
    if (isMaxChecked) {
      $$invalidate(3, inputs = inputs.map((input) => Object.assign(Object.assign({}, input), { isChecked: false })));
      $$invalidate(9, checkCount = 0);
    } else {
      $$invalidate(3, inputs = inputs.map((input) => Object.assign(Object.assign({}, input), { isChecked: true })));
      $$invalidate(9, checkCount = names.length);
    }
  }
  function onSubmit() {
    if (checkCount === 0) {
      $$invalidate(2, alertText = "Please select at least one property to remove.");
      errorEl.classList.remove("hidden");
      return;
    }
    let propNames = inputs.filter((input) => input.isChecked).map((input) => input.name);
    submission(propNames);
  }
  function submit_handler(event) {
    bubble.call(this, $$self, event);
  }
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      errorEl = $$value;
      $$invalidate(1, errorEl);
    });
  }
  function input_1_change_handler(each_value, input_index) {
    each_value[input_index].name = this.value;
    each_value[input_index].isChecked = this.checked;
    $$invalidate(3, inputs);
  }
  const change_handler = (event) => onCheckboxChange(event);
  $$self.$$set = ($$props2) => {
    if ("names" in $$props2) $$invalidate(7, names = $$props2.names);
    if ("submission" in $$props2) $$invalidate(8, submission = $$props2.submission);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*checkCount, names*/
    640) {
      $: $$invalidate(0, isMaxChecked = checkCount >= names.length);
    }
    if ($$self.$$.dirty & /*isMaxChecked*/
    1) {
      $: console.log(isMaxChecked);
    }
  };
  return [
    isMaxChecked,
    errorEl,
    alertText,
    inputs,
    onCheckboxChange,
    toggleAll,
    onSubmit,
    names,
    submission,
    checkCount,
    submit_handler,
    div2_binding,
    input_1_change_handler,
    change_handler
  ];
}
var RemovePropForm = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance5, create_fragment5, safe_not_equal, { names: 7, submission: 8 }, add_css4);
  }
};
var RemovePropForm_default = RemovePropForm;

// src/RemoveConfirmModal.ts
var import_obsidian5 = require("obsidian");

// src/RemoveConfirmForm.svelte
function get_each_context6(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  return child_ctx;
}
function create_each_block6(ctx) {
  let li;
  let t0_value = (
    /*name*/
    ctx[6] + ""
  );
  let t0;
  let t1;
  return {
    c() {
      li = element("li");
      t0 = text(t0_value);
      t1 = space();
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, t0);
      append(li, t1);
    },
    p(ctx2, dirty) {
      if (dirty & /*names*/
      1 && t0_value !== (t0_value = /*name*/
      ctx2[6] + "")) set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
    }
  };
}
function create_fragment6(ctx) {
  let div;
  let form;
  let p0;
  let t3;
  let ul;
  let t4;
  let p1;
  let t6;
  let button0;
  let t8;
  let button1;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*names*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block6(get_each_context6(ctx, each_value, i));
  }
  return {
    c() {
      div = element("div");
      form = element("form");
      p0 = element("p");
      p0.textContent = `The following ${/*word*/
      ctx[4]} will be removed:`;
      t3 = space();
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t4 = space();
      p1 = element("p");
      p1.textContent = "Are you sure you wish to proceed?";
      t6 = space();
      button0 = element("button");
      button0.textContent = "Delete";
      t8 = space();
      button1 = element("button");
      button1.textContent = "Cancel";
      attr(button0, "class", "mod-warning");
      attr(button0, "type", "submit");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, form);
      append(form, p0);
      append(form, t3);
      append(form, ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ul, null);
        }
      }
      append(form, t4);
      append(form, p1);
      append(form, t6);
      append(form, button0);
      append(form, t8);
      append(form, button1);
      ctx[5](button1);
      if (!mounted) {
        dispose = [
          listen(button1, "click", function() {
            if (is_function(
              /*cancel*/
              ctx[2]
            )) ctx[2].apply(this, arguments);
          }),
          listen(form, "submit", prevent_default(function() {
            if (is_function(
              /*submission*/
              ctx[1]
            )) ctx[1].apply(this, arguments);
          }))
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (dirty & /*names*/
      1) {
        each_value = ensure_array_like(
          /*names*/
          ctx[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context6(ctx, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block6(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ul, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
      ctx[5](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance6($$self, $$props, $$invalidate) {
  let { names = ["test", "test2"] } = $$props;
  let { submission } = $$props;
  let { cancel } = $$props;
  let btnCancel;
  const word = names.length > 1 ? "properties" : "property";
  onMount(() => {
    btnCancel.focus();
  });
  function button1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      btnCancel = $$value;
      $$invalidate(3, btnCancel);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("names" in $$props2) $$invalidate(0, names = $$props2.names);
    if ("submission" in $$props2) $$invalidate(1, submission = $$props2.submission);
    if ("cancel" in $$props2) $$invalidate(2, cancel = $$props2.cancel);
  };
  return [names, submission, cancel, btnCancel, word, button1_binding];
}
var RemoveConfirmForm = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance6, create_fragment6, safe_not_equal, { names: 0, submission: 1, cancel: 2 });
  }
};
var RemoveConfirmForm_default = RemoveConfirmForm;

// src/RemoveConfirmModal.ts
var RemoveConfirmModal = class extends import_obsidian5.Modal {
  constructor(app, names, submission) {
    super(app);
    this.names = names;
    this.submission = submission;
  }
  async onSubmit() {
    await this.submission(true);
    this.close();
  }
  onCancel() {
    this.submission(false);
    this.close();
  }
  onOpen() {
    if (!this.names || this.names.length === 0) {
      new import_obsidian5.Notice("Please check at least one property to remove.");
      this.close();
    }
    this.titleEl.createEl("h2", { text: "Remove Properties" });
    this.component = new RemoveConfirmForm_default({
      target: this.contentEl,
      props: {
        names: this.names,
        submission: this.onSubmit.bind(this),
        cancel: this.onCancel.bind(this)
      }
    });
  }
};

// src/RemoveModal.ts
var RemoveModal = class extends import_obsidian6.Modal {
  constructor(app, names, submission) {
    if (!names || names.length === 0) {
      new import_obsidian6.Notice("No properties to remove");
      return;
    }
    super(app);
    this.names = names;
    this.submission = submission;
  }
  async onConfirm(bool) {
    if (bool) {
      await this.submission(this.props);
      this.close();
    }
  }
  onSubmit(props) {
    this.props = props;
    new RemoveConfirmModal(
      this.app,
      this.props,
      this.onConfirm.bind(this)
    ).open();
  }
  onOpen() {
    this.titleEl.createEl("h2", { text: "Remove Properties" });
    this.component = new RemovePropForm_default({
      target: this.contentEl,
      props: {
        names: this.names,
        submission: this.onSubmit.bind(this)
      }
    });
  }
};

// src/RemoveValueModal.ts
var import_obsidian7 = require("obsidian");

// src/RemoveValueForm.svelte
function get_each_context7(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i];
  return child_ctx;
}
function create_each_block_1(ctx) {
  let option;
  let t_value = (
    /*prop*/
    ctx[16] + ""
  );
  let t;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = option_value_value = /*prop*/
      ctx[16];
      set_input_value(option, option.__value);
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*properties*/
      1 && t_value !== (t_value = /*prop*/
      ctx2[16] + "")) set_data(t, t_value);
      if (dirty & /*properties*/
      1 && option_value_value !== (option_value_value = /*prop*/
      ctx2[16])) {
        option.__value = option_value_value;
        set_input_value(option, option.__value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(option);
      }
    }
  };
}
function create_if_block(ctx) {
  let fieldset;
  let legend;
  let t1;
  let div;
  let each_value = ensure_array_like(
    /*values*/
    ctx[2]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block7(get_each_context7(ctx, each_value, i));
  }
  return {
    c() {
      fieldset = element("fieldset");
      legend = element("legend");
      legend.textContent = "Select Values to Remove";
      t1 = space();
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "checkbox-group");
      attr(fieldset, "class", "form-group");
    },
    m(target, anchor) {
      insert(target, fieldset, anchor);
      append(fieldset, legend);
      append(fieldset, t1);
      append(fieldset, div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*values, selectedValues*/
      12) {
        each_value = ensure_array_like(
          /*values*/
          ctx2[2]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context7(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block7(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(fieldset);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block7(ctx) {
  let label;
  let input;
  let input_value_value;
  let value_has_changed = false;
  let t0;
  let t1_value = (
    /*value*/
    ctx[13] + ""
  );
  let t1;
  let t2;
  let binding_group;
  let mounted;
  let dispose;
  binding_group = init_binding_group(
    /*$$binding_groups*/
    ctx[11][0]
  );
  return {
    c() {
      label = element("label");
      input = element("input");
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      attr(input, "type", "checkbox");
      input.__value = input_value_value = /*value*/
      ctx[13];
      set_input_value(input, input.__value);
      binding_group.p(input);
    },
    m(target, anchor) {
      insert(target, label, anchor);
      append(label, input);
      input.checked = ~/*selectedValues*/
      (ctx[3] || []).indexOf(input.__value);
      append(label, t0);
      append(label, t1);
      append(label, t2);
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*input_change_handler*/
          ctx[10]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*values*/
      4 && input_value_value !== (input_value_value = /*value*/
      ctx2[13])) {
        input.__value = input_value_value;
        set_input_value(input, input.__value);
        value_has_changed = true;
      }
      if (value_has_changed || dirty & /*selectedValues, values*/
      12) {
        input.checked = ~/*selectedValues*/
        (ctx2[3] || []).indexOf(input.__value);
      }
      if (dirty & /*values*/
      4 && t1_value !== (t1_value = /*value*/
      ctx2[13] + "")) set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(label);
      }
      binding_group.r();
      mounted = false;
      dispose();
    }
  };
}
function create_fragment7(ctx) {
  let form;
  let div1;
  let h2;
  let t1;
  let div0;
  let label;
  let t3;
  let select;
  let option;
  let t5;
  let t6;
  let div2;
  let button0;
  let t7;
  let button0_disabled_value;
  let t8;
  let button1;
  let mounted;
  let dispose;
  let each_value_1 = ensure_array_like(
    /*properties*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  let if_block = (
    /*selectedProperty*/
    ctx[1] && create_if_block(ctx)
  );
  return {
    c() {
      form = element("form");
      div1 = element("div");
      h2 = element("h2");
      h2.textContent = "Remove Value from Property";
      t1 = space();
      div0 = element("div");
      label = element("label");
      label.textContent = "Select Property";
      t3 = space();
      select = element("select");
      option = element("option");
      option.textContent = "Choose a property...";
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t5 = space();
      if (if_block) if_block.c();
      t6 = space();
      div2 = element("div");
      button0 = element("button");
      t7 = text("Remove Values");
      t8 = space();
      button1 = element("button");
      button1.textContent = "Cancel";
      attr(label, "for", "property-select");
      option.__value = "";
      set_input_value(option, option.__value);
      option.disabled = true;
      attr(select, "id", "property-select");
      select.required = true;
      if (
        /*selectedProperty*/
        ctx[1] === void 0
      ) add_render_callback(() => (
        /*select_change_handler*/
        ctx[9].call(select)
      ));
      attr(div0, "class", "form-group");
      attr(div1, "class", "modal-content");
      attr(button0, "type", "submit");
      attr(button0, "class", "mod-cta");
      button0.disabled = button0_disabled_value = /*selectedValues*/
      ctx[3].length === 0;
      attr(button1, "type", "button");
      attr(div2, "class", "modal-footer");
    },
    m(target, anchor) {
      insert(target, form, anchor);
      append(form, div1);
      append(div1, h2);
      append(div1, t1);
      append(div1, div0);
      append(div0, label);
      append(div0, t3);
      append(div0, select);
      append(select, option);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select, null);
        }
      }
      select_option(
        select,
        /*selectedProperty*/
        ctx[1],
        true
      );
      append(div1, t5);
      if (if_block) if_block.m(div1, null);
      append(form, t6);
      append(form, div2);
      append(div2, button0);
      append(button0, t7);
      append(div2, t8);
      append(div2, button1);
      if (!mounted) {
        dispose = [
          listen(
            select,
            "change",
            /*select_change_handler*/
            ctx[9]
          ),
          listen(
            select,
            "change",
            /*handlePropertyChange*/
            ctx[5]
          ),
          listen(
            button1,
            "click",
            /*click_handler*/
            ctx[12]
          ),
          listen(form, "submit", prevent_default(
            /*handleSubmit*/
            ctx[6]
          ))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*properties*/
      1) {
        each_value_1 = ensure_array_like(
          /*properties*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
      if (dirty & /*selectedProperty, properties*/
      3) {
        select_option(
          select,
          /*selectedProperty*/
          ctx2[1]
        );
      }
      if (
        /*selectedProperty*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          if_block.m(div1, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*selectedValues*/
      8 && button0_disabled_value !== (button0_disabled_value = /*selectedValues*/
      ctx2[3].length === 0)) {
        button0.disabled = button0_disabled_value;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(form);
      }
      destroy_each(each_blocks, detaching);
      if (if_block) if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance7($$self, $$props, $$invalidate) {
  let { properties } = $$props;
  let { getValues } = $$props;
  let { onSubmit } = $$props;
  let selectedProperty = "";
  let values = [];
  let selectedValues = [];
  const dispatch = createEventDispatcher();
  function handlePropertyChange() {
    return __awaiter(this, void 0, void 0, function* () {
      if (selectedProperty) {
        $$invalidate(2, values = yield getValues(selectedProperty));
        $$invalidate(3, selectedValues = []);
      }
    });
  }
  function handleSubmit() {
    if (selectedProperty && selectedValues.length > 0) {
      onSubmit(selectedProperty, selectedValues);
      dispatch("submit");
    }
  }
  const $$binding_groups = [[]];
  function select_change_handler() {
    selectedProperty = select_value(this);
    $$invalidate(1, selectedProperty);
    $$invalidate(0, properties);
  }
  function input_change_handler() {
    selectedValues = get_binding_group_value($$binding_groups[0], this.__value, this.checked);
    $$invalidate(3, selectedValues);
  }
  const click_handler = () => dispatch("cancel");
  $$self.$$set = ($$props2) => {
    if ("properties" in $$props2) $$invalidate(0, properties = $$props2.properties);
    if ("getValues" in $$props2) $$invalidate(7, getValues = $$props2.getValues);
    if ("onSubmit" in $$props2) $$invalidate(8, onSubmit = $$props2.onSubmit);
  };
  return [
    properties,
    selectedProperty,
    values,
    selectedValues,
    dispatch,
    handlePropertyChange,
    handleSubmit,
    getValues,
    onSubmit,
    select_change_handler,
    input_change_handler,
    $$binding_groups,
    click_handler
  ];
}
var RemoveValueForm = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance7, create_fragment7, safe_not_equal, { properties: 0, getValues: 7, onSubmit: 8 });
  }
};
var RemoveValueForm_default = RemoveValueForm;

// src/RemoveValueModal.ts
var RemoveValueModal = class extends import_obsidian7.Modal {
  constructor(app, properties, getValues, onSubmit) {
    super(app);
    this.properties = properties;
    this.getValues = getValues;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    this.component = new RemoveValueForm_default({
      target: contentEl,
      props: {
        properties: this.properties,
        getValues: this.getValues,
        onSubmit: (selectedProperty, valuesToRemove) => {
          this.onSubmit(selectedProperty, valuesToRemove);
          this.close();
        }
      }
    });
    this.component.$on("cancel", () => {
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/frontmatter.ts
async function addProperties(fileProcessor, file, props, overwrite, propCache) {
  await fileProcessor(file, (frontmatter) => {
    for (const [key, value] of props) {
      if (key === "tags") {
        const existingTags = frontmatter[key] || [];
        const newTags = Array.isArray(value.data) ? value.data : [value.data];
        frontmatter[key] = [.../* @__PURE__ */ new Set([...existingTags, ...newTags])];
        continue;
      }
      if (!frontmatter[key] || overwrite) {
        frontmatter[key] = value.data;
        continue;
      }
      let type1 = value.type;
      let type2 = propCache[key.toLowerCase()].type;
      if (canBeAppended(type1, type2)) {
        if (frontmatter[key] === value.data) continue;
        if (!value.data) continue;
        let arr = mergeIntoArrays(frontmatter[key], value.data);
        frontmatter[key] = arr;
        continue;
      } else {
        frontmatter[key] = value.data;
        continue;
      }
    }
  });
}
async function addPropToSet(fileProcessor, set, file) {
  await fileProcessor(file, (frontmatter) => {
    for (const key in frontmatter) {
      console.log({ key });
      set.add(key);
    }
  });
  return set;
}
async function removeProperties(fileProcessor, file, props) {
  await fileProcessor(file, (frontmatter) => {
    for (const prop of props) {
      frontmatter[prop] = void 0;
    }
  });
}
function canBeAppended(str1, str2) {
  let arr = ["number", "date", "datetime", "checkbox"];
  if (arr.includes(str1) || arr.includes(str2)) return false;
  return true;
}
function mergeIntoArrays(...args) {
  const arrays = args.map((arg) => Array.isArray(arg) ? arg : [arg]);
  const flattened = arrays.flat();
  const unique = [...new Set(flattened)];
  return unique;
}
async function addValueToProperty(fileProcessor, file, property, value) {
  await fileProcessor(file, (frontmatter) => {
    if (frontmatter[property]) {
      const existingValues = Array.isArray(frontmatter[property]) ? frontmatter[property] : [frontmatter[property]];
      const newValues = [.../* @__PURE__ */ new Set([...existingValues, value])];
      frontmatter[property] = newValues;
    }
  });
}
async function removeValuesFromProperty(fileProcessor, file, property, valuesToRemove) {
  await fileProcessor(file, (frontmatter) => {
    if (frontmatter[property] && Array.isArray(frontmatter[property])) {
      frontmatter[property] = frontmatter[property].filter(
        (value) => !valuesToRemove.includes(value)
      );
    }
  });
}
async function getUniqueValues(app, files, property) {
  const values = /* @__PURE__ */ new Set();
  for (const file of files) {
    await app.fileManager.processFrontMatter(file, (frontmatter) => {
      if (frontmatter[property] && Array.isArray(frontmatter[property])) {
        for (const value of frontmatter[property]) {
          values.add(value);
        }
      }
    });
  }
  return [...values];
}

// src/main.ts
var defaultSettings = {
  overwrite: false,
  recursive: true,
  delimiter: ",",
  defaultPropPath: ""
};
var MultiPropPlugin = class extends import_obsidian8.Plugin {
  async loadSettings() {
    this.settings = Object.assign({}, defaultSettings, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async changeOverwrite(bool) {
    this.settings.overwrite = bool;
    await this.saveSettings();
  }
  _getFilesFromTabGroup(leaf) {
    if (!leaf) {
      return [];
    }
    const files = [];
    const fileSet = /* @__PURE__ */ new Set();
    const activeParent = leaf.parent;
    if (activeParent instanceof import_obsidian8.WorkspaceTabs) {
      this.app.workspace.iterateAllLeaves((l) => {
        if (l.parent === activeParent && l.view instanceof import_obsidian8.FileView) {
          const file = l.view.file;
          if (file && !fileSet.has(file.path)) {
            files.push(file);
            fileSet.add(file.path);
          }
        }
      });
    } else {
      const activeWindowRoot = leaf.getRoot();
      this.app.workspace.iterateAllLeaves((l) => {
        if (l.getRoot() === activeWindowRoot && l.view instanceof import_obsidian8.FileView) {
          const file = l.view.file;
          if (file && !fileSet.has(file.path)) {
            files.push(file);
            fileSet.add(file.path);
          }
        }
      });
    }
    return files;
  }
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new SettingTab(this.app, this));
    this.addCommand({
      id: "add-props-to-current-note",
      name: "Add props to current note",
      callback: async () => {
        const file = this.app.workspace.getActiveFile();
        if (!file) {
          new import_obsidian8.Notice("No active file to add properties to.", 4e3);
          return;
        }
        await this.createPropModal([file]);
      }
    });
    this.addCommand({
      id: "remove-props-from-current-note",
      name: "Remove props from current note",
      callback: async () => {
        const file = this.app.workspace.getActiveFile();
        if (!file) {
          new import_obsidian8.Notice("No active file to remove properties from.", 4e3);
          return;
        }
        await this.createRemoveModal([file]);
      }
    });
    this.addCommand({
      id: "add-props-to-tab-group",
      name: "Add props to tabs in active tab group",
      callback: async () => {
        const files = this._getFilesFromTabGroup(this.app.workspace.activeLeaf);
        if (!files || !files.length) {
          new import_obsidian8.Notice("No open tabs in the active tab group to add properties to.", 4e3);
          return;
        }
        await this.createPropModal(files);
      }
    });
    this.addCommand({
      id: "remove-props-from-tab-group",
      name: "Remove props from tabs in active tab group",
      callback: async () => {
        const files = this._getFilesFromTabGroup(this.app.workspace.activeLeaf);
        if (!files || !files.length) {
          new import_obsidian8.Notice("No open tabs in the active tab group to remove properties from.", 4e3);
          return;
        }
        await this.createRemoveModal(files);
      }
    });
    this.addCommand({
      id: "add-value-to-property",
      name: "Add value to a property on the current note",
      callback: async () => {
        const file = this.app.workspace.getActiveFile();
        if (!file) {
          new import_obsidian8.Notice("No active file to add a value to.", 4e3);
          return;
        }
        await this.createAddValueModal([file]);
      }
    });
    this.addCommand({
      id: "remove-value-from-property",
      name: "Remove a value from a property on the current note",
      callback: async () => {
        const file = this.app.workspace.getActiveFile();
        if (!file) {
          new import_obsidian8.Notice("No active file to remove a value from.", 4e3);
          return;
        }
        await this.createRemoveValueModal([file]);
      }
    });
    this.addCommand({
      id: "remove-value-from-property-in-tab-group",
      name: "Remove a value from a property on all notes in the active tab group",
      callback: async () => {
        const files = this._getFilesFromTabGroup(this.app.workspace.activeLeaf);
        if (!files || !files.length) {
          new import_obsidian8.Notice("No open tabs in the active tab group to remove a value from.", 4e3);
          return;
        }
        await this.createRemoveValueModal(files);
      }
    });
  }
  async getPropsFromFolder(folder, names) {
    for (let obj of folder.children) {
      if (obj instanceof import_obsidian8.TFile && obj.extension === "md") {
        names = await addPropToSet(this.app.fileManager.processFrontMatter.bind(this.app.fileManager), names, obj);
      }
      if (obj instanceof import_obsidian8.TFolder) {
        if (this.settings.recursive) {
          await this.getPropsFromFolder(obj, names);
        }
      }
    }
    return [...names].sort();
  }
  async getPropsFromFiles(files, names) {
    for (let file of files) {
      if (file instanceof import_obsidian8.TFile && file.extension === "md") {
        names = await addPropToSet(this.app.fileManager.processFrontMatter.bind(this.app.fileManager), names, file);
      }
    }
    return [...names];
  }
  async searchFolders(folder, callback) {
    for (let obj of folder.children) {
      if (obj instanceof import_obsidian8.TFolder) {
        if (this.settings.recursive) {
          await this.searchFolders(obj, callback);
        }
      }
      if (obj instanceof import_obsidian8.TFile && obj.extension === "md") {
        await callback(obj);
      }
    }
  }
  async searchFiles(files, callback) {
    for (let file of files) {
      if (file instanceof import_obsidian8.TFile && file.extension === "md") {
        await callback(file);
      }
    }
  }
  getFilesFromSearch(leaf) {
    let files = [];
    leaf.dom.vChildren.children.forEach((e) => {
      files.push(e.file);
    });
    return files;
  }
  async createPropModal(iterable) {
    let iterateFunc;
    let files = [];
    if (iterable instanceof import_obsidian8.TFolder) {
      iterateFunc = async (props) => await this.searchFolders(iterable, this.addPropsCallback(props));
    } else {
      files = iterable;
      iterateFunc = async (props) => await this.searchFiles(files, this.addPropsCallback(props));
    }
    let defaultProps;
    if (!this.settings.defaultPropPath) {
      defaultProps = [{ name: "", value: "", type: "text" }];
    } else {
      try {
        const file = this.app.vault.getAbstractFileByPath(
          `${this.settings.defaultPropPath}.md`
        );
        let tmp = this.readYamlProperties(file);
        if (tmp === void 0) throw Error("Undefined path.");
        defaultProps = tmp;
      } catch (e) {
        new import_obsidian8.Notice(
          `${e}.  Check if you entered a valid path in the Default Props File setting.`,
          1e4
        );
        defaultProps = [];
      }
    }
    new PropModal(
      this.app,
      iterateFunc,
      this.settings.overwrite,
      this.settings.delimiter,
      defaultProps,
      this.changeOverwrite.bind(this)
    ).open();
  }
  async createRemoveModal(iterable) {
    let names;
    let iterateFunc;
    if (iterable instanceof import_obsidian8.TFolder) {
      names = await this.getPropsFromFolder(iterable, /* @__PURE__ */ new Set());
      iterateFunc = async (props) => await this.searchFolders(iterable, this.removePropsCallback(props));
    } else {
      names = await this.getPropsFromFiles(iterable, /* @__PURE__ */ new Set());
      iterateFunc = async (props) => await this.searchFiles(iterable, this.removePropsCallback(props));
    }
    if (names.length === 0) {
      new import_obsidian8.Notice("No properties to remove", 4e3);
      return;
    }
    const sortedNames = [...names].sort(
      (a, b) => a.toLowerCase() > b.toLowerCase() ? 1 : -1
    );
    new RemoveModal(this.app, sortedNames, iterateFunc).open();
  }
  async createAddValueModal(files) {
    const listProps = await this.getListProperties(files);
    if (listProps.length === 0) {
      new import_obsidian8.Notice("No list-type properties found in the selected files.", 4e3);
      return;
    }
    new AddValueModal(this.app, listProps, (prop, value) => {
      files.forEach(async (file) => {
        await addValueToProperty(
          this.app.fileManager.processFrontMatter.bind(this.app.fileManager),
          file,
          prop,
          value
        );
      });
    }).open();
  }
  async createRemoveValueModal(files) {
    const listProps = await this.getListProperties(files);
    if (listProps.length === 0) {
      new import_obsidian8.Notice("No list-type properties found in the selected files.", 4e3);
      return;
    }
    const getValues = async (prop) => {
      return await getUniqueValues(this.app, files, prop);
    };
    new RemoveValueModal(
      this.app,
      listProps,
      getValues,
      (prop, values) => {
        files.forEach(async (file) => {
          await removeValuesFromProperty(
            this.app.fileManager.processFrontMatter.bind(this.app.fileManager),
            file,
            prop,
            values
          );
        });
      }
    ).open();
  }
  async getListProperties(files) {
    const listProps = /* @__PURE__ */ new Set();
    for (const file of files) {
      const metadata = this.app.metadataCache.getFileCache(file);
      const frontmatter = metadata == null ? void 0 : metadata.frontmatter;
      if (frontmatter) {
        for (const [key, value] of Object.entries(frontmatter)) {
          if (Array.isArray(value)) {
            listProps.add(key);
          }
        }
      }
    }
    return [...listProps].sort();
  }
  readYamlProperties(file) {
    const metadata = this.app.metadataCache.getFileCache(file);
    const frontmatter = metadata == null ? void 0 : metadata.frontmatter;
    if (!frontmatter) {
      new import_obsidian8.Notice("Not a valid Props template.", 4e3);
      return;
    }
    const allPropsWithType = this.app.metadataCache.getAllPropertyInfos();
    let result = [];
    for (let [key, value] of Object.entries(frontmatter)) {
      const keyLower = key.toLowerCase();
      const obj = {
        name: key,
        value,
        type: allPropsWithType[keyLower].type
      };
      result.push(obj);
    }
    return result;
  }
  addPropsCallback(props) {
    return async (file) => {
      await addProperties(this.app.fileManager.processFrontMatter.bind(this.app.fileManager), file, props, this.settings.overwrite, this.app.metadataCache.getAllPropertyInfos());
    };
  }
  removePropsCallback(props) {
    return async (file) => {
      await removeProperties(this.app.fileManager.processFrontMatter.bind(this.app.fileManager), file, props);
    };
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsic3JjL21haW4udHMiLCAic3JjL0FkZFByb3BNb2RhbC50cyIsICJub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL2ludGVybmFsL3V0aWxzLmpzIiwgIm5vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvaW50ZXJuYWwvZ2xvYmFscy5qcyIsICJub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL2ludGVybmFsL1Jlc2l6ZU9ic2VydmVyU2luZ2xldG9uLmpzIiwgIm5vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvaW50ZXJuYWwvZG9tLmpzIiwgIm5vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvaW50ZXJuYWwvbGlmZWN5Y2xlLmpzIiwgIm5vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvaW50ZXJuYWwvc2NoZWR1bGVyLmpzIiwgIm5vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvaW50ZXJuYWwvdHJhbnNpdGlvbnMuanMiLCAibm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvcnVudGltZS9pbnRlcm5hbC9lYWNoLmpzIiwgIm5vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3NoYXJlZC9ib29sZWFuX2F0dHJpYnV0ZXMuanMiLCAibm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvcnVudGltZS9pbnRlcm5hbC9Db21wb25lbnQuanMiLCAibm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvc2hhcmVkL3ZlcnNpb24uanMiLCAibm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvcnVudGltZS9pbnRlcm5hbC9kaXNjbG9zZS12ZXJzaW9uL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanMiLCAic3JjL0FkZFByb3BJbnB1dC5zdmVsdGUiLCAic3JjL2hlbHBlcnMudHMiLCAic3JjL0FkZFByb3BGb3JtLnN2ZWx0ZSIsICJzcmMvQWRkQ29uZmlybU1vZGFsLnRzIiwgInNyYy9BZGRDb25maXJtRm9ybS5zdmVsdGUiLCAic3JjL0FkZFZhbHVlTW9kYWwudHMiLCAic3JjL0FkZFZhbHVlRm9ybS5zdmVsdGUiLCAic3JjL1NldHRpbmdUYWIudHMiLCAic3JjL1JlbW92ZU1vZGFsLnRzIiwgInNyYy9SZW1vdmVQcm9wRm9ybS5zdmVsdGUiLCAic3JjL1JlbW92ZUNvbmZpcm1Nb2RhbC50cyIsICJzcmMvUmVtb3ZlQ29uZmlybUZvcm0uc3ZlbHRlIiwgInNyYy9SZW1vdmVWYWx1ZU1vZGFsLnRzIiwgInNyYy9SZW1vdmVWYWx1ZUZvcm0uc3ZlbHRlIiwgInNyYy9mcm9udG1hdHRlci50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgTWVudSwgTm90aWNlLCBQbHVnaW4sIFRBYnN0cmFjdEZpbGUsIFRGaWxlLCBURm9sZGVyLCBGaWxlVmlldywgV29ya3NwYWNlTGVhZiwgV29ya3NwYWNlVGFicyB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHsgUHJvcE1vZGFsIH0gZnJvbSBcIi4vQWRkUHJvcE1vZGFsXCI7XG5pbXBvcnQgeyBBZGRWYWx1ZU1vZGFsIH0gZnJvbSBcIi4vQWRkVmFsdWVNb2RhbFwiO1xuaW1wb3J0IHsgTXVsdGlQcm9wU2V0dGluZ3MsIFNldHRpbmdUYWIgfSBmcm9tIFwiLi9TZXR0aW5nVGFiXCI7XG5pbXBvcnQgeyBSZW1vdmVNb2RhbCB9IGZyb20gXCIuL1JlbW92ZU1vZGFsXCI7XG5pbXBvcnQgeyBSZW1vdmVWYWx1ZU1vZGFsIH0gZnJvbSBcIi4vUmVtb3ZlVmFsdWVNb2RhbFwiO1xuaW1wb3J0IHsgYWRkUHJvcGVydGllcywgYWRkUHJvcFRvU2V0LCByZW1vdmVQcm9wZXJ0aWVzLCBjYW5CZUFwcGVuZGVkLCBhZGRWYWx1ZVRvUHJvcGVydHksIHJlbW92ZVZhbHVlc0Zyb21Qcm9wZXJ0eSwgZ2V0VW5pcXVlVmFsdWVzIH0gZnJvbSBcIi4vZnJvbnRtYXR0ZXJcIjtcbmltcG9ydCB7IFByb3BlcnR5VHlwZXMgfSBmcm9tIFwiLi90eXBlcy9jdXN0b21cIjtcblxuZGVjbGFyZSBjb25zdCBwcm9jZXNzOiBhbnk7XG5cbmNvbnN0IGRlZmF1bHRTZXR0aW5nczogTXVsdGlQcm9wU2V0dGluZ3MgPSB7XG4gIG92ZXJ3cml0ZTogZmFsc2UsXG4gIHJlY3Vyc2l2ZTogdHJ1ZSxcbiAgZGVsaW1pdGVyOiBcIixcIixcbiAgZGVmYXVsdFByb3BQYXRoOiBcIlwiLFxufTtcblxuZXhwb3J0IGludGVyZmFjZSBOZXdQcm9wRGF0YSB7XG4gIHR5cGU6IHN0cmluZztcbiAgZGF0YTogc3RyaW5nIHwgc3RyaW5nW10gfCBudWxsO1xuICBvdmVyd3JpdGU6IGJvb2xlYW47XG4gIGRlbGltaXRlcjogc3RyaW5nO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNdWx0aVByb3BQbHVnaW4gZXh0ZW5kcyBQbHVnaW4ge1xuICBzZXR0aW5nczogTXVsdGlQcm9wU2V0dGluZ3M7XG4gIGFzeW5jIGxvYWRTZXR0aW5ncygpIHtcbiAgICB0aGlzLnNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFNldHRpbmdzLCBhd2FpdCB0aGlzLmxvYWREYXRhKCkpO1xuICB9XG5cbiAgYXN5bmMgc2F2ZVNldHRpbmdzKCkge1xuICAgIGF3YWl0IHRoaXMuc2F2ZURhdGEodGhpcy5zZXR0aW5ncyk7XG4gIH1cblxuICBhc3luYyBjaGFuZ2VPdmVyd3JpdGUoYm9vbDogYm9vbGVhbikge1xuICAgIHRoaXMuc2V0dGluZ3Mub3ZlcndyaXRlID0gYm9vbDtcbiAgICBhd2FpdCB0aGlzLnNhdmVTZXR0aW5ncygpO1xuICB9XG5cbiAgcHJpdmF0ZSBfZ2V0RmlsZXNGcm9tVGFiR3JvdXAobGVhZjogV29ya3NwYWNlTGVhZiB8IG51bGwpOiBURmlsZVtdIHtcbiAgICBpZiAoIWxlYWYpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBjb25zdCBmaWxlczogVEZpbGVbXSA9IFtdO1xuICAgIGNvbnN0IGZpbGVTZXQgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICBjb25zdCBhY3RpdmVQYXJlbnQgPSBsZWFmLnBhcmVudDtcblxuICAgIGlmIChhY3RpdmVQYXJlbnQgaW5zdGFuY2VvZiBXb3Jrc3BhY2VUYWJzKSB7XG4gICAgICB0aGlzLmFwcC53b3Jrc3BhY2UuaXRlcmF0ZUFsbExlYXZlcygobCkgPT4ge1xuICAgICAgICBpZiAobC5wYXJlbnQgPT09IGFjdGl2ZVBhcmVudCAmJiBsLnZpZXcgaW5zdGFuY2VvZiBGaWxlVmlldykge1xuICAgICAgICAgIGNvbnN0IGZpbGUgPSBsLnZpZXcuZmlsZTtcbiAgICAgICAgICBpZiAoZmlsZSAmJiAhZmlsZVNldC5oYXMoZmlsZS5wYXRoKSkge1xuICAgICAgICAgICAgZmlsZXMucHVzaChmaWxlKTtcbiAgICAgICAgICAgIGZpbGVTZXQuYWRkKGZpbGUucGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmFsbGJhY2sgZm9yIHBvcC1vdXQgd2luZG93cyBvciBvdGhlciBjYXNlc1xuICAgICAgY29uc3QgYWN0aXZlV2luZG93Um9vdCA9IGxlYWYuZ2V0Um9vdCgpO1xuICAgICAgdGhpcy5hcHAud29ya3NwYWNlLml0ZXJhdGVBbGxMZWF2ZXMoKGwpID0+IHtcbiAgICAgICAgaWYgKGwuZ2V0Um9vdCgpID09PSBhY3RpdmVXaW5kb3dSb290ICYmIGwudmlldyBpbnN0YW5jZW9mIEZpbGVWaWV3KSB7XG4gICAgICAgICAgY29uc3QgZmlsZSA9IGwudmlldy5maWxlO1xuICAgICAgICAgIGlmIChmaWxlICYmICFmaWxlU2V0LmhhcyhmaWxlLnBhdGgpKSB7XG4gICAgICAgICAgICBmaWxlcy5wdXNoKGZpbGUpO1xuICAgICAgICAgICAgZmlsZVNldC5hZGQoZmlsZS5wYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBmaWxlcztcbiAgfVxuXG4gIGFzeW5jIG9ubG9hZCgpIHtcbiAgICBhd2FpdCB0aGlzLmxvYWRTZXR0aW5ncygpO1xuICAgIHRoaXMuYWRkU2V0dGluZ1RhYihuZXcgU2V0dGluZ1RhYih0aGlzLmFwcCwgdGhpcykpO1xuXG4gICAgLy8gQWxsIGNvbW1hbmRzIGFyZSByZXN0b3JlZCBoZXJlLlxuICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICBpZDogXCJhZGQtcHJvcHMtdG8tY3VycmVudC1ub3RlXCIsXG4gICAgICBuYW1lOiBcIkFkZCBwcm9wcyB0byBjdXJyZW50IG5vdGVcIixcbiAgICAgIGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpO1xuICAgICAgICBpZiAoIWZpbGUpIHtcbiAgICAgICAgICBuZXcgTm90aWNlKFwiTm8gYWN0aXZlIGZpbGUgdG8gYWRkIHByb3BlcnRpZXMgdG8uXCIsIDQwMDApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLmNyZWF0ZVByb3BNb2RhbChbZmlsZV0pO1xuICAgICAgfSxcbiAgICB9KTtcblxuICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICBpZDogXCJyZW1vdmUtcHJvcHMtZnJvbS1jdXJyZW50LW5vdGVcIixcbiAgICAgIG5hbWU6IFwiUmVtb3ZlIHByb3BzIGZyb20gY3VycmVudCBub3RlXCIsXG4gICAgICBjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBmaWxlID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZUZpbGUoKTtcbiAgICAgICAgaWYgKCFmaWxlKSB7XG4gICAgICAgICAgbmV3IE5vdGljZShcIk5vIGFjdGl2ZSBmaWxlIHRvIHJlbW92ZSBwcm9wZXJ0aWVzIGZyb20uXCIsIDQwMDApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLmNyZWF0ZVJlbW92ZU1vZGFsKFtmaWxlXSk7XG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgIGlkOiBcImFkZC1wcm9wcy10by10YWItZ3JvdXBcIixcbiAgICAgIG5hbWU6IFwiQWRkIHByb3BzIHRvIHRhYnMgaW4gYWN0aXZlIHRhYiBncm91cFwiLFxuICAgICAgY2FsbGJhY2s6IGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgZmlsZXMgPSB0aGlzLl9nZXRGaWxlc0Zyb21UYWJHcm91cCh0aGlzLmFwcC53b3Jrc3BhY2UuYWN0aXZlTGVhZik7XG4gICAgICAgIGlmICghZmlsZXMgfHwgIWZpbGVzLmxlbmd0aCkge1xuICAgICAgICAgIG5ldyBOb3RpY2UoXCJObyBvcGVuIHRhYnMgaW4gdGhlIGFjdGl2ZSB0YWIgZ3JvdXAgdG8gYWRkIHByb3BlcnRpZXMgdG8uXCIsIDQwMDApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLmNyZWF0ZVByb3BNb2RhbChmaWxlcyk7XG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgIGlkOiBcInJlbW92ZS1wcm9wcy1mcm9tLXRhYi1ncm91cFwiLFxuICAgICAgbmFtZTogXCJSZW1vdmUgcHJvcHMgZnJvbSB0YWJzIGluIGFjdGl2ZSB0YWIgZ3JvdXBcIixcbiAgICAgIGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGZpbGVzID0gdGhpcy5fZ2V0RmlsZXNGcm9tVGFiR3JvdXAodGhpcy5hcHAud29ya3NwYWNlLmFjdGl2ZUxlYWYpO1xuICAgICAgICBpZiAoIWZpbGVzIHx8ICFmaWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICBuZXcgTm90aWNlKFwiTm8gb3BlbiB0YWJzIGluIHRoZSBhY3RpdmUgdGFiIGdyb3VwIHRvIHJlbW92ZSBwcm9wZXJ0aWVzIGZyb20uXCIsIDQwMDApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLmNyZWF0ZVJlbW92ZU1vZGFsKGZpbGVzKTtcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgaWQ6IFwiYWRkLXZhbHVlLXRvLXByb3BlcnR5XCIsXG4gICAgICBuYW1lOiBcIkFkZCB2YWx1ZSB0byBhIHByb3BlcnR5IG9uIHRoZSBjdXJyZW50IG5vdGVcIixcbiAgICAgIGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpO1xuICAgICAgICBpZiAoIWZpbGUpIHtcbiAgICAgICAgICBuZXcgTm90aWNlKFwiTm8gYWN0aXZlIGZpbGUgdG8gYWRkIGEgdmFsdWUgdG8uXCIsIDQwMDApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLmNyZWF0ZUFkZFZhbHVlTW9kYWwoW2ZpbGVdKTtcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgaWQ6IFwicmVtb3ZlLXZhbHVlLWZyb20tcHJvcGVydHlcIixcbiAgICAgIG5hbWU6IFwiUmVtb3ZlIGEgdmFsdWUgZnJvbSBhIHByb3BlcnR5IG9uIHRoZSBjdXJyZW50IG5vdGVcIixcbiAgICAgIGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpO1xuICAgICAgICBpZiAoIWZpbGUpIHtcbiAgICAgICAgICBuZXcgTm90aWNlKFwiTm8gYWN0aXZlIGZpbGUgdG8gcmVtb3ZlIGEgdmFsdWUgZnJvbS5cIiwgNDAwMCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuY3JlYXRlUmVtb3ZlVmFsdWVNb2RhbChbZmlsZV0pO1xuICAgICAgfSxcbiAgICB9KTtcblxuICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICBpZDogXCJyZW1vdmUtdmFsdWUtZnJvbS1wcm9wZXJ0eS1pbi10YWItZ3JvdXBcIixcbiAgICAgIG5hbWU6IFwiUmVtb3ZlIGEgdmFsdWUgZnJvbSBhIHByb3BlcnR5IG9uIGFsbCBub3RlcyBpbiB0aGUgYWN0aXZlIHRhYiBncm91cFwiLFxuICAgICAgY2FsbGJhY2s6IGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgZmlsZXMgPSB0aGlzLl9nZXRGaWxlc0Zyb21UYWJHcm91cCh0aGlzLmFwcC53b3Jrc3BhY2UuYWN0aXZlTGVhZik7XG4gICAgICAgIGlmICghZmlsZXMgfHwgIWZpbGVzLmxlbmd0aCkge1xuICAgICAgICAgIG5ldyBOb3RpY2UoXCJObyBvcGVuIHRhYnMgaW4gdGhlIGFjdGl2ZSB0YWIgZ3JvdXAgdG8gcmVtb3ZlIGEgdmFsdWUgZnJvbS5cIiwgNDAwMCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuY3JlYXRlUmVtb3ZlVmFsdWVNb2RhbChmaWxlcyk7XG4gICAgICB9LFxuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgZ2V0UHJvcHNGcm9tRm9sZGVyKGZvbGRlcjogVEZvbGRlciwgbmFtZXM6IFNldDxzdHJpbmc+KSB7XG4gICAgZm9yIChsZXQgb2JqIG9mIGZvbGRlci5jaGlsZHJlbikge1xuICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIFRGaWxlICYmIG9iai5leHRlbnNpb24gPT09IFwibWRcIikge1xuICAgICAgICBuYW1lcyA9IGF3YWl0IGFkZFByb3BUb1NldCh0aGlzLmFwcC5maWxlTWFuYWdlci5wcm9jZXNzRnJvbnRNYXR0ZXIuYmluZCh0aGlzLmFwcC5maWxlTWFuYWdlciksIG5hbWVzLCBvYmopO1xuICAgICAgfVxuICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIFRGb2xkZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MucmVjdXJzaXZlKSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5nZXRQcm9wc0Zyb21Gb2xkZXIob2JqLCBuYW1lcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFsuLi5uYW1lc10uc29ydCgpO1xuICB9XG5cbiAgYXN5bmMgZ2V0UHJvcHNGcm9tRmlsZXMoZmlsZXM6IFRBYnN0cmFjdEZpbGVbXSwgbmFtZXM6IFNldDxzdHJpbmc+KSB7XG4gICAgZm9yIChsZXQgZmlsZSBvZiBmaWxlcykge1xuICAgICAgaWYgKGZpbGUgaW5zdGFuY2VvZiBURmlsZSAmJiBmaWxlLmV4dGVuc2lvbiA9PT0gXCJtZFwiKSB7XG4gICAgICAgIG5hbWVzID0gYXdhaXQgYWRkUHJvcFRvU2V0KHRoaXMuYXBwLmZpbGVNYW5hZ2VyLnByb2Nlc3NGcm9udE1hdHRlci5iaW5kKHRoaXMuYXBwLmZpbGVNYW5hZ2VyKSwgbmFtZXMsIGZpbGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gWy4uLm5hbWVzXTtcbiAgfVxuXG4gIGFzeW5jIHNlYXJjaEZvbGRlcnMoZm9sZGVyOiBURm9sZGVyLCBjYWxsYmFjazogKGZpbGU6IFRGaWxlKSA9PiBhbnkpIHtcbiAgICBmb3IgKGxldCBvYmogb2YgZm9sZGVyLmNoaWxkcmVuKSB7XG4gICAgICBpZiAob2JqIGluc3RhbmNlb2YgVEZvbGRlcikge1xuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5yZWN1cnNpdmUpIHtcbiAgICAgICAgICBhd2FpdCB0aGlzLnNlYXJjaEZvbGRlcnMob2JqLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBURmlsZSAmJiBvYmouZXh0ZW5zaW9uID09PSBcIm1kXCIpIHtcbiAgICAgICAgYXdhaXQgY2FsbGJhY2sob2JqKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhc3luYyBzZWFyY2hGaWxlcyhmaWxlczogVEFic3RyYWN0RmlsZVtdLCBjYWxsYmFjazogKGZpbGU6IFRGaWxlKSA9PiBhbnkpIHtcbiAgICBmb3IgKGxldCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgICBpZiAoZmlsZSBpbnN0YW5jZW9mIFRGaWxlICYmIGZpbGUuZXh0ZW5zaW9uID09PSBcIm1kXCIpIHtcbiAgICAgICAgYXdhaXQgY2FsbGJhY2soZmlsZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZ2V0RmlsZXNGcm9tU2VhcmNoKGxlYWY6IGFueSkge1xuICAgIGxldCBmaWxlczogVEZpbGVbXSA9IFtdO1xuICAgIGxlYWYuZG9tLnZDaGlsZHJlbi5jaGlsZHJlbi5mb3JFYWNoKChlOiBhbnkpID0+IHtcbiAgICAgIGZpbGVzLnB1c2goZS5maWxlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZmlsZXM7XG4gIH1cblxuICBhc3luYyBjcmVhdGVQcm9wTW9kYWwoaXRlcmFibGU6IFRGaWxlW10gfCBURm9sZGVyKSB7XG4gICAgbGV0IGl0ZXJhdGVGdW5jO1xuICAgIGxldCBmaWxlczogVEZpbGVbXSA9IFtdO1xuICAgIGlmIChpdGVyYWJsZSBpbnN0YW5jZW9mIFRGb2xkZXIpIHtcbiAgICAgIGl0ZXJhdGVGdW5jID0gYXN5bmMgKHByb3BzOiBNYXA8c3RyaW5nLCBhbnk+KSA9PlxuICAgICAgICBhd2FpdCB0aGlzLnNlYXJjaEZvbGRlcnMoaXRlcmFibGUsIHRoaXMuYWRkUHJvcHNDYWxsYmFjayhwcm9wcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmaWxlcyA9IGl0ZXJhYmxlO1xuICAgICAgaXRlcmF0ZUZ1bmMgPSBhc3luYyAocHJvcHM6IE1hcDxzdHJpbmcsIGFueT4pID0+XG4gICAgICAgIGF3YWl0IHRoaXMuc2VhcmNoRmlsZXMoZmlsZXMsIHRoaXMuYWRkUHJvcHNDYWxsYmFjayhwcm9wcykpO1xuICAgIH1cblxuICAgIGxldCBkZWZhdWx0UHJvcHM6IHsgbmFtZTogc3RyaW5nOyB2YWx1ZTogYW55OyB0eXBlOiBQcm9wZXJ0eVR5cGVzIH1bXTtcbiAgICBpZiAoIXRoaXMuc2V0dGluZ3MuZGVmYXVsdFByb3BQYXRoKSB7XG4gICAgICBkZWZhdWx0UHJvcHMgPSBbeyBuYW1lOiBcIlwiLCB2YWx1ZTogXCJcIiwgdHlwZTogXCJ0ZXh0XCIgfV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoXG4gICAgICAgICAgYCR7dGhpcy5zZXR0aW5ncy5kZWZhdWx0UHJvcFBhdGh9Lm1kYFxuICAgICAgICApO1xuICAgICAgICBsZXQgdG1wID0gdGhpcy5yZWFkWWFtbFByb3BlcnRpZXMoZmlsZSBhcyBURmlsZSk7XG4gICAgICAgIGlmICh0bXAgPT09IHVuZGVmaW5lZCkgdGhyb3cgRXJyb3IoXCJVbmRlZmluZWQgcGF0aC5cIik7XG4gICAgICAgIGRlZmF1bHRQcm9wcyA9IHRtcDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbmV3IE5vdGljZShcbiAgICAgICAgICBgJHtlfS4gIENoZWNrIGlmIHlvdSBlbnRlcmVkIGEgdmFsaWQgcGF0aCBpbiB0aGUgRGVmYXVsdCBQcm9wcyBGaWxlIHNldHRpbmcuYCxcbiAgICAgICAgICAxMDAwMFxuICAgICAgICApO1xuICAgICAgICBkZWZhdWx0UHJvcHMgPSBbXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBuZXcgUHJvcE1vZGFsKFxuICAgICAgdGhpcy5hcHAsXG4gICAgICBpdGVyYXRlRnVuYyxcbiAgICAgIHRoaXMuc2V0dGluZ3Mub3ZlcndyaXRlLFxuICAgICAgdGhpcy5zZXR0aW5ncy5kZWxpbWl0ZXIsXG4gICAgICBkZWZhdWx0UHJvcHMsXG4gICAgICB0aGlzLmNoYW5nZU92ZXJ3cml0ZS5iaW5kKHRoaXMpXG4gICAgKS5vcGVuKCk7XG4gIH1cblxuICBhc3luYyBjcmVhdGVSZW1vdmVNb2RhbChpdGVyYWJsZTogVEFic3RyYWN0RmlsZVtdIHwgVEZvbGRlcikge1xuICAgIGxldCBuYW1lcztcbiAgICBsZXQgaXRlcmF0ZUZ1bmM7XG5cbiAgICBpZiAoaXRlcmFibGUgaW5zdGFuY2VvZiBURm9sZGVyKSB7XG4gICAgICBuYW1lcyA9IGF3YWl0IHRoaXMuZ2V0UHJvcHNGcm9tRm9sZGVyKGl0ZXJhYmxlLCBuZXcgU2V0KCkpO1xuICAgICAgaXRlcmF0ZUZ1bmMgPSBhc3luYyAocHJvcHM6IHN0cmluZ1tdKSA9PlxuICAgICAgICBhd2FpdCB0aGlzLnNlYXJjaEZvbGRlcnMoaXRlcmFibGUsIHRoaXMucmVtb3ZlUHJvcHNDYWxsYmFjayhwcm9wcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lcyA9IGF3YWl0IHRoaXMuZ2V0UHJvcHNGcm9tRmlsZXMoaXRlcmFibGUsIG5ldyBTZXQoKSk7XG4gICAgICBpdGVyYXRlRnVuYyA9IGFzeW5jIChwcm9wczogc3RyaW5nW10pID0+XG4gICAgICAgIGF3YWl0IHRoaXMuc2VhcmNoRmlsZXMoaXRlcmFibGUsIHRoaXMucmVtb3ZlUHJvcHNDYWxsYmFjayhwcm9wcykpO1xuICAgIH1cbiAgICBpZiAobmFtZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBuZXcgTm90aWNlKFwiTm8gcHJvcGVydGllcyB0byByZW1vdmVcIiwgNDAwMCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc29ydGVkTmFtZXMgPSBbLi4ubmFtZXNdLnNvcnQoKGEsIGIpID0+XG4gICAgICBhLnRvTG93ZXJDYXNlKCkgPiBiLnRvTG93ZXJDYXNlKCkgPyAxIDogLTFcbiAgICApO1xuXG4gICAgbmV3IFJlbW92ZU1vZGFsKHRoaXMuYXBwLCBzb3J0ZWROYW1lcywgaXRlcmF0ZUZ1bmMpLm9wZW4oKTtcbiAgfVxuXG4gIGFzeW5jIGNyZWF0ZUFkZFZhbHVlTW9kYWwoZmlsZXM6IFRGaWxlW10pIHtcbiAgICBjb25zdCBsaXN0UHJvcHMgPSBhd2FpdCB0aGlzLmdldExpc3RQcm9wZXJ0aWVzKGZpbGVzKTtcbiAgICBpZiAobGlzdFByb3BzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgbmV3IE5vdGljZShcIk5vIGxpc3QtdHlwZSBwcm9wZXJ0aWVzIGZvdW5kIGluIHRoZSBzZWxlY3RlZCBmaWxlcy5cIiwgNDAwMCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbmV3IEFkZFZhbHVlTW9kYWwodGhpcy5hcHAsIGxpc3RQcm9wcywgKHByb3AsIHZhbHVlKSA9PiB7XG4gICAgICBmaWxlcy5mb3JFYWNoKGFzeW5jIChmaWxlKSA9PiB7XG4gICAgICAgIGF3YWl0IGFkZFZhbHVlVG9Qcm9wZXJ0eShcbiAgICAgICAgICB0aGlzLmFwcC5maWxlTWFuYWdlci5wcm9jZXNzRnJvbnRNYXR0ZXIuYmluZCh0aGlzLmFwcC5maWxlTWFuYWdlciksXG4gICAgICAgICAgZmlsZSxcbiAgICAgICAgICBwcm9wLFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9KS5vcGVuKCk7XG4gIH1cblxuICBhc3luYyBjcmVhdGVSZW1vdmVWYWx1ZU1vZGFsKGZpbGVzOiBURmlsZVtdKSB7XG4gICAgY29uc3QgbGlzdFByb3BzID0gYXdhaXQgdGhpcy5nZXRMaXN0UHJvcGVydGllcyhmaWxlcyk7XG4gICAgaWYgKGxpc3RQcm9wcy5sZW5ndGggPT09IDApIHtcbiAgICAgIG5ldyBOb3RpY2UoXCJObyBsaXN0LXR5cGUgcHJvcGVydGllcyBmb3VuZCBpbiB0aGUgc2VsZWN0ZWQgZmlsZXMuXCIsIDQwMDApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGdldFZhbHVlcyA9IGFzeW5jIChwcm9wOiBzdHJpbmcpID0+IHtcbiAgICAgIHJldHVybiBhd2FpdCBnZXRVbmlxdWVWYWx1ZXModGhpcy5hcHAsIGZpbGVzLCBwcm9wKTtcbiAgICB9O1xuXG4gICAgbmV3IFJlbW92ZVZhbHVlTW9kYWwoXG4gICAgICB0aGlzLmFwcCxcbiAgICAgIGxpc3RQcm9wcyxcbiAgICAgIGdldFZhbHVlcyxcbiAgICAgIChwcm9wLCB2YWx1ZXMpID0+IHtcbiAgICAgICAgZmlsZXMuZm9yRWFjaChhc3luYyAoZmlsZSkgPT4ge1xuICAgICAgICAgIGF3YWl0IHJlbW92ZVZhbHVlc0Zyb21Qcm9wZXJ0eShcbiAgICAgICAgICAgIHRoaXMuYXBwLmZpbGVNYW5hZ2VyLnByb2Nlc3NGcm9udE1hdHRlci5iaW5kKHRoaXMuYXBwLmZpbGVNYW5hZ2VyKSxcbiAgICAgICAgICAgIGZpbGUsXG4gICAgICAgICAgICBwcm9wLFxuICAgICAgICAgICAgdmFsdWVzXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgKS5vcGVuKCk7XG4gIH1cblxuICBhc3luYyBnZXRMaXN0UHJvcGVydGllcyhmaWxlczogVEZpbGVbXSk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICBjb25zdCBsaXN0UHJvcHMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICBmb3IgKGNvbnN0IGZpbGUgb2YgZmlsZXMpIHtcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gdGhpcy5hcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZmlsZSk7XG4gICAgICBjb25zdCBmcm9udG1hdHRlciA9IG1ldGFkYXRhPy5mcm9udG1hdHRlcjtcbiAgICAgIGlmIChmcm9udG1hdHRlcikge1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhmcm9udG1hdHRlcikpIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGxpc3RQcm9wcy5hZGQoa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFsuLi5saXN0UHJvcHNdLnNvcnQoKTtcbiAgfVxuXG4gIHJlYWRZYW1sUHJvcGVydGllcyhmaWxlOiBURmlsZSkge1xuICAgIGNvbnN0IG1ldGFkYXRhID0gdGhpcy5hcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZmlsZSk7XG4gICAgY29uc3QgZnJvbnRtYXR0ZXIgPSBtZXRhZGF0YT8uZnJvbnRtYXR0ZXI7XG5cbiAgICBpZiAoIWZyb250bWF0dGVyKSB7XG4gICAgICBuZXcgTm90aWNlKFwiTm90IGEgdmFsaWQgUHJvcHMgdGVtcGxhdGUuXCIsIDQwMDApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGFsbFByb3BzV2l0aFR5cGUgPSB0aGlzLmFwcC5tZXRhZGF0YUNhY2hlLmdldEFsbFByb3BlcnR5SW5mb3MoKTtcblxuICAgIGxldCByZXN1bHQ6IHsgbmFtZTogc3RyaW5nOyB2YWx1ZTogYW55OyB0eXBlOiBQcm9wZXJ0eVR5cGVzIH1bXSA9IFtdO1xuXG4gICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGZyb250bWF0dGVyKSkge1xuICAgICAgY29uc3Qga2V5TG93ZXIgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgIGNvbnN0IG9iaiA9IHtcbiAgICAgICAgbmFtZToga2V5LFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIHR5cGU6IGFsbFByb3BzV2l0aFR5cGVba2V5TG93ZXJdLnR5cGUsXG4gICAgICB9O1xuXG4gICAgICByZXN1bHQucHVzaChvYmopO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgYWRkUHJvcHNDYWxsYmFjayhwcm9wczogYW55KSB7XG4gICAgcmV0dXJuIGFzeW5jIChmaWxlOiBURmlsZSkgPT4ge1xuICAgICAgYXdhaXQgYWRkUHJvcGVydGllcyh0aGlzLmFwcC5maWxlTWFuYWdlci5wcm9jZXNzRnJvbnRNYXR0ZXIuYmluZCh0aGlzLmFwcC5maWxlTWFuYWdlciksIGZpbGUsIHByb3BzLCB0aGlzLnNldHRpbmdzLm92ZXJ3cml0ZSwgdGhpcy5hcHAubWV0YWRhdGFDYWNoZS5nZXRBbGxQcm9wZXJ0eUluZm9zKCkpO1xuICAgIH07XG4gIH1cblxuICByZW1vdmVQcm9wc0NhbGxiYWNrKHByb3BzOiBhbnkpIHtcbiAgICByZXR1cm4gYXN5bmMgKGZpbGU6IFRGaWxlKSA9PiB7XG4gICAgICBhd2FpdCByZW1vdmVQcm9wZXJ0aWVzKHRoaXMuYXBwLmZpbGVNYW5hZ2VyLnByb2Nlc3NGcm9udE1hdHRlci5iaW5kKHRoaXMuYXBwLmZpbGVNYW5hZ2VyKSwgZmlsZSwgcHJvcHMpO1xuICAgIH07XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBNb2RhbCwgQXBwIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgUHJvcEZvcm0gZnJvbSBcIi4vQWRkUHJvcEZvcm0uc3ZlbHRlXCI7XG5pbXBvcnQgeyBOZXdQcm9wRGF0YSB9IGZyb20gXCIuL21haW5cIjtcbmltcG9ydCB7IEFkZENvbmZpcm1Nb2RhbCB9IGZyb20gXCIuL0FkZENvbmZpcm1Nb2RhbFwiO1xuaW1wb3J0IHsgUHJvcGVydHlUeXBlcyB9IGZyb20gXCIuL3R5cGVzL2N1c3RvbVwiO1xuXG4vKiogTG9hZHMgYSBtb2RhbCBhbmQgaGFuZGxlcyBmb3JtIHN1Ym1pc3Npb25zLiAqL1xuZXhwb3J0IGNsYXNzIFByb3BNb2RhbCBleHRlbmRzIE1vZGFsIHtcbiAgc3VibWlzc2lvbjogKGN1c3RvbVByb3BzOiBNYXA8c3RyaW5nLCBhbnk+KSA9PiBQcm9taXNlPHZvaWQ+O1xuICBwcm9wczogTWFwPHN0cmluZywgTmV3UHJvcERhdGE+O1xuICBvdmVyd3JpdGU6IGJvb2xlYW47XG4gIGRlbGltaXRlcjogc3RyaW5nO1xuICBkZWZhdWx0UHJvcHM6IHsgbmFtZTogc3RyaW5nOyB2YWx1ZTogYW55OyB0eXBlOiBQcm9wZXJ0eVR5cGVzOyB9W107XG4gIGNoYW5nZUJvb2w6IChib29sOiBib29sZWFuKSA9PiB2b2lkO1xuICBjb21wb25lbnQ6IFByb3BGb3JtO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIGFwcDogQXBwLFxuICAgIHN1Ym1pc3Npb246IChjdXN0b21Qcm9wczogTWFwPHN0cmluZywgYW55PikgPT4gUHJvbWlzZTx2b2lkPixcbiAgICBvdmVyd3JpdGU6IGJvb2xlYW4sXG4gICAgZGVsaW1pdGVyOiBzdHJpbmcsXG4gICAgZGVmYXVsdFByb3BzOiBhbnksXG4gICAgY2hhbmdlQm9vbDogKGJvb2w6IGJvb2xlYW4pID0+IHZvaWRcbiAgKSB7XG4gICAgc3VwZXIoYXBwKTtcbiAgICB0aGlzLnN1Ym1pc3Npb24gPSBzdWJtaXNzaW9uO1xuICAgIHRoaXMub3ZlcndyaXRlID0gb3ZlcndyaXRlO1xuICAgIHRoaXMuZGVsaW1pdGVyID0gZGVsaW1pdGVyO1xuICAgIHRoaXMuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuICAgIHRoaXMuY2hhbmdlQm9vbCA9IGNoYW5nZUJvb2w7XG4gIH1cblxuICAvL1J1biBmb3JtIHN1Ym1pc3Npb24gaWYgdXNlciBjbGlja3MgY29uZmlybS5cbiAgYXN5bmMgb25Db25maXJtKGJvb2w6IGJvb2xlYW4pIHtcbiAgICBpZiAoYm9vbCkge1xuICAgICAgYXdhaXQgdGhpcy5zdWJtaXNzaW9uKHRoaXMucHJvcHMpO1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZUJvb2woYm9vbDogYm9vbGVhbikge1xuICAgIHRoaXMub3ZlcndyaXRlID0gYm9vbDtcbiAgICB0aGlzLmNoYW5nZUJvb2woYm9vbCk7XG4gIH1cblxuICAvL1B1bGwgdXAgY29uZmlybWF0aW9uIGZvcm0gd2hlbiB1c2VyIHN1Ym1pdHMgYmFzZSBmb3JtLlxuICBvblN1Ym1pdChwcm9wczogTWFwPHN0cmluZywgTmV3UHJvcERhdGE+KSB7XG4gICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgIG5ldyBBZGRDb25maXJtTW9kYWwoXG4gICAgICB0aGlzLmFwcCxcbiAgICAgIHRoaXMucHJvcHMsXG4gICAgICB0aGlzLm92ZXJ3cml0ZSxcbiAgICAgIHRoaXMub25Db25maXJtLmJpbmQodGhpcylcbiAgICApLm9wZW4oKTtcbiAgfVxuXG4gIG9uT3BlbigpOiB2b2lkIHtcbiAgICB0aGlzLnRpdGxlRWwuY3JlYXRlRWwoXCJoMlwiLCB7IHRleHQ6IFwiQWRkIFByb3BlcnRpZXNcIiB9KTtcblxuICAgIHRoaXMuY29tcG9uZW50ID0gbmV3IFByb3BGb3JtKHtcbiAgICAgIHRhcmdldDogdGhpcy5jb250ZW50RWwsXG4gICAgICBwcm9wczoge1xuICAgICAgICBzdWJtaXNzaW9uOiB0aGlzLm9uU3VibWl0LmJpbmQodGhpcyksXG4gICAgICAgIG92ZXJ3cml0ZTogdGhpcy5vdmVyd3JpdGUsXG4gICAgICAgIGRlbGltaXRlcjogdGhpcy5kZWxpbWl0ZXIsXG4gICAgICAgIGRlZmF1bHRQcm9wczogdGhpcy5kZWZhdWx0UHJvcHMsXG4gICAgICAgIGNoYW5nZUJvb2w6IHRoaXMudXBkYXRlQm9vbC5iaW5kKHRoaXMpLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxufVxuIiwgIi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBub29wKCkge31cblxuZXhwb3J0IGNvbnN0IGlkZW50aXR5ID0gKHgpID0+IHg7XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEB0ZW1wbGF0ZSBTXG4gKiBAcGFyYW0ge1R9IHRhclxuICogQHBhcmFtIHtTfSBzcmNcbiAqIEByZXR1cm5zIHtUICYgU31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbih0YXIsIHNyYykge1xuXHQvLyBAdHMtaWdub3JlXG5cdGZvciAoY29uc3QgayBpbiBzcmMpIHRhcltrXSA9IHNyY1trXTtcblx0cmV0dXJuIC8qKiBAdHlwZSB7VCAmIFN9ICovICh0YXIpO1xufVxuXG4vLyBBZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3RoZW4vaXMtcHJvbWlzZS9ibG9iL21hc3Rlci9pbmRleC5qc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgTUlUIExpY2Vuc2UgaHR0cHM6Ly9naXRodWIuY29tL3RoZW4vaXMtcHJvbWlzZS9ibG9iL21hc3Rlci9MSUNFTlNFXG4vKipcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHJldHVybnMge3ZhbHVlIGlzIFByb21pc2VMaWtlPGFueT59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19wcm9taXNlKHZhbHVlKSB7XG5cdHJldHVybiAoXG5cdFx0ISF2YWx1ZSAmJlxuXHRcdCh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykgJiZcblx0XHR0eXBlb2YgKC8qKiBAdHlwZSB7YW55fSAqLyAodmFsdWUpLnRoZW4pID09PSAnZnVuY3Rpb24nXG5cdCk7XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRfbG9jYXRpb24oZWxlbWVudCwgZmlsZSwgbGluZSwgY29sdW1uLCBjaGFyKSB7XG5cdGVsZW1lbnQuX19zdmVsdGVfbWV0YSA9IHtcblx0XHRsb2M6IHsgZmlsZSwgbGluZSwgY29sdW1uLCBjaGFyIH1cblx0fTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJ1bihmbikge1xuXHRyZXR1cm4gZm4oKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJsYW5rX29iamVjdCgpIHtcblx0cmV0dXJuIE9iamVjdC5jcmVhdGUobnVsbCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtGdW5jdGlvbltdfSBmbnNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcnVuX2FsbChmbnMpIHtcblx0Zm5zLmZvckVhY2gocnVuKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gdGhpbmdcbiAqIEByZXR1cm5zIHt0aGluZyBpcyBGdW5jdGlvbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX2Z1bmN0aW9uKHRoaW5nKSB7XG5cdHJldHVybiB0eXBlb2YgdGhpbmcgPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKiBAcmV0dXJucyB7Ym9vbGVhbn0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYWZlX25vdF9lcXVhbChhLCBiKSB7XG5cdHJldHVybiBhICE9IGEgPyBiID09IGIgOiBhICE9PSBiIHx8IChhICYmIHR5cGVvZiBhID09PSAnb2JqZWN0JykgfHwgdHlwZW9mIGEgPT09ICdmdW5jdGlvbic7XG59XG5cbmxldCBzcmNfdXJsX2VxdWFsX2FuY2hvcjtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZWxlbWVudF9zcmNcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3JjX3VybF9lcXVhbChlbGVtZW50X3NyYywgdXJsKSB7XG5cdGlmIChlbGVtZW50X3NyYyA9PT0gdXJsKSByZXR1cm4gdHJ1ZTtcblx0aWYgKCFzcmNfdXJsX2VxdWFsX2FuY2hvcikge1xuXHRcdHNyY191cmxfZXF1YWxfYW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuXHR9XG5cdC8vIFRoaXMgaXMgYWN0dWFsbHkgZmFzdGVyIHRoYW4gZG9pbmcgVVJMKC4uKS5ocmVmXG5cdHNyY191cmxfZXF1YWxfYW5jaG9yLmhyZWYgPSB1cmw7XG5cdHJldHVybiBlbGVtZW50X3NyYyA9PT0gc3JjX3VybF9lcXVhbF9hbmNob3IuaHJlZjtcbn1cblxuLyoqIEBwYXJhbSB7c3RyaW5nfSBzcmNzZXQgKi9cbmZ1bmN0aW9uIHNwbGl0X3NyY3NldChzcmNzZXQpIHtcblx0cmV0dXJuIHNyY3NldC5zcGxpdCgnLCcpLm1hcCgoc3JjKSA9PiBzcmMudHJpbSgpLnNwbGl0KCcgJykuZmlsdGVyKEJvb2xlYW4pKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxTb3VyY2VFbGVtZW50IHwgSFRNTEltYWdlRWxlbWVudH0gZWxlbWVudF9zcmNzZXRcbiAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkIHwgbnVsbH0gc3Jjc2V0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNyY3NldF91cmxfZXF1YWwoZWxlbWVudF9zcmNzZXQsIHNyY3NldCkge1xuXHRjb25zdCBlbGVtZW50X3VybHMgPSBzcGxpdF9zcmNzZXQoZWxlbWVudF9zcmNzZXQuc3Jjc2V0KTtcblx0Y29uc3QgdXJscyA9IHNwbGl0X3NyY3NldChzcmNzZXQgfHwgJycpO1xuXG5cdHJldHVybiAoXG5cdFx0dXJscy5sZW5ndGggPT09IGVsZW1lbnRfdXJscy5sZW5ndGggJiZcblx0XHR1cmxzLmV2ZXJ5KFxuXHRcdFx0KFt1cmwsIHdpZHRoXSwgaSkgPT5cblx0XHRcdFx0d2lkdGggPT09IGVsZW1lbnRfdXJsc1tpXVsxXSAmJlxuXHRcdFx0XHQvLyBXZSBuZWVkIHRvIHRlc3QgYm90aCB3YXlzIGJlY2F1c2UgVml0ZSB3aWxsIGNyZWF0ZSBhbiBhIGZ1bGwgVVJMIHdpdGhcblx0XHRcdFx0Ly8gYG5ldyBVUkwoYXNzZXQsIGltcG9ydC5tZXRhLnVybCkuaHJlZmAgZm9yIHRoZSBjbGllbnQgd2hlbiBgYmFzZTogJy4vJ2AsIGFuZCB0aGVcblx0XHRcdFx0Ly8gcmVsYXRpdmUgVVJMcyBpbnNpZGUgc3Jjc2V0IGFyZSBub3QgYXV0b21hdGljYWxseSByZXNvbHZlZCB0byBhYnNvbHV0ZSBVUkxzIGJ5XG5cdFx0XHRcdC8vIGJyb3dzZXJzIChpbiBjb250cmFzdCB0byBpbWcuc3JjKS4gVGhpcyBtZWFucyBib3RoIFNTUiBhbmQgRE9NIGNvZGUgY291bGRcblx0XHRcdFx0Ly8gY29udGFpbiByZWxhdGl2ZSBvciBhYnNvbHV0ZSBVUkxzLlxuXHRcdFx0XHQoc3JjX3VybF9lcXVhbChlbGVtZW50X3VybHNbaV1bMF0sIHVybCkgfHwgc3JjX3VybF9lcXVhbCh1cmwsIGVsZW1lbnRfdXJsc1tpXVswXSkpXG5cdFx0KVxuXHQpO1xufVxuXG4vKiogQHJldHVybnMge2Jvb2xlYW59ICovXG5leHBvcnQgZnVuY3Rpb24gbm90X2VxdWFsKGEsIGIpIHtcblx0cmV0dXJuIGEgIT0gYSA/IGIgPT0gYiA6IGEgIT09IGI7XG59XG5cbi8qKiBAcmV0dXJucyB7Ym9vbGVhbn0gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19lbXB0eShvYmopIHtcblx0cmV0dXJuIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID09PSAwO1xufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVfc3RvcmUoc3RvcmUsIG5hbWUpIHtcblx0aWYgKHN0b3JlICE9IG51bGwgJiYgdHlwZW9mIHN0b3JlLnN1YnNjcmliZSAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdHRocm93IG5ldyBFcnJvcihgJyR7bmFtZX0nIGlzIG5vdCBhIHN0b3JlIHdpdGggYSAnc3Vic2NyaWJlJyBtZXRob2RgKTtcblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc3Vic2NyaWJlKHN0b3JlLCAuLi5jYWxsYmFja3MpIHtcblx0aWYgKHN0b3JlID09IG51bGwpIHtcblx0XHRmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIGNhbGxiYWNrcykge1xuXHRcdFx0Y2FsbGJhY2sodW5kZWZpbmVkKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5vb3A7XG5cdH1cblx0Y29uc3QgdW5zdWIgPSBzdG9yZS5zdWJzY3JpYmUoLi4uY2FsbGJhY2tzKTtcblx0cmV0dXJuIHVuc3ViLnVuc3Vic2NyaWJlID8gKCkgPT4gdW5zdWIudW5zdWJzY3JpYmUoKSA6IHVuc3ViO1xufVxuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCB2YWx1ZSBmcm9tIGEgc3RvcmUgYnkgc3Vic2NyaWJpbmcgYW5kIGltbWVkaWF0ZWx5IHVuc3Vic2NyaWJpbmcuXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLXN0b3JlI2dldFxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9zdG9yZS9wdWJsaWMuanMnKS5SZWFkYWJsZTxUPn0gc3RvcmVcbiAqIEByZXR1cm5zIHtUfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0X3N0b3JlX3ZhbHVlKHN0b3JlKSB7XG5cdGxldCB2YWx1ZTtcblx0c3Vic2NyaWJlKHN0b3JlLCAoXykgPT4gKHZhbHVlID0gXykpKCk7XG5cdHJldHVybiB2YWx1ZTtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBvbmVudF9zdWJzY3JpYmUoY29tcG9uZW50LCBzdG9yZSwgY2FsbGJhY2spIHtcblx0Y29tcG9uZW50LiQkLm9uX2Rlc3Ryb3kucHVzaChzdWJzY3JpYmUoc3RvcmUsIGNhbGxiYWNrKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVfc2xvdChkZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGZuKSB7XG5cdGlmIChkZWZpbml0aW9uKSB7XG5cdFx0Y29uc3Qgc2xvdF9jdHggPSBnZXRfc2xvdF9jb250ZXh0KGRlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZm4pO1xuXHRcdHJldHVybiBkZWZpbml0aW9uWzBdKHNsb3RfY3R4KTtcblx0fVxufVxuXG5mdW5jdGlvbiBnZXRfc2xvdF9jb250ZXh0KGRlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZm4pIHtcblx0cmV0dXJuIGRlZmluaXRpb25bMV0gJiYgZm4gPyBhc3NpZ24oJCRzY29wZS5jdHguc2xpY2UoKSwgZGVmaW5pdGlvblsxXShmbihjdHgpKSkgOiAkJHNjb3BlLmN0eDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldF9zbG90X2NoYW5nZXMoZGVmaW5pdGlvbiwgJCRzY29wZSwgZGlydHksIGZuKSB7XG5cdGlmIChkZWZpbml0aW9uWzJdICYmIGZuKSB7XG5cdFx0Y29uc3QgbGV0cyA9IGRlZmluaXRpb25bMl0oZm4oZGlydHkpKTtcblx0XHRpZiAoJCRzY29wZS5kaXJ0eSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gbGV0cztcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiBsZXRzID09PSAnb2JqZWN0Jykge1xuXHRcdFx0Y29uc3QgbWVyZ2VkID0gW107XG5cdFx0XHRjb25zdCBsZW4gPSBNYXRoLm1heCgkJHNjb3BlLmRpcnR5Lmxlbmd0aCwgbGV0cy5sZW5ndGgpO1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuXHRcdFx0XHRtZXJnZWRbaV0gPSAkJHNjb3BlLmRpcnR5W2ldIHwgbGV0c1tpXTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtZXJnZWQ7XG5cdFx0fVxuXHRcdHJldHVybiAkJHNjb3BlLmRpcnR5IHwgbGV0cztcblx0fVxuXHRyZXR1cm4gJCRzY29wZS5kaXJ0eTtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZV9zbG90X2Jhc2UoXG5cdHNsb3QsXG5cdHNsb3RfZGVmaW5pdGlvbixcblx0Y3R4LFxuXHQkJHNjb3BlLFxuXHRzbG90X2NoYW5nZXMsXG5cdGdldF9zbG90X2NvbnRleHRfZm5cbikge1xuXHRpZiAoc2xvdF9jaGFuZ2VzKSB7XG5cdFx0Y29uc3Qgc2xvdF9jb250ZXh0ID0gZ2V0X3Nsb3RfY29udGV4dChzbG90X2RlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZ2V0X3Nsb3RfY29udGV4dF9mbik7XG5cdFx0c2xvdC5wKHNsb3RfY29udGV4dCwgc2xvdF9jaGFuZ2VzKTtcblx0fVxufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlX3Nsb3QoXG5cdHNsb3QsXG5cdHNsb3RfZGVmaW5pdGlvbixcblx0Y3R4LFxuXHQkJHNjb3BlLFxuXHRkaXJ0eSxcblx0Z2V0X3Nsb3RfY2hhbmdlc19mbixcblx0Z2V0X3Nsb3RfY29udGV4dF9mblxuKSB7XG5cdGNvbnN0IHNsb3RfY2hhbmdlcyA9IGdldF9zbG90X2NoYW5nZXMoc2xvdF9kZWZpbml0aW9uLCAkJHNjb3BlLCBkaXJ0eSwgZ2V0X3Nsb3RfY2hhbmdlc19mbik7XG5cdHVwZGF0ZV9zbG90X2Jhc2Uoc2xvdCwgc2xvdF9kZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIHNsb3RfY2hhbmdlcywgZ2V0X3Nsb3RfY29udGV4dF9mbik7XG59XG5cbi8qKiBAcmV0dXJucyB7YW55W10gfCAtMX0gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRfYWxsX2RpcnR5X2Zyb21fc2NvcGUoJCRzY29wZSkge1xuXHRpZiAoJCRzY29wZS5jdHgubGVuZ3RoID4gMzIpIHtcblx0XHRjb25zdCBkaXJ0eSA9IFtdO1xuXHRcdGNvbnN0IGxlbmd0aCA9ICQkc2NvcGUuY3R4Lmxlbmd0aCAvIDMyO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdGRpcnR5W2ldID0gLTE7XG5cdFx0fVxuXHRcdHJldHVybiBkaXJ0eTtcblx0fVxuXHRyZXR1cm4gLTE7XG59XG5cbi8qKiBAcmV0dXJucyB7e319ICovXG5leHBvcnQgZnVuY3Rpb24gZXhjbHVkZV9pbnRlcm5hbF9wcm9wcyhwcm9wcykge1xuXHRjb25zdCByZXN1bHQgPSB7fTtcblx0Zm9yIChjb25zdCBrIGluIHByb3BzKSBpZiAoa1swXSAhPT0gJyQnKSByZXN1bHRba10gPSBwcm9wc1trXTtcblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqIEByZXR1cm5zIHt7fX0gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlX3Jlc3RfcHJvcHMocHJvcHMsIGtleXMpIHtcblx0Y29uc3QgcmVzdCA9IHt9O1xuXHRrZXlzID0gbmV3IFNldChrZXlzKTtcblx0Zm9yIChjb25zdCBrIGluIHByb3BzKSBpZiAoIWtleXMuaGFzKGspICYmIGtbMF0gIT09ICckJykgcmVzdFtrXSA9IHByb3BzW2tdO1xuXHRyZXR1cm4gcmVzdDtcbn1cblxuLyoqIEByZXR1cm5zIHt7fX0gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlX3Nsb3RzKHNsb3RzKSB7XG5cdGNvbnN0IHJlc3VsdCA9IHt9O1xuXHRmb3IgKGNvbnN0IGtleSBpbiBzbG90cykge1xuXHRcdHJlc3VsdFtrZXldID0gdHJ1ZTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG4vKiogQHJldHVybnMgeyh0aGlzOiBhbnksIC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9uY2UoZm4pIHtcblx0bGV0IHJhbiA9IGZhbHNlO1xuXHRyZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblx0XHRpZiAocmFuKSByZXR1cm47XG5cdFx0cmFuID0gdHJ1ZTtcblx0XHRmbi5jYWxsKHRoaXMsIC4uLmFyZ3MpO1xuXHR9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbnVsbF90b19lbXB0eSh2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRfc3RvcmVfdmFsdWUoc3RvcmUsIHJldCwgdmFsdWUpIHtcblx0c3RvcmUuc2V0KHZhbHVlKTtcblx0cmV0dXJuIHJldDtcbn1cblxuZXhwb3J0IGNvbnN0IGhhc19wcm9wID0gKG9iaiwgcHJvcCkgPT4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBhY3Rpb25fZGVzdHJveWVyKGFjdGlvbl9yZXN1bHQpIHtcblx0cmV0dXJuIGFjdGlvbl9yZXN1bHQgJiYgaXNfZnVuY3Rpb24oYWN0aW9uX3Jlc3VsdC5kZXN0cm95KSA/IGFjdGlvbl9yZXN1bHQuZGVzdHJveSA6IG5vb3A7XG59XG5cbi8qKiBAcGFyYW0ge251bWJlciB8IHN0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtbbnVtYmVyLCBzdHJpbmddfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3BsaXRfY3NzX3VuaXQodmFsdWUpIHtcblx0Y29uc3Qgc3BsaXQgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLm1hdGNoKC9eXFxzKigtP1tcXGQuXSspKFteXFxzXSopXFxzKiQvKTtcblx0cmV0dXJuIHNwbGl0ID8gW3BhcnNlRmxvYXQoc3BsaXRbMV0pLCBzcGxpdFsyXSB8fCAncHgnXSA6IFsvKiogQHR5cGUge251bWJlcn0gKi8gKHZhbHVlKSwgJ3B4J107XG59XG5cbmV4cG9ydCBjb25zdCBjb250ZW50ZWRpdGFibGVfdHJ1dGh5X3ZhbHVlcyA9IFsnJywgdHJ1ZSwgMSwgJ3RydWUnLCAnY29udGVudGVkaXRhYmxlJ107XG4iLCAiLyoqIEB0eXBlIHt0eXBlb2YgZ2xvYmFsVGhpc30gKi9cbmV4cG9ydCBjb25zdCBnbG9iYWxzID1cblx0dHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcblx0XHQ/IHdpbmRvd1xuXHRcdDogdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnXG5cdFx0PyBnbG9iYWxUaGlzXG5cdFx0OiAvLyBAdHMtaWdub3JlIE5vZGUgdHlwaW5ncyBoYXZlIHRoaXNcblx0XHQgIGdsb2JhbDtcbiIsICJpbXBvcnQgeyBnbG9iYWxzIH0gZnJvbSAnLi9nbG9iYWxzLmpzJztcblxuLyoqXG4gKiBSZXNpemUgb2JzZXJ2ZXIgc2luZ2xldG9uLlxuICogT25lIGxpc3RlbmVyIHBlciBlbGVtZW50IG9ubHkhXG4gKiBodHRwczovL2dyb3Vwcy5nb29nbGUuY29tL2EvY2hyb21pdW0ub3JnL2cvYmxpbmstZGV2L2MvejZpZW5PTlViNUEvbS9GNS1WY1VadEJBQUpcbiAqL1xuZXhwb3J0IGNsYXNzIFJlc2l6ZU9ic2VydmVyU2luZ2xldG9uIHtcblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEByZWFkb25seVxuXHQgKiBAdHlwZSB7V2Vha01hcDxFbGVtZW50LCBpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLkxpc3RlbmVyPn1cblx0ICovXG5cdF9saXN0ZW5lcnMgPSAnV2Vha01hcCcgaW4gZ2xvYmFscyA/IG5ldyBXZWFrTWFwKCkgOiB1bmRlZmluZWQ7XG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEB0eXBlIHtSZXNpemVPYnNlcnZlcn1cblx0ICovXG5cdF9vYnNlcnZlciA9IHVuZGVmaW5lZDtcblxuXHQvKiogQHR5cGUge1Jlc2l6ZU9ic2VydmVyT3B0aW9uc30gKi9cblx0b3B0aW9ucztcblxuXHQvKiogQHBhcmFtIHtSZXNpemVPYnNlcnZlck9wdGlvbnN9IG9wdGlvbnMgKi9cblx0Y29uc3RydWN0b3Iob3B0aW9ucykge1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG5cdCAqIEBwYXJhbSB7aW1wb3J0KCcuL3ByaXZhdGUuanMnKS5MaXN0ZW5lcn0gbGlzdGVuZXJcblx0ICogQHJldHVybnMgeygpID0+IHZvaWR9XG5cdCAqL1xuXHRvYnNlcnZlKGVsZW1lbnQsIGxpc3RlbmVyKSB7XG5cdFx0dGhpcy5fbGlzdGVuZXJzLnNldChlbGVtZW50LCBsaXN0ZW5lcik7XG5cdFx0dGhpcy5fZ2V0T2JzZXJ2ZXIoKS5vYnNlcnZlKGVsZW1lbnQsIHRoaXMub3B0aW9ucyk7XG5cdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdHRoaXMuX2xpc3RlbmVycy5kZWxldGUoZWxlbWVudCk7XG5cdFx0XHR0aGlzLl9vYnNlcnZlci51bm9ic2VydmUoZWxlbWVudCk7IC8vIHRoaXMgbGluZSBjYW4gcHJvYmFibHkgYmUgcmVtb3ZlZFxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9nZXRPYnNlcnZlcigpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0dGhpcy5fb2JzZXJ2ZXIgPz9cblx0XHRcdCh0aGlzLl9vYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoZW50cmllcykgPT4ge1xuXHRcdFx0XHRmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcblx0XHRcdFx0XHRSZXNpemVPYnNlcnZlclNpbmdsZXRvbi5lbnRyaWVzLnNldChlbnRyeS50YXJnZXQsIGVudHJ5KTtcblx0XHRcdFx0XHR0aGlzLl9saXN0ZW5lcnMuZ2V0KGVudHJ5LnRhcmdldCk/LihlbnRyeSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pKVxuXHRcdCk7XG5cdH1cbn1cblxuLy8gTmVlZHMgdG8gYmUgd3JpdHRlbiBsaWtlIHRoaXMgdG8gcGFzcyB0aGUgdHJlZS1zaGFrZS10ZXN0XG5SZXNpemVPYnNlcnZlclNpbmdsZXRvbi5lbnRyaWVzID0gJ1dlYWtNYXAnIGluIGdsb2JhbHMgPyBuZXcgV2Vha01hcCgpIDogdW5kZWZpbmVkO1xuIiwgImltcG9ydCB7IGNvbnRlbnRlZGl0YWJsZV90cnV0aHlfdmFsdWVzLCBoYXNfcHJvcCB9IGZyb20gJy4vdXRpbHMuanMnO1xuXG5pbXBvcnQgeyBSZXNpemVPYnNlcnZlclNpbmdsZXRvbiB9IGZyb20gJy4vUmVzaXplT2JzZXJ2ZXJTaW5nbGV0b24uanMnO1xuXG4vLyBUcmFjayB3aGljaCBub2RlcyBhcmUgY2xhaW1lZCBkdXJpbmcgaHlkcmF0aW9uLiBVbmNsYWltZWQgbm9kZXMgY2FuIHRoZW4gYmUgcmVtb3ZlZCBmcm9tIHRoZSBET01cbi8vIGF0IHRoZSBlbmQgb2YgaHlkcmF0aW9uIHdpdGhvdXQgdG91Y2hpbmcgdGhlIHJlbWFpbmluZyBub2Rlcy5cbmxldCBpc19oeWRyYXRpbmcgPSBmYWxzZTtcblxuLyoqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0X2h5ZHJhdGluZygpIHtcblx0aXNfaHlkcmF0aW5nID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuZF9oeWRyYXRpbmcoKSB7XG5cdGlzX2h5ZHJhdGluZyA9IGZhbHNlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3dcbiAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoXG4gKiBAcGFyYW0geyhpbmRleDogbnVtYmVyKSA9PiBudW1iZXJ9IGtleVxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiB1cHBlcl9ib3VuZChsb3csIGhpZ2gsIGtleSwgdmFsdWUpIHtcblx0Ly8gUmV0dXJuIGZpcnN0IGluZGV4IG9mIHZhbHVlIGxhcmdlciB0aGFuIGlucHV0IHZhbHVlIGluIHRoZSByYW5nZSBbbG93LCBoaWdoKVxuXHR3aGlsZSAobG93IDwgaGlnaCkge1xuXHRcdGNvbnN0IG1pZCA9IGxvdyArICgoaGlnaCAtIGxvdykgPj4gMSk7XG5cdFx0aWYgKGtleShtaWQpIDw9IHZhbHVlKSB7XG5cdFx0XHRsb3cgPSBtaWQgKyAxO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRoaWdoID0gbWlkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbG93O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZUV4fSB0YXJnZXRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBpbml0X2h5ZHJhdGUodGFyZ2V0KSB7XG5cdGlmICh0YXJnZXQuaHlkcmF0ZV9pbml0KSByZXR1cm47XG5cdHRhcmdldC5oeWRyYXRlX2luaXQgPSB0cnVlO1xuXHQvLyBXZSBrbm93IHRoYXQgYWxsIGNoaWxkcmVuIGhhdmUgY2xhaW1fb3JkZXIgdmFsdWVzIHNpbmNlIHRoZSB1bmNsYWltZWQgaGF2ZSBiZWVuIGRldGFjaGVkIGlmIHRhcmdldCBpcyBub3QgPGhlYWQ+XG5cblx0bGV0IGNoaWxkcmVuID0gLyoqIEB0eXBlIHtBcnJheUxpa2U8Tm9kZUV4Mj59ICovICh0YXJnZXQuY2hpbGROb2Rlcyk7XG5cdC8vIElmIHRhcmdldCBpcyA8aGVhZD4sIHRoZXJlIG1heSBiZSBjaGlsZHJlbiB3aXRob3V0IGNsYWltX29yZGVyXG5cdGlmICh0YXJnZXQubm9kZU5hbWUgPT09ICdIRUFEJykge1xuXHRcdGNvbnN0IG15X2NoaWxkcmVuID0gW107XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3Qgbm9kZSA9IGNoaWxkcmVuW2ldO1xuXHRcdFx0aWYgKG5vZGUuY2xhaW1fb3JkZXIgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRteV9jaGlsZHJlbi5wdXNoKG5vZGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRjaGlsZHJlbiA9IG15X2NoaWxkcmVuO1xuXHR9XG5cdC8qXG5cdCAqIFJlb3JkZXIgY2xhaW1lZCBjaGlsZHJlbiBvcHRpbWFsbHkuXG5cdCAqIFdlIGNhbiByZW9yZGVyIGNsYWltZWQgY2hpbGRyZW4gb3B0aW1hbGx5IGJ5IGZpbmRpbmcgdGhlIGxvbmdlc3Qgc3Vic2VxdWVuY2Ugb2Zcblx0ICogbm9kZXMgdGhhdCBhcmUgYWxyZWFkeSBjbGFpbWVkIGluIG9yZGVyIGFuZCBvbmx5IG1vdmluZyB0aGUgcmVzdC4gVGhlIGxvbmdlc3Rcblx0ICogc3Vic2VxdWVuY2Ugb2Ygbm9kZXMgdGhhdCBhcmUgY2xhaW1lZCBpbiBvcmRlciBjYW4gYmUgZm91bmQgYnlcblx0ICogY29tcHV0aW5nIHRoZSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2Ugb2YgLmNsYWltX29yZGVyIHZhbHVlcy5cblx0ICpcblx0ICogVGhpcyBhbGdvcml0aG0gaXMgb3B0aW1hbCBpbiBnZW5lcmF0aW5nIHRoZSBsZWFzdCBhbW91bnQgb2YgcmVvcmRlciBvcGVyYXRpb25zXG5cdCAqIHBvc3NpYmxlLlxuXHQgKlxuXHQgKiBQcm9vZjpcblx0ICogV2Uga25vdyB0aGF0LCBnaXZlbiBhIHNldCBvZiByZW9yZGVyaW5nIG9wZXJhdGlvbnMsIHRoZSBub2RlcyB0aGF0IGRvIG5vdCBtb3ZlXG5cdCAqIGFsd2F5cyBmb3JtIGFuIGluY3JlYXNpbmcgc3Vic2VxdWVuY2UsIHNpbmNlIHRoZXkgZG8gbm90IG1vdmUgYW1vbmcgZWFjaCBvdGhlclxuXHQgKiBtZWFuaW5nIHRoYXQgdGhleSBtdXN0IGJlIGFscmVhZHkgb3JkZXJlZCBhbW9uZyBlYWNoIG90aGVyLiBUaHVzLCB0aGUgbWF4aW1hbFxuXHQgKiBzZXQgb2Ygbm9kZXMgdGhhdCBkbyBub3QgbW92ZSBmb3JtIGEgbG9uZ2VzdCBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlLlxuXHQgKi9cblx0Ly8gQ29tcHV0ZSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2Vcblx0Ly8gbTogc3Vic2VxdWVuY2UgbGVuZ3RoIGogPT4gaW5kZXggayBvZiBzbWFsbGVzdCB2YWx1ZSB0aGF0IGVuZHMgYW4gaW5jcmVhc2luZyBzdWJzZXF1ZW5jZSBvZiBsZW5ndGggalxuXHRjb25zdCBtID0gbmV3IEludDMyQXJyYXkoY2hpbGRyZW4ubGVuZ3RoICsgMSk7XG5cdC8vIFByZWRlY2Vzc29yIGluZGljZXMgKyAxXG5cdGNvbnN0IHAgPSBuZXcgSW50MzJBcnJheShjaGlsZHJlbi5sZW5ndGgpO1xuXHRtWzBdID0gLTE7XG5cdGxldCBsb25nZXN0ID0gMDtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdGNvbnN0IGN1cnJlbnQgPSBjaGlsZHJlbltpXS5jbGFpbV9vcmRlcjtcblx0XHQvLyBGaW5kIHRoZSBsYXJnZXN0IHN1YnNlcXVlbmNlIGxlbmd0aCBzdWNoIHRoYXQgaXQgZW5kcyBpbiBhIHZhbHVlIGxlc3MgdGhhbiBvdXIgY3VycmVudCB2YWx1ZVxuXHRcdC8vIHVwcGVyX2JvdW5kIHJldHVybnMgZmlyc3QgZ3JlYXRlciB2YWx1ZSwgc28gd2Ugc3VidHJhY3Qgb25lXG5cdFx0Ly8gd2l0aCBmYXN0IHBhdGggZm9yIHdoZW4gd2UgYXJlIG9uIHRoZSBjdXJyZW50IGxvbmdlc3Qgc3Vic2VxdWVuY2Vcblx0XHRjb25zdCBzZXFfbGVuID1cblx0XHRcdChsb25nZXN0ID4gMCAmJiBjaGlsZHJlblttW2xvbmdlc3RdXS5jbGFpbV9vcmRlciA8PSBjdXJyZW50XG5cdFx0XHRcdD8gbG9uZ2VzdCArIDFcblx0XHRcdFx0OiB1cHBlcl9ib3VuZCgxLCBsb25nZXN0LCAoaWR4KSA9PiBjaGlsZHJlblttW2lkeF1dLmNsYWltX29yZGVyLCBjdXJyZW50KSkgLSAxO1xuXHRcdHBbaV0gPSBtW3NlcV9sZW5dICsgMTtcblx0XHRjb25zdCBuZXdfbGVuID0gc2VxX2xlbiArIDE7XG5cdFx0Ly8gV2UgY2FuIGd1YXJhbnRlZSB0aGF0IGN1cnJlbnQgaXMgdGhlIHNtYWxsZXN0IHZhbHVlLiBPdGhlcndpc2UsIHdlIHdvdWxkIGhhdmUgZ2VuZXJhdGVkIGEgbG9uZ2VyIHNlcXVlbmNlLlxuXHRcdG1bbmV3X2xlbl0gPSBpO1xuXHRcdGxvbmdlc3QgPSBNYXRoLm1heChuZXdfbGVuLCBsb25nZXN0KTtcblx0fVxuXHQvLyBUaGUgbG9uZ2VzdCBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlIG9mIG5vZGVzIChpbml0aWFsbHkgcmV2ZXJzZWQpXG5cblx0LyoqXG5cdCAqIEB0eXBlIHtOb2RlRXgyW119XG5cdCAqL1xuXHRjb25zdCBsaXMgPSBbXTtcblx0Ly8gVGhlIHJlc3Qgb2YgdGhlIG5vZGVzLCBub2RlcyB0aGF0IHdpbGwgYmUgbW92ZWRcblxuXHQvKipcblx0ICogQHR5cGUge05vZGVFeDJbXX1cblx0ICovXG5cdGNvbnN0IHRvX21vdmUgPSBbXTtcblx0bGV0IGxhc3QgPSBjaGlsZHJlbi5sZW5ndGggLSAxO1xuXHRmb3IgKGxldCBjdXIgPSBtW2xvbmdlc3RdICsgMTsgY3VyICE9IDA7IGN1ciA9IHBbY3VyIC0gMV0pIHtcblx0XHRsaXMucHVzaChjaGlsZHJlbltjdXIgLSAxXSk7XG5cdFx0Zm9yICg7IGxhc3QgPj0gY3VyOyBsYXN0LS0pIHtcblx0XHRcdHRvX21vdmUucHVzaChjaGlsZHJlbltsYXN0XSk7XG5cdFx0fVxuXHRcdGxhc3QtLTtcblx0fVxuXHRmb3IgKDsgbGFzdCA+PSAwOyBsYXN0LS0pIHtcblx0XHR0b19tb3ZlLnB1c2goY2hpbGRyZW5bbGFzdF0pO1xuXHR9XG5cdGxpcy5yZXZlcnNlKCk7XG5cdC8vIFdlIHNvcnQgdGhlIG5vZGVzIGJlaW5nIG1vdmVkIHRvIGd1YXJhbnRlZSB0aGF0IHRoZWlyIGluc2VydGlvbiBvcmRlciBtYXRjaGVzIHRoZSBjbGFpbSBvcmRlclxuXHR0b19tb3ZlLnNvcnQoKGEsIGIpID0+IGEuY2xhaW1fb3JkZXIgLSBiLmNsYWltX29yZGVyKTtcblx0Ly8gRmluYWxseSwgd2UgbW92ZSB0aGUgbm9kZXNcblx0Zm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgdG9fbW92ZS5sZW5ndGg7IGkrKykge1xuXHRcdHdoaWxlIChqIDwgbGlzLmxlbmd0aCAmJiB0b19tb3ZlW2ldLmNsYWltX29yZGVyID49IGxpc1tqXS5jbGFpbV9vcmRlcikge1xuXHRcdFx0aisrO1xuXHRcdH1cblx0XHRjb25zdCBhbmNob3IgPSBqIDwgbGlzLmxlbmd0aCA/IGxpc1tqXSA6IG51bGw7XG5cdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSh0b19tb3ZlW2ldLCBhbmNob3IpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmQodGFyZ2V0LCBub2RlKSB7XG5cdHRhcmdldC5hcHBlbmRDaGlsZChub2RlKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICogQHBhcmFtIHtzdHJpbmd9IHN0eWxlX3NoZWV0X2lkXG4gKiBAcGFyYW0ge3N0cmluZ30gc3R5bGVzXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGVuZF9zdHlsZXModGFyZ2V0LCBzdHlsZV9zaGVldF9pZCwgc3R5bGVzKSB7XG5cdGNvbnN0IGFwcGVuZF9zdHlsZXNfdG8gPSBnZXRfcm9vdF9mb3Jfc3R5bGUodGFyZ2V0KTtcblx0aWYgKCFhcHBlbmRfc3R5bGVzX3RvLmdldEVsZW1lbnRCeUlkKHN0eWxlX3NoZWV0X2lkKSkge1xuXHRcdGNvbnN0IHN0eWxlID0gZWxlbWVudCgnc3R5bGUnKTtcblx0XHRzdHlsZS5pZCA9IHN0eWxlX3NoZWV0X2lkO1xuXHRcdHN0eWxlLnRleHRDb250ZW50ID0gc3R5bGVzO1xuXHRcdGFwcGVuZF9zdHlsZXNoZWV0KGFwcGVuZF9zdHlsZXNfdG8sIHN0eWxlKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHJldHVybnMge1NoYWRvd1Jvb3QgfCBEb2N1bWVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldF9yb290X2Zvcl9zdHlsZShub2RlKSB7XG5cdGlmICghbm9kZSkgcmV0dXJuIGRvY3VtZW50O1xuXHRjb25zdCByb290ID0gbm9kZS5nZXRSb290Tm9kZSA/IG5vZGUuZ2V0Um9vdE5vZGUoKSA6IG5vZGUub3duZXJEb2N1bWVudDtcblx0aWYgKHJvb3QgJiYgLyoqIEB0eXBlIHtTaGFkb3dSb290fSAqLyAocm9vdCkuaG9zdCkge1xuXHRcdHJldHVybiAvKiogQHR5cGUge1NoYWRvd1Jvb3R9ICovIChyb290KTtcblx0fVxuXHRyZXR1cm4gbm9kZS5vd25lckRvY3VtZW50O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHJldHVybnMge0NTU1N0eWxlU2hlZXR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRfZW1wdHlfc3R5bGVzaGVldChub2RlKSB7XG5cdGNvbnN0IHN0eWxlX2VsZW1lbnQgPSBlbGVtZW50KCdzdHlsZScpO1xuXHQvLyBGb3IgdHJhbnNpdGlvbnMgdG8gd29yayB3aXRob3V0ICdzdHlsZS1zcmM6IHVuc2FmZS1pbmxpbmUnIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5LFxuXHQvLyB0aGVzZSBlbXB0eSB0YWdzIG5lZWQgdG8gYmUgYWxsb3dlZCB3aXRoIGEgaGFzaCBhcyBhIHdvcmthcm91bmQgdW50aWwgd2UgbW92ZSB0byB0aGUgV2ViIEFuaW1hdGlvbnMgQVBJLlxuXHQvLyBVc2luZyB0aGUgaGFzaCBmb3IgdGhlIGVtcHR5IHN0cmluZyAoZm9yIGFuIGVtcHR5IHRhZykgd29ya3MgaW4gYWxsIGJyb3dzZXJzIGV4Y2VwdCBTYWZhcmkuXG5cdC8vIFNvIGFzIGEgd29ya2Fyb3VuZCBmb3IgdGhlIHdvcmthcm91bmQsIHdoZW4gd2UgYXBwZW5kIGVtcHR5IHN0eWxlIHRhZ3Mgd2Ugc2V0IHRoZWlyIGNvbnRlbnQgdG8gLyogZW1wdHkgKi8uXG5cdC8vIFRoZSBoYXNoICdzaGEyNTYtOU9sTk8wRE5FZWFWekhMNFJad0NMc0JIQThXQlE4dG9CcC80RjVYVjJuYz0nIHdpbGwgdGhlbiB3b3JrIGV2ZW4gaW4gU2FmYXJpLlxuXHRzdHlsZV9lbGVtZW50LnRleHRDb250ZW50ID0gJy8qIGVtcHR5ICovJztcblx0YXBwZW5kX3N0eWxlc2hlZXQoZ2V0X3Jvb3RfZm9yX3N0eWxlKG5vZGUpLCBzdHlsZV9lbGVtZW50KTtcblx0cmV0dXJuIHN0eWxlX2VsZW1lbnQuc2hlZXQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTaGFkb3dSb290IHwgRG9jdW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7SFRNTFN0eWxlRWxlbWVudH0gc3R5bGVcbiAqIEByZXR1cm5zIHtDU1NTdHlsZVNoZWV0fVxuICovXG5mdW5jdGlvbiBhcHBlbmRfc3R5bGVzaGVldChub2RlLCBzdHlsZSkge1xuXHRhcHBlbmQoLyoqIEB0eXBlIHtEb2N1bWVudH0gKi8gKG5vZGUpLmhlYWQgfHwgbm9kZSwgc3R5bGUpO1xuXHRyZXR1cm4gc3R5bGUuc2hlZXQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlRXh9IHRhcmdldFxuICogQHBhcmFtIHtOb2RlRXh9IG5vZGVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kX2h5ZHJhdGlvbih0YXJnZXQsIG5vZGUpIHtcblx0aWYgKGlzX2h5ZHJhdGluZykge1xuXHRcdGluaXRfaHlkcmF0ZSh0YXJnZXQpO1xuXHRcdGlmIChcblx0XHRcdHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkID09PSB1bmRlZmluZWQgfHxcblx0XHRcdCh0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCAhPT0gbnVsbCAmJiB0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZC5wYXJlbnROb2RlICE9PSB0YXJnZXQpXG5cdFx0KSB7XG5cdFx0XHR0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCA9IHRhcmdldC5maXJzdENoaWxkO1xuXHRcdH1cblx0XHQvLyBTa2lwIG5vZGVzIG9mIHVuZGVmaW5lZCBvcmRlcmluZ1xuXHRcdHdoaWxlICh0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCAhPT0gbnVsbCAmJiB0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZC5jbGFpbV9vcmRlciA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCA9IHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkLm5leHRTaWJsaW5nO1xuXHRcdH1cblx0XHRpZiAobm9kZSAhPT0gdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQpIHtcblx0XHRcdC8vIFdlIG9ubHkgaW5zZXJ0IGlmIHRoZSBvcmRlcmluZyBvZiB0aGlzIG5vZGUgc2hvdWxkIGJlIG1vZGlmaWVkIG9yIHRoZSBwYXJlbnQgbm9kZSBpcyBub3QgdGFyZ2V0XG5cdFx0XHRpZiAobm9kZS5jbGFpbV9vcmRlciAhPT0gdW5kZWZpbmVkIHx8IG5vZGUucGFyZW50Tm9kZSAhPT0gdGFyZ2V0KSB7XG5cdFx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUobm9kZSwgdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCA9IG5vZGUubmV4dFNpYmxpbmc7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKG5vZGUucGFyZW50Tm9kZSAhPT0gdGFyZ2V0IHx8IG5vZGUubmV4dFNpYmxpbmcgIT09IG51bGwpIHtcblx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQobm9kZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge05vZGV9IFthbmNob3JdXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluc2VydCh0YXJnZXQsIG5vZGUsIGFuY2hvcikge1xuXHR0YXJnZXQuaW5zZXJ0QmVmb3JlKG5vZGUsIGFuY2hvciB8fCBudWxsKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGVFeH0gdGFyZ2V0XG4gKiBAcGFyYW0ge05vZGVFeH0gbm9kZVxuICogQHBhcmFtIHtOb2RlRXh9IFthbmNob3JdXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluc2VydF9oeWRyYXRpb24odGFyZ2V0LCBub2RlLCBhbmNob3IpIHtcblx0aWYgKGlzX2h5ZHJhdGluZyAmJiAhYW5jaG9yKSB7XG5cdFx0YXBwZW5kX2h5ZHJhdGlvbih0YXJnZXQsIG5vZGUpO1xuXHR9IGVsc2UgaWYgKG5vZGUucGFyZW50Tm9kZSAhPT0gdGFyZ2V0IHx8IG5vZGUubmV4dFNpYmxpbmcgIT0gYW5jaG9yKSB7XG5cdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShub2RlLCBhbmNob3IgfHwgbnVsbCk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGV0YWNoKG5vZGUpIHtcblx0aWYgKG5vZGUucGFyZW50Tm9kZSkge1xuXHRcdG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcblx0fVxufVxuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlc3Ryb3lfZWFjaChpdGVyYXRpb25zLCBkZXRhY2hpbmcpIHtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyYXRpb25zLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0aWYgKGl0ZXJhdGlvbnNbaV0pIGl0ZXJhdGlvbnNbaV0uZChkZXRhY2hpbmcpO1xuXHR9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIHtrZXlvZiBIVE1MRWxlbWVudFRhZ05hbWVNYXB9IEtcbiAqIEBwYXJhbSB7S30gbmFtZVxuICogQHJldHVybnMge0hUTUxFbGVtZW50VGFnTmFtZU1hcFtLXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVsZW1lbnQobmFtZSkge1xuXHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lKTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge2tleW9mIEhUTUxFbGVtZW50VGFnTmFtZU1hcH0gS1xuICogQHBhcmFtIHtLfSBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gaXNcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudFRhZ05hbWVNYXBbS119XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbGVtZW50X2lzKG5hbWUsIGlzKSB7XG5cdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUsIHsgaXMgfSk7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEB0ZW1wbGF0ZSB7a2V5b2YgVH0gS1xuICogQHBhcmFtIHtUfSBvYmpcbiAqIEBwYXJhbSB7S1tdfSBleGNsdWRlXG4gKiBAcmV0dXJucyB7UGljazxULCBFeGNsdWRlPGtleW9mIFQsIEs+Pn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9iamVjdF93aXRob3V0X3Byb3BlcnRpZXMob2JqLCBleGNsdWRlKSB7XG5cdGNvbnN0IHRhcmdldCA9IC8qKiBAdHlwZSB7UGljazxULCBFeGNsdWRlPGtleW9mIFQsIEs+Pn0gKi8gKHt9KTtcblx0Zm9yIChjb25zdCBrIGluIG9iaikge1xuXHRcdGlmIChcblx0XHRcdGhhc19wcm9wKG9iaiwgaykgJiZcblx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdGV4Y2x1ZGUuaW5kZXhPZihrKSA9PT0gLTFcblx0XHQpIHtcblx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdHRhcmdldFtrXSA9IG9ialtrXTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHRhcmdldDtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge2tleW9mIFNWR0VsZW1lbnRUYWdOYW1lTWFwfSBLXG4gKiBAcGFyYW0ge0t9IG5hbWVcbiAqIEByZXR1cm5zIHtTVkdFbGVtZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3ZnX2VsZW1lbnQobmFtZSkge1xuXHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsIG5hbWUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhXG4gKiBAcmV0dXJucyB7VGV4dH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRleHQoZGF0YSkge1xuXHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZGF0YSk7XG59XG5cbi8qKlxuICogQHJldHVybnMge1RleHR9ICovXG5leHBvcnQgZnVuY3Rpb24gc3BhY2UoKSB7XG5cdHJldHVybiB0ZXh0KCcgJyk7XG59XG5cbi8qKlxuICogQHJldHVybnMge1RleHR9ICovXG5leHBvcnQgZnVuY3Rpb24gZW1wdHkoKSB7XG5cdHJldHVybiB0ZXh0KCcnKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGVudFxuICogQHJldHVybnMge0NvbW1lbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21tZW50KGNvbnRlbnQpIHtcblx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoY29udGVudCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0V2ZW50TGlzdGVuZXJPckV2ZW50TGlzdGVuZXJPYmplY3R9IGhhbmRsZXJcbiAqIEBwYXJhbSB7Ym9vbGVhbiB8IEFkZEV2ZW50TGlzdGVuZXJPcHRpb25zIHwgRXZlbnRMaXN0ZW5lck9wdGlvbnN9IFtvcHRpb25zXVxuICogQHJldHVybnMgeygpID0+IHZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaXN0ZW4obm9kZSwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpIHtcblx0bm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcblx0cmV0dXJuICgpID0+IG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogQHJldHVybnMgeyhldmVudDogYW55KSA9PiBhbnl9ICovXG5leHBvcnQgZnVuY3Rpb24gcHJldmVudF9kZWZhdWx0KGZuKSB7XG5cdHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRyZXR1cm4gZm4uY2FsbCh0aGlzLCBldmVudCk7XG5cdH07XG59XG5cbi8qKlxuICogQHJldHVybnMgeyhldmVudDogYW55KSA9PiBhbnl9ICovXG5leHBvcnQgZnVuY3Rpb24gc3RvcF9wcm9wYWdhdGlvbihmbikge1xuXHRyZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdHJldHVybiBmbi5jYWxsKHRoaXMsIGV2ZW50KTtcblx0fTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7KGV2ZW50OiBhbnkpID0+IGFueX0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdG9wX2ltbWVkaWF0ZV9wcm9wYWdhdGlvbihmbikge1xuXHRyZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdHJldHVybiBmbi5jYWxsKHRoaXMsIGV2ZW50KTtcblx0fTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7KGV2ZW50OiBhbnkpID0+IHZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gc2VsZihmbikge1xuXHRyZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdGlmIChldmVudC50YXJnZXQgPT09IHRoaXMpIGZuLmNhbGwodGhpcywgZXZlbnQpO1xuXHR9O1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHsoZXZlbnQ6IGFueSkgPT4gdm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cnVzdGVkKGZuKSB7XG5cdHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0aWYgKGV2ZW50LmlzVHJ1c3RlZCkgZm4uY2FsbCh0aGlzLCBldmVudCk7XG5cdH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gW3ZhbHVlXVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhdHRyKG5vZGUsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcblx0aWYgKHZhbHVlID09IG51bGwpIG5vZGUucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG5cdGVsc2UgaWYgKG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZSkgIT09IHZhbHVlKSBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIHZhbHVlKTtcbn1cbi8qKlxuICogTGlzdCBvZiBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIGFsd2F5cyBiZSBzZXQgdGhyb3VnaCB0aGUgYXR0ciBtZXRob2QsXG4gKiBiZWNhdXNlIHVwZGF0aW5nIHRoZW0gdGhyb3VnaCB0aGUgcHJvcGVydHkgc2V0dGVyIGRvZXNuJ3Qgd29yayByZWxpYWJseS5cbiAqIEluIHRoZSBleGFtcGxlIG9mIGB3aWR0aGAvYGhlaWdodGAsIHRoZSBwcm9ibGVtIGlzIHRoYXQgdGhlIHNldHRlciBvbmx5XG4gKiBhY2NlcHRzIG51bWVyaWMgdmFsdWVzLCBidXQgdGhlIGF0dHJpYnV0ZSBjYW4gYWxzbyBiZSBzZXQgdG8gYSBzdHJpbmcgbGlrZSBgNTAlYC5cbiAqIElmIHRoaXMgbGlzdCBiZWNvbWVzIHRvbyBiaWcsIHJldGhpbmsgdGhpcyBhcHByb2FjaC5cbiAqL1xuY29uc3QgYWx3YXlzX3NldF90aHJvdWdoX3NldF9hdHRyaWJ1dGUgPSBbJ3dpZHRoJywgJ2hlaWdodCddO1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudCAmIEVsZW1lbnRDU1NJbmxpbmVTdHlsZX0gbm9kZVxuICogQHBhcmFtIHt7IFt4OiBzdHJpbmddOiBzdHJpbmcgfX0gYXR0cmlidXRlc1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfYXR0cmlidXRlcyhub2RlLCBhdHRyaWJ1dGVzKSB7XG5cdC8vIEB0cy1pZ25vcmVcblx0Y29uc3QgZGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhub2RlLl9fcHJvdG9fXyk7XG5cdGZvciAoY29uc3Qga2V5IGluIGF0dHJpYnV0ZXMpIHtcblx0XHRpZiAoYXR0cmlidXRlc1trZXldID09IG51bGwpIHtcblx0XHRcdG5vZGUucmVtb3ZlQXR0cmlidXRlKGtleSk7XG5cdFx0fSBlbHNlIGlmIChrZXkgPT09ICdzdHlsZScpIHtcblx0XHRcdG5vZGUuc3R5bGUuY3NzVGV4dCA9IGF0dHJpYnV0ZXNba2V5XTtcblx0XHR9IGVsc2UgaWYgKGtleSA9PT0gJ19fdmFsdWUnKSB7XG5cdFx0XHQvKiogQHR5cGUge2FueX0gKi8gKG5vZGUpLnZhbHVlID0gbm9kZVtrZXldID0gYXR0cmlidXRlc1trZXldO1xuXHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRkZXNjcmlwdG9yc1trZXldICYmXG5cdFx0XHRkZXNjcmlwdG9yc1trZXldLnNldCAmJlxuXHRcdFx0YWx3YXlzX3NldF90aHJvdWdoX3NldF9hdHRyaWJ1dGUuaW5kZXhPZihrZXkpID09PSAtMVxuXHRcdCkge1xuXHRcdFx0bm9kZVtrZXldID0gYXR0cmlidXRlc1trZXldO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhdHRyKG5vZGUsIGtleSwgYXR0cmlidXRlc1trZXldKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnQgJiBFbGVtZW50Q1NTSW5saW5lU3R5bGV9IG5vZGVcbiAqIEBwYXJhbSB7eyBbeDogc3RyaW5nXTogc3RyaW5nIH19IGF0dHJpYnV0ZXNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X3N2Z19hdHRyaWJ1dGVzKG5vZGUsIGF0dHJpYnV0ZXMpIHtcblx0Zm9yIChjb25zdCBrZXkgaW4gYXR0cmlidXRlcykge1xuXHRcdGF0dHIobm9kZSwga2V5LCBhdHRyaWJ1dGVzW2tleV0pO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn0gZGF0YV9tYXBcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2N1c3RvbV9lbGVtZW50X2RhdGFfbWFwKG5vZGUsIGRhdGFfbWFwKSB7XG5cdE9iamVjdC5rZXlzKGRhdGFfbWFwKS5mb3JFYWNoKChrZXkpID0+IHtcblx0XHRzZXRfY3VzdG9tX2VsZW1lbnRfZGF0YShub2RlLCBrZXksIGRhdGFfbWFwW2tleV0pO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfY3VzdG9tX2VsZW1lbnRfZGF0YShub2RlLCBwcm9wLCB2YWx1ZSkge1xuXHRjb25zdCBsb3dlciA9IHByb3AudG9Mb3dlckNhc2UoKTsgLy8gZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggZXhpc3RpbmcgYmVoYXZpb3Igd2UgZG8gbG93ZXJjYXNlIGZpcnN0XG5cdGlmIChsb3dlciBpbiBub2RlKSB7XG5cdFx0bm9kZVtsb3dlcl0gPSB0eXBlb2Ygbm9kZVtsb3dlcl0gPT09ICdib29sZWFuJyAmJiB2YWx1ZSA9PT0gJycgPyB0cnVlIDogdmFsdWU7XG5cdH0gZWxzZSBpZiAocHJvcCBpbiBub2RlKSB7XG5cdFx0bm9kZVtwcm9wXSA9IHR5cGVvZiBub2RlW3Byb3BdID09PSAnYm9vbGVhbicgJiYgdmFsdWUgPT09ICcnID8gdHJ1ZSA6IHZhbHVlO1xuXHR9IGVsc2Uge1xuXHRcdGF0dHIobm9kZSwgcHJvcCwgdmFsdWUpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2R5bmFtaWNfZWxlbWVudF9kYXRhKHRhZykge1xuXHRyZXR1cm4gLy0vLnRlc3QodGFnKSA/IHNldF9jdXN0b21fZWxlbWVudF9kYXRhX21hcCA6IHNldF9hdHRyaWJ1dGVzO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24geGxpbmtfYXR0cihub2RlLCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG5cdG5vZGUuc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCBhdHRyaWJ1dGUsIHZhbHVlKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0X3N2ZWx0ZV9kYXRhc2V0KG5vZGUpIHtcblx0cmV0dXJuIG5vZGUuZGF0YXNldC5zdmVsdGVIO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHt1bmtub3duW119ICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0X2JpbmRpbmdfZ3JvdXBfdmFsdWUoZ3JvdXAsIF9fdmFsdWUsIGNoZWNrZWQpIHtcblx0Y29uc3QgdmFsdWUgPSBuZXcgU2V0KCk7XG5cdGZvciAobGV0IGkgPSAwOyBpIDwgZ3JvdXAubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRpZiAoZ3JvdXBbaV0uY2hlY2tlZCkgdmFsdWUuYWRkKGdyb3VwW2ldLl9fdmFsdWUpO1xuXHR9XG5cdGlmICghY2hlY2tlZCkge1xuXHRcdHZhbHVlLmRlbGV0ZShfX3ZhbHVlKTtcblx0fVxuXHRyZXR1cm4gQXJyYXkuZnJvbSh2YWx1ZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50W119IGdyb3VwXG4gKiBAcmV0dXJucyB7eyBwKC4uLmlucHV0czogSFRNTElucHV0RWxlbWVudFtdKTogdm9pZDsgcigpOiB2b2lkOyB9fVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdF9iaW5kaW5nX2dyb3VwKGdyb3VwKSB7XG5cdC8qKlxuXHQgKiBAdHlwZSB7SFRNTElucHV0RWxlbWVudFtdfSAqL1xuXHRsZXQgX2lucHV0cztcblx0cmV0dXJuIHtcblx0XHQvKiBwdXNoICovIHAoLi4uaW5wdXRzKSB7XG5cdFx0XHRfaW5wdXRzID0gaW5wdXRzO1xuXHRcdFx0X2lucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4gZ3JvdXAucHVzaChpbnB1dCkpO1xuXHRcdH0sXG5cdFx0LyogcmVtb3ZlICovIHIoKSB7XG5cdFx0XHRfaW5wdXRzLmZvckVhY2goKGlucHV0KSA9PiBncm91cC5zcGxpY2UoZ3JvdXAuaW5kZXhPZihpbnB1dCksIDEpKTtcblx0XHR9XG5cdH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJbXX0gaW5kZXhlc1xuICogQHJldHVybnMge3sgdShuZXdfaW5kZXhlczogbnVtYmVyW10pOiB2b2lkOyBwKC4uLmlucHV0czogSFRNTElucHV0RWxlbWVudFtdKTogdm9pZDsgcjogKCkgPT4gdm9pZDsgfX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluaXRfYmluZGluZ19ncm91cF9keW5hbWljKGdyb3VwLCBpbmRleGVzKSB7XG5cdC8qKlxuXHQgKiBAdHlwZSB7SFRNTElucHV0RWxlbWVudFtdfSAqL1xuXHRsZXQgX2dyb3VwID0gZ2V0X2JpbmRpbmdfZ3JvdXAoZ3JvdXApO1xuXG5cdC8qKlxuXHQgKiBAdHlwZSB7SFRNTElucHV0RWxlbWVudFtdfSAqL1xuXHRsZXQgX2lucHV0cztcblxuXHRmdW5jdGlvbiBnZXRfYmluZGluZ19ncm91cChncm91cCkge1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXhlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0Z3JvdXAgPSBncm91cFtpbmRleGVzW2ldXSA9IGdyb3VwW2luZGV4ZXNbaV1dIHx8IFtdO1xuXHRcdH1cblx0XHRyZXR1cm4gZ3JvdXA7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge3ZvaWR9ICovXG5cdGZ1bmN0aW9uIHB1c2goKSB7XG5cdFx0X2lucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4gX2dyb3VwLnB1c2goaW5wdXQpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7dm9pZH0gKi9cblx0ZnVuY3Rpb24gcmVtb3ZlKCkge1xuXHRcdF9pbnB1dHMuZm9yRWFjaCgoaW5wdXQpID0+IF9ncm91cC5zcGxpY2UoX2dyb3VwLmluZGV4T2YoaW5wdXQpLCAxKSk7XG5cdH1cblx0cmV0dXJuIHtcblx0XHQvKiB1cGRhdGUgKi8gdShuZXdfaW5kZXhlcykge1xuXHRcdFx0aW5kZXhlcyA9IG5ld19pbmRleGVzO1xuXHRcdFx0Y29uc3QgbmV3X2dyb3VwID0gZ2V0X2JpbmRpbmdfZ3JvdXAoZ3JvdXApO1xuXHRcdFx0aWYgKG5ld19ncm91cCAhPT0gX2dyb3VwKSB7XG5cdFx0XHRcdHJlbW92ZSgpO1xuXHRcdFx0XHRfZ3JvdXAgPSBuZXdfZ3JvdXA7XG5cdFx0XHRcdHB1c2goKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdC8qIHB1c2ggKi8gcCguLi5pbnB1dHMpIHtcblx0XHRcdF9pbnB1dHMgPSBpbnB1dHM7XG5cdFx0XHRwdXNoKCk7XG5cdFx0fSxcblx0XHQvKiByZW1vdmUgKi8gcjogcmVtb3ZlXG5cdH07XG59XG5cbi8qKiBAcmV0dXJucyB7bnVtYmVyfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvX251bWJlcih2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUgPT09ICcnID8gbnVsbCA6ICt2YWx1ZTtcbn1cblxuLyoqIEByZXR1cm5zIHthbnlbXX0gKi9cbmV4cG9ydCBmdW5jdGlvbiB0aW1lX3Jhbmdlc190b19hcnJheShyYW5nZXMpIHtcblx0Y29uc3QgYXJyYXkgPSBbXTtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRhcnJheS5wdXNoKHsgc3RhcnQ6IHJhbmdlcy5zdGFydChpKSwgZW5kOiByYW5nZXMuZW5kKGkpIH0pO1xuXHR9XG5cdHJldHVybiBhcnJheTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtDaGlsZE5vZGVbXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoaWxkcmVuKGVsZW1lbnQpIHtcblx0cmV0dXJuIEFycmF5LmZyb20oZWxlbWVudC5jaGlsZE5vZGVzKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NoaWxkTm9kZUFycmF5fSBub2Rlc1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIGluaXRfY2xhaW1faW5mbyhub2Rlcykge1xuXHRpZiAobm9kZXMuY2xhaW1faW5mbyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0bm9kZXMuY2xhaW1faW5mbyA9IHsgbGFzdF9pbmRleDogMCwgdG90YWxfY2xhaW1lZDogMCB9O1xuXHR9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIHtDaGlsZE5vZGVFeH0gUlxuICogQHBhcmFtIHtDaGlsZE5vZGVBcnJheX0gbm9kZXNcbiAqIEBwYXJhbSB7KG5vZGU6IENoaWxkTm9kZUV4KSA9PiBub2RlIGlzIFJ9IHByZWRpY2F0ZVxuICogQHBhcmFtIHsobm9kZTogQ2hpbGROb2RlRXgpID0+IENoaWxkTm9kZUV4IHwgdW5kZWZpbmVkfSBwcm9jZXNzX25vZGVcbiAqIEBwYXJhbSB7KCkgPT4gUn0gY3JlYXRlX25vZGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZG9udF91cGRhdGVfbGFzdF9pbmRleFxuICogQHJldHVybnMge1J9XG4gKi9cbmZ1bmN0aW9uIGNsYWltX25vZGUobm9kZXMsIHByZWRpY2F0ZSwgcHJvY2Vzc19ub2RlLCBjcmVhdGVfbm9kZSwgZG9udF91cGRhdGVfbGFzdF9pbmRleCA9IGZhbHNlKSB7XG5cdC8vIFRyeSB0byBmaW5kIG5vZGVzIGluIGFuIG9yZGVyIHN1Y2ggdGhhdCB3ZSBsZW5ndGhlbiB0aGUgbG9uZ2VzdCBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlXG5cdGluaXRfY2xhaW1faW5mbyhub2Rlcyk7XG5cdGNvbnN0IHJlc3VsdF9ub2RlID0gKCgpID0+IHtcblx0XHQvLyBXZSBmaXJzdCB0cnkgdG8gZmluZCBhbiBlbGVtZW50IGFmdGVyIHRoZSBwcmV2aW91cyBvbmVcblx0XHRmb3IgKGxldCBpID0gbm9kZXMuY2xhaW1faW5mby5sYXN0X2luZGV4OyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcblx0XHRcdGlmIChwcmVkaWNhdGUobm9kZSkpIHtcblx0XHRcdFx0Y29uc3QgcmVwbGFjZW1lbnQgPSBwcm9jZXNzX25vZGUobm9kZSk7XG5cdFx0XHRcdGlmIChyZXBsYWNlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0bm9kZXMuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG5vZGVzW2ldID0gcmVwbGFjZW1lbnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFkb250X3VwZGF0ZV9sYXN0X2luZGV4KSB7XG5cdFx0XHRcdFx0bm9kZXMuY2xhaW1faW5mby5sYXN0X2luZGV4ID0gaTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbm9kZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gT3RoZXJ3aXNlLCB3ZSB0cnkgdG8gZmluZCBvbmUgYmVmb3JlXG5cdFx0Ly8gV2UgaXRlcmF0ZSBpbiByZXZlcnNlIHNvIHRoYXQgd2UgZG9uJ3QgZ28gdG9vIGZhciBiYWNrXG5cdFx0Zm9yIChsZXQgaSA9IG5vZGVzLmNsYWltX2luZm8ubGFzdF9pbmRleCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRjb25zdCBub2RlID0gbm9kZXNbaV07XG5cdFx0XHRpZiAocHJlZGljYXRlKG5vZGUpKSB7XG5cdFx0XHRcdGNvbnN0IHJlcGxhY2VtZW50ID0gcHJvY2Vzc19ub2RlKG5vZGUpO1xuXHRcdFx0XHRpZiAocmVwbGFjZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdG5vZGVzLnNwbGljZShpLCAxKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRub2Rlc1tpXSA9IHJlcGxhY2VtZW50O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghZG9udF91cGRhdGVfbGFzdF9pbmRleCkge1xuXHRcdFx0XHRcdG5vZGVzLmNsYWltX2luZm8ubGFzdF9pbmRleCA9IGk7XG5cdFx0XHRcdH0gZWxzZSBpZiAocmVwbGFjZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdC8vIFNpbmNlIHdlIHNwbGljZWQgYmVmb3JlIHRoZSBsYXN0X2luZGV4LCB3ZSBkZWNyZWFzZSBpdFxuXHRcdFx0XHRcdG5vZGVzLmNsYWltX2luZm8ubGFzdF9pbmRleC0tO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBub2RlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBJZiB3ZSBjYW4ndCBmaW5kIGFueSBtYXRjaGluZyBub2RlLCB3ZSBjcmVhdGUgYSBuZXcgb25lXG5cdFx0cmV0dXJuIGNyZWF0ZV9ub2RlKCk7XG5cdH0pKCk7XG5cdHJlc3VsdF9ub2RlLmNsYWltX29yZGVyID0gbm9kZXMuY2xhaW1faW5mby50b3RhbF9jbGFpbWVkO1xuXHRub2Rlcy5jbGFpbV9pbmZvLnRvdGFsX2NsYWltZWQgKz0gMTtcblx0cmV0dXJuIHJlc3VsdF9ub2RlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Q2hpbGROb2RlQXJyYXl9IG5vZGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHt7IFtrZXk6IHN0cmluZ106IGJvb2xlYW4gfX0gYXR0cmlidXRlc1xuICogQHBhcmFtIHsobmFtZTogc3RyaW5nKSA9PiBFbGVtZW50IHwgU1ZHRWxlbWVudH0gY3JlYXRlX2VsZW1lbnRcbiAqIEByZXR1cm5zIHtFbGVtZW50IHwgU1ZHRWxlbWVudH1cbiAqL1xuZnVuY3Rpb24gY2xhaW1fZWxlbWVudF9iYXNlKG5vZGVzLCBuYW1lLCBhdHRyaWJ1dGVzLCBjcmVhdGVfZWxlbWVudCkge1xuXHRyZXR1cm4gY2xhaW1fbm9kZShcblx0XHRub2Rlcyxcblx0XHQvKiogQHJldHVybnMge25vZGUgaXMgRWxlbWVudCB8IFNWR0VsZW1lbnR9ICovXG5cdFx0KG5vZGUpID0+IG5vZGUubm9kZU5hbWUgPT09IG5hbWUsXG5cdFx0LyoqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSAqL1xuXHRcdChub2RlKSA9PiB7XG5cdFx0XHRjb25zdCByZW1vdmUgPSBbXTtcblx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgbm9kZS5hdHRyaWJ1dGVzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGNvbnN0IGF0dHJpYnV0ZSA9IG5vZGUuYXR0cmlidXRlc1tqXTtcblx0XHRcdFx0aWYgKCFhdHRyaWJ1dGVzW2F0dHJpYnV0ZS5uYW1lXSkge1xuXHRcdFx0XHRcdHJlbW92ZS5wdXNoKGF0dHJpYnV0ZS5uYW1lKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmVtb3ZlLmZvckVhY2goKHYpID0+IG5vZGUucmVtb3ZlQXR0cmlidXRlKHYpKTtcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0fSxcblx0XHQoKSA9PiBjcmVhdGVfZWxlbWVudChuYW1lKVxuXHQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Q2hpbGROb2RlQXJyYXl9IG5vZGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHt7IFtrZXk6IHN0cmluZ106IGJvb2xlYW4gfX0gYXR0cmlidXRlc1xuICogQHJldHVybnMge0VsZW1lbnQgfCBTVkdFbGVtZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xhaW1fZWxlbWVudChub2RlcywgbmFtZSwgYXR0cmlidXRlcykge1xuXHRyZXR1cm4gY2xhaW1fZWxlbWVudF9iYXNlKG5vZGVzLCBuYW1lLCBhdHRyaWJ1dGVzLCBlbGVtZW50KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NoaWxkTm9kZUFycmF5fSBub2Rlc1xuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7eyBba2V5OiBzdHJpbmddOiBib29sZWFuIH19IGF0dHJpYnV0ZXNcbiAqIEByZXR1cm5zIHtFbGVtZW50IHwgU1ZHRWxlbWVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsYWltX3N2Z19lbGVtZW50KG5vZGVzLCBuYW1lLCBhdHRyaWJ1dGVzKSB7XG5cdHJldHVybiBjbGFpbV9lbGVtZW50X2Jhc2Uobm9kZXMsIG5hbWUsIGF0dHJpYnV0ZXMsIHN2Z19lbGVtZW50KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NoaWxkTm9kZUFycmF5fSBub2Rlc1xuICogQHJldHVybnMge1RleHR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGFpbV90ZXh0KG5vZGVzLCBkYXRhKSB7XG5cdHJldHVybiBjbGFpbV9ub2RlKFxuXHRcdG5vZGVzLFxuXHRcdC8qKiBAcmV0dXJucyB7bm9kZSBpcyBUZXh0fSAqL1xuXHRcdChub2RlKSA9PiBub2RlLm5vZGVUeXBlID09PSAzLFxuXHRcdC8qKiBAcGFyYW0ge1RleHR9IG5vZGUgKi9cblx0XHQobm9kZSkgPT4ge1xuXHRcdFx0Y29uc3QgZGF0YV9zdHIgPSAnJyArIGRhdGE7XG5cdFx0XHRpZiAobm9kZS5kYXRhLnN0YXJ0c1dpdGgoZGF0YV9zdHIpKSB7XG5cdFx0XHRcdGlmIChub2RlLmRhdGEubGVuZ3RoICE9PSBkYXRhX3N0ci5sZW5ndGgpIHtcblx0XHRcdFx0XHRyZXR1cm4gbm9kZS5zcGxpdFRleHQoZGF0YV9zdHIubGVuZ3RoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bm9kZS5kYXRhID0gZGF0YV9zdHI7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQoKSA9PiB0ZXh0KGRhdGEpLFxuXHRcdHRydWUgLy8gVGV4dCBub2RlcyBzaG91bGQgbm90IHVwZGF0ZSBsYXN0IGluZGV4IHNpbmNlIGl0IGlzIGxpa2VseSBub3Qgd29ydGggaXQgdG8gZWxpbWluYXRlIGFuIGluY3JlYXNpbmcgc3Vic2VxdWVuY2Ugb2YgYWN0dWFsIGVsZW1lbnRzXG5cdCk7XG59XG5cbi8qKlxuICogQHJldHVybnMge1RleHR9ICovXG5leHBvcnQgZnVuY3Rpb24gY2xhaW1fc3BhY2Uobm9kZXMpIHtcblx0cmV0dXJuIGNsYWltX3RleHQobm9kZXMsICcgJyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtDaGlsZE5vZGVBcnJheX0gbm9kZXNcbiAqIEByZXR1cm5zIHtDb21tZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xhaW1fY29tbWVudChub2RlcywgZGF0YSkge1xuXHRyZXR1cm4gY2xhaW1fbm9kZShcblx0XHRub2Rlcyxcblx0XHQvKiogQHJldHVybnMge25vZGUgaXMgQ29tbWVudH0gKi9cblx0XHQobm9kZSkgPT4gbm9kZS5ub2RlVHlwZSA9PT0gOCxcblx0XHQvKiogQHBhcmFtIHtDb21tZW50fSBub2RlICovXG5cdFx0KG5vZGUpID0+IHtcblx0XHRcdG5vZGUuZGF0YSA9ICcnICsgZGF0YTtcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0fSxcblx0XHQoKSA9PiBjb21tZW50KGRhdGEpLFxuXHRcdHRydWVcblx0KTtcbn1cblxuZnVuY3Rpb24gZ2V0X2NvbW1lbnRfaWR4KG5vZGVzLCB0ZXh0LCBzdGFydCkge1xuXHRmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBub2Rlcy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcblx0XHRpZiAobm9kZS5ub2RlVHlwZSA9PT0gOCAvKiBjb21tZW50IG5vZGUgKi8gJiYgbm9kZS50ZXh0Q29udGVudC50cmltKCkgPT09IHRleHQpIHtcblx0XHRcdHJldHVybiBpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gLTE7XG59XG5cbi8qKlxuICogQHBhcmFtIHtib29sZWFufSBpc19zdmdcbiAqIEByZXR1cm5zIHtIdG1sVGFnSHlkcmF0aW9ufVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xhaW1faHRtbF90YWcobm9kZXMsIGlzX3N2Zykge1xuXHQvLyBmaW5kIGh0bWwgb3BlbmluZyB0YWdcblx0Y29uc3Qgc3RhcnRfaW5kZXggPSBnZXRfY29tbWVudF9pZHgobm9kZXMsICdIVE1MX1RBR19TVEFSVCcsIDApO1xuXHRjb25zdCBlbmRfaW5kZXggPSBnZXRfY29tbWVudF9pZHgobm9kZXMsICdIVE1MX1RBR19FTkQnLCBzdGFydF9pbmRleCArIDEpO1xuXHRpZiAoc3RhcnRfaW5kZXggPT09IC0xIHx8IGVuZF9pbmRleCA9PT0gLTEpIHtcblx0XHRyZXR1cm4gbmV3IEh0bWxUYWdIeWRyYXRpb24oaXNfc3ZnKTtcblx0fVxuXG5cdGluaXRfY2xhaW1faW5mbyhub2Rlcyk7XG5cdGNvbnN0IGh0bWxfdGFnX25vZGVzID0gbm9kZXMuc3BsaWNlKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDEpO1xuXHRkZXRhY2goaHRtbF90YWdfbm9kZXNbMF0pO1xuXHRkZXRhY2goaHRtbF90YWdfbm9kZXNbaHRtbF90YWdfbm9kZXMubGVuZ3RoIC0gMV0pO1xuXHRjb25zdCBjbGFpbWVkX25vZGVzID0gaHRtbF90YWdfbm9kZXMuc2xpY2UoMSwgaHRtbF90YWdfbm9kZXMubGVuZ3RoIC0gMSk7XG5cdGlmIChjbGFpbWVkX25vZGVzLmxlbmd0aCA9PT0gMCkge1xuXHRcdHJldHVybiBuZXcgSHRtbFRhZ0h5ZHJhdGlvbihpc19zdmcpO1xuXHR9XG5cdGZvciAoY29uc3QgbiBvZiBjbGFpbWVkX25vZGVzKSB7XG5cdFx0bi5jbGFpbV9vcmRlciA9IG5vZGVzLmNsYWltX2luZm8udG90YWxfY2xhaW1lZDtcblx0XHRub2Rlcy5jbGFpbV9pbmZvLnRvdGFsX2NsYWltZWQgKz0gMTtcblx0fVxuXHRyZXR1cm4gbmV3IEh0bWxUYWdIeWRyYXRpb24oaXNfc3ZnLCBjbGFpbWVkX25vZGVzKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RleHR9IHRleHRcbiAqIEBwYXJhbSB7dW5rbm93bn0gZGF0YVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfZGF0YSh0ZXh0LCBkYXRhKSB7XG5cdGRhdGEgPSAnJyArIGRhdGE7XG5cdGlmICh0ZXh0LmRhdGEgPT09IGRhdGEpIHJldHVybjtcblx0dGV4dC5kYXRhID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovIChkYXRhKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RleHR9IHRleHRcbiAqIEBwYXJhbSB7dW5rbm93bn0gZGF0YVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfZGF0YV9jb250ZW50ZWRpdGFibGUodGV4dCwgZGF0YSkge1xuXHRkYXRhID0gJycgKyBkYXRhO1xuXHRpZiAodGV4dC53aG9sZVRleHQgPT09IGRhdGEpIHJldHVybjtcblx0dGV4dC5kYXRhID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovIChkYXRhKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RleHR9IHRleHRcbiAqIEBwYXJhbSB7dW5rbm93bn0gZGF0YVxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJfdmFsdWVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2RhdGFfbWF5YmVfY29udGVudGVkaXRhYmxlKHRleHQsIGRhdGEsIGF0dHJfdmFsdWUpIHtcblx0aWYgKH5jb250ZW50ZWRpdGFibGVfdHJ1dGh5X3ZhbHVlcy5pbmRleE9mKGF0dHJfdmFsdWUpKSB7XG5cdFx0c2V0X2RhdGFfY29udGVudGVkaXRhYmxlKHRleHQsIGRhdGEpO1xuXHR9IGVsc2Uge1xuXHRcdHNldF9kYXRhKHRleHQsIGRhdGEpO1xuXHR9XG59XG5cbi8qKlxuICogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2lucHV0X3ZhbHVlKGlucHV0LCB2YWx1ZSkge1xuXHRpbnB1dC52YWx1ZSA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9pbnB1dF90eXBlKGlucHV0LCB0eXBlKSB7XG5cdHRyeSB7XG5cdFx0aW5wdXQudHlwZSA9IHR5cGU7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBkbyBub3RoaW5nXG5cdH1cbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfc3R5bGUobm9kZSwga2V5LCB2YWx1ZSwgaW1wb3J0YW50KSB7XG5cdGlmICh2YWx1ZSA9PSBudWxsKSB7XG5cdFx0bm9kZS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShrZXkpO1xuXHR9IGVsc2Uge1xuXHRcdG5vZGUuc3R5bGUuc2V0UHJvcGVydHkoa2V5LCB2YWx1ZSwgaW1wb3J0YW50ID8gJ2ltcG9ydGFudCcgOiAnJyk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZWxlY3Rfb3B0aW9uKHNlbGVjdCwgdmFsdWUsIG1vdW50aW5nKSB7XG5cdGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZWN0Lm9wdGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRjb25zdCBvcHRpb24gPSBzZWxlY3Qub3B0aW9uc1tpXTtcblx0XHRpZiAob3B0aW9uLl9fdmFsdWUgPT09IHZhbHVlKSB7XG5cdFx0XHRvcHRpb24uc2VsZWN0ZWQgPSB0cnVlO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0fVxuXHRpZiAoIW1vdW50aW5nIHx8IHZhbHVlICE9PSB1bmRlZmluZWQpIHtcblx0XHRzZWxlY3Quc2VsZWN0ZWRJbmRleCA9IC0xOyAvLyBubyBvcHRpb24gc2hvdWxkIGJlIHNlbGVjdGVkXG5cdH1cbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZWxlY3Rfb3B0aW9ucyhzZWxlY3QsIHZhbHVlKSB7XG5cdGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZWN0Lm9wdGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRjb25zdCBvcHRpb24gPSBzZWxlY3Qub3B0aW9uc1tpXTtcblx0XHRvcHRpb24uc2VsZWN0ZWQgPSB+dmFsdWUuaW5kZXhPZihvcHRpb24uX192YWx1ZSk7XG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdF92YWx1ZShzZWxlY3QpIHtcblx0Y29uc3Qgc2VsZWN0ZWRfb3B0aW9uID0gc2VsZWN0LnF1ZXJ5U2VsZWN0b3IoJzpjaGVja2VkJyk7XG5cdHJldHVybiBzZWxlY3RlZF9vcHRpb24gJiYgc2VsZWN0ZWRfb3B0aW9uLl9fdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZWxlY3RfbXVsdGlwbGVfdmFsdWUoc2VsZWN0KSB7XG5cdHJldHVybiBbXS5tYXAuY2FsbChzZWxlY3QucXVlcnlTZWxlY3RvckFsbCgnOmNoZWNrZWQnKSwgKG9wdGlvbikgPT4gb3B0aW9uLl9fdmFsdWUpO1xufVxuLy8gdW5mb3J0dW5hdGVseSB0aGlzIGNhbid0IGJlIGEgY29uc3RhbnQgYXMgdGhhdCB3b3VsZG4ndCBiZSB0cmVlLXNoYWtlYWJsZVxuLy8gc28gd2UgY2FjaGUgdGhlIHJlc3VsdCBpbnN0ZWFkXG5cbi8qKlxuICogQHR5cGUge2Jvb2xlYW59ICovXG5sZXQgY3Jvc3NvcmlnaW47XG5cbi8qKlxuICogQHJldHVybnMge2Jvb2xlYW59ICovXG5leHBvcnQgZnVuY3Rpb24gaXNfY3Jvc3NvcmlnaW4oKSB7XG5cdGlmIChjcm9zc29yaWdpbiA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0Y3Jvc3NvcmlnaW4gPSBmYWxzZTtcblx0XHR0cnkge1xuXHRcdFx0aWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wYXJlbnQpIHtcblx0XHRcdFx0dm9pZCB3aW5kb3cucGFyZW50LmRvY3VtZW50O1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjcm9zc29yaWdpbiA9IHRydWU7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBjcm9zc29yaWdpbjtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IGZuXG4gKiBAcmV0dXJucyB7KCkgPT4gdm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZF9pZnJhbWVfcmVzaXplX2xpc3RlbmVyKG5vZGUsIGZuKSB7XG5cdGNvbnN0IGNvbXB1dGVkX3N0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcblx0aWYgKGNvbXB1dGVkX3N0eWxlLnBvc2l0aW9uID09PSAnc3RhdGljJykge1xuXHRcdG5vZGUuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuXHR9XG5cdGNvbnN0IGlmcmFtZSA9IGVsZW1lbnQoJ2lmcmFtZScpO1xuXHRpZnJhbWUuc2V0QXR0cmlidXRlKFxuXHRcdCdzdHlsZScsXG5cdFx0J2Rpc3BsYXk6IGJsb2NrOyBwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogMDsgbGVmdDogMDsgd2lkdGg6IDEwMCU7IGhlaWdodDogMTAwJTsgJyArXG5cdFx0XHQnb3ZlcmZsb3c6IGhpZGRlbjsgYm9yZGVyOiAwOyBvcGFjaXR5OiAwOyBwb2ludGVyLWV2ZW50czogbm9uZTsgei1pbmRleDogLTE7J1xuXHQpO1xuXHRpZnJhbWUuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG5cdGlmcmFtZS50YWJJbmRleCA9IC0xO1xuXHRjb25zdCBjcm9zc29yaWdpbiA9IGlzX2Nyb3Nzb3JpZ2luKCk7XG5cblx0LyoqXG5cdCAqIEB0eXBlIHsoKSA9PiB2b2lkfVxuXHQgKi9cblx0bGV0IHVuc3Vic2NyaWJlO1xuXHRpZiAoY3Jvc3NvcmlnaW4pIHtcblx0XHRpZnJhbWUuc3JjID0gXCJkYXRhOnRleHQvaHRtbCw8c2NyaXB0Pm9ucmVzaXplPWZ1bmN0aW9uKCl7cGFyZW50LnBvc3RNZXNzYWdlKDAsJyonKX08L3NjcmlwdD5cIjtcblx0XHR1bnN1YnNjcmliZSA9IGxpc3Rlbihcblx0XHRcdHdpbmRvdyxcblx0XHRcdCdtZXNzYWdlJyxcblx0XHRcdC8qKiBAcGFyYW0ge01lc3NhZ2VFdmVudH0gZXZlbnQgKi8gKGV2ZW50KSA9PiB7XG5cdFx0XHRcdGlmIChldmVudC5zb3VyY2UgPT09IGlmcmFtZS5jb250ZW50V2luZG93KSBmbigpO1xuXHRcdFx0fVxuXHRcdCk7XG5cdH0gZWxzZSB7XG5cdFx0aWZyYW1lLnNyYyA9ICdhYm91dDpibGFuayc7XG5cdFx0aWZyYW1lLm9ubG9hZCA9ICgpID0+IHtcblx0XHRcdHVuc3Vic2NyaWJlID0gbGlzdGVuKGlmcmFtZS5jb250ZW50V2luZG93LCAncmVzaXplJywgZm4pO1xuXHRcdFx0Ly8gbWFrZSBzdXJlIGFuIGluaXRpYWwgcmVzaXplIGV2ZW50IGlzIGZpcmVkIF9hZnRlcl8gdGhlIGlmcmFtZSBpcyBsb2FkZWQgKHdoaWNoIGlzIGFzeW5jaHJvbm91cylcblx0XHRcdC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vc3ZlbHRlanMvc3ZlbHRlL2lzc3Vlcy80MjMzXG5cdFx0XHRmbigpO1xuXHRcdH07XG5cdH1cblx0YXBwZW5kKG5vZGUsIGlmcmFtZSk7XG5cdHJldHVybiAoKSA9PiB7XG5cdFx0aWYgKGNyb3Nzb3JpZ2luKSB7XG5cdFx0XHR1bnN1YnNjcmliZSgpO1xuXHRcdH0gZWxzZSBpZiAodW5zdWJzY3JpYmUgJiYgaWZyYW1lLmNvbnRlbnRXaW5kb3cpIHtcblx0XHRcdHVuc3Vic2NyaWJlKCk7XG5cdFx0fVxuXHRcdGRldGFjaChpZnJhbWUpO1xuXHR9O1xufVxuZXhwb3J0IGNvbnN0IHJlc2l6ZV9vYnNlcnZlcl9jb250ZW50X2JveCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgUmVzaXplT2JzZXJ2ZXJTaW5nbGV0b24oe1xuXHRib3g6ICdjb250ZW50LWJveCdcbn0pO1xuZXhwb3J0IGNvbnN0IHJlc2l6ZV9vYnNlcnZlcl9ib3JkZXJfYm94ID0gLyogQF9fUFVSRV9fICovIG5ldyBSZXNpemVPYnNlcnZlclNpbmdsZXRvbih7XG5cdGJveDogJ2JvcmRlci1ib3gnXG59KTtcbmV4cG9ydCBjb25zdCByZXNpemVfb2JzZXJ2ZXJfZGV2aWNlX3BpeGVsX2NvbnRlbnRfYm94ID0gLyogQF9fUFVSRV9fICovIG5ldyBSZXNpemVPYnNlcnZlclNpbmdsZXRvbihcblx0eyBib3g6ICdkZXZpY2UtcGl4ZWwtY29udGVudC1ib3gnIH1cbik7XG5leHBvcnQgeyBSZXNpemVPYnNlcnZlclNpbmdsZXRvbiB9O1xuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvZ2dsZV9jbGFzcyhlbGVtZW50LCBuYW1lLCB0b2dnbGUpIHtcblx0Ly8gVGhlIGAhIWAgaXMgcmVxdWlyZWQgYmVjYXVzZSBhbiBgdW5kZWZpbmVkYCBmbGFnIG1lYW5zIGZsaXBwaW5nIHRoZSBjdXJyZW50IHN0YXRlLlxuXHRlbGVtZW50LmNsYXNzTGlzdC50b2dnbGUobmFtZSwgISF0b2dnbGUpO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtUfSBbZGV0YWlsXVxuICogQHBhcmFtIHt7IGJ1YmJsZXM/OiBib29sZWFuLCBjYW5jZWxhYmxlPzogYm9vbGVhbiB9fSBbb3B0aW9uc11cbiAqIEByZXR1cm5zIHtDdXN0b21FdmVudDxUPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGN1c3RvbV9ldmVudCh0eXBlLCBkZXRhaWwsIHsgYnViYmxlcyA9IGZhbHNlLCBjYW5jZWxhYmxlID0gZmFsc2UgfSA9IHt9KSB7XG5cdHJldHVybiBuZXcgQ3VzdG9tRXZlbnQodHlwZSwgeyBkZXRhaWwsIGJ1YmJsZXMsIGNhbmNlbGFibGUgfSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRcbiAqIEByZXR1cm5zIHtDaGlsZE5vZGVBcnJheX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1ZXJ5X3NlbGVjdG9yX2FsbChzZWxlY3RvciwgcGFyZW50ID0gZG9jdW1lbnQuYm9keSkge1xuXHRyZXR1cm4gQXJyYXkuZnJvbShwYXJlbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBub2RlSWRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGhlYWRcbiAqIEByZXR1cm5zIHthbnlbXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhlYWRfc2VsZWN0b3Iobm9kZUlkLCBoZWFkKSB7XG5cdGNvbnN0IHJlc3VsdCA9IFtdO1xuXHRsZXQgc3RhcnRlZCA9IDA7XG5cdGZvciAoY29uc3Qgbm9kZSBvZiBoZWFkLmNoaWxkTm9kZXMpIHtcblx0XHRpZiAobm9kZS5ub2RlVHlwZSA9PT0gOCAvKiBjb21tZW50IG5vZGUgKi8pIHtcblx0XHRcdGNvbnN0IGNvbW1lbnQgPSBub2RlLnRleHRDb250ZW50LnRyaW0oKTtcblx0XHRcdGlmIChjb21tZW50ID09PSBgSEVBRF8ke25vZGVJZH1fRU5EYCkge1xuXHRcdFx0XHRzdGFydGVkIC09IDE7XG5cdFx0XHRcdHJlc3VsdC5wdXNoKG5vZGUpO1xuXHRcdFx0fSBlbHNlIGlmIChjb21tZW50ID09PSBgSEVBRF8ke25vZGVJZH1fU1RBUlRgKSB7XG5cdFx0XHRcdHN0YXJ0ZWQgKz0gMTtcblx0XHRcdFx0cmVzdWx0LnB1c2gobm9kZSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChzdGFydGVkID4gMCkge1xuXHRcdFx0cmVzdWx0LnB1c2gobm9kZSk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiByZXN1bHQ7XG59XG4vKiogKi9cbmV4cG9ydCBjbGFzcyBIdG1sVGFnIHtcblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBkZWZhdWx0IGZhbHNlXG5cdCAqL1xuXHRpc19zdmcgPSBmYWxzZTtcblx0LyoqIHBhcmVudCBmb3IgY3JlYXRpbmcgbm9kZSAqL1xuXHRlID0gdW5kZWZpbmVkO1xuXHQvKiogaHRtbCB0YWcgbm9kZXMgKi9cblx0biA9IHVuZGVmaW5lZDtcblx0LyoqIHRhcmdldCAqL1xuXHR0ID0gdW5kZWZpbmVkO1xuXHQvKiogYW5jaG9yICovXG5cdGEgPSB1bmRlZmluZWQ7XG5cdGNvbnN0cnVjdG9yKGlzX3N2ZyA9IGZhbHNlKSB7XG5cdFx0dGhpcy5pc19zdmcgPSBpc19zdmc7XG5cdFx0dGhpcy5lID0gdGhpcy5uID0gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdGMoaHRtbCkge1xuXHRcdHRoaXMuaChodG1sKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50IHwgU1ZHRWxlbWVudH0gdGFyZ2V0XG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50fSBhbmNob3Jcblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRtKGh0bWwsIHRhcmdldCwgYW5jaG9yID0gbnVsbCkge1xuXHRcdGlmICghdGhpcy5lKSB7XG5cdFx0XHRpZiAodGhpcy5pc19zdmcpXG5cdFx0XHRcdHRoaXMuZSA9IHN2Z19lbGVtZW50KC8qKiBAdHlwZSB7a2V5b2YgU1ZHRWxlbWVudFRhZ05hbWVNYXB9ICovICh0YXJnZXQubm9kZU5hbWUpKTtcblx0XHRcdC8qKiAjNzM2NCAgdGFyZ2V0IGZvciA8dGVtcGxhdGU+IG1heSBiZSBwcm92aWRlZCBhcyAjZG9jdW1lbnQtZnJhZ21lbnQoMTEpICovIGVsc2Vcblx0XHRcdFx0dGhpcy5lID0gZWxlbWVudChcblx0XHRcdFx0XHQvKiogQHR5cGUge2tleW9mIEhUTUxFbGVtZW50VGFnTmFtZU1hcH0gKi8gKFxuXHRcdFx0XHRcdFx0dGFyZ2V0Lm5vZGVUeXBlID09PSAxMSA/ICdURU1QTEFURScgOiB0YXJnZXQubm9kZU5hbWVcblx0XHRcdFx0XHQpXG5cdFx0XHRcdCk7XG5cdFx0XHR0aGlzLnQgPVxuXHRcdFx0XHR0YXJnZXQudGFnTmFtZSAhPT0gJ1RFTVBMQVRFJ1xuXHRcdFx0XHRcdD8gdGFyZ2V0XG5cdFx0XHRcdFx0OiAvKiogQHR5cGUge0hUTUxUZW1wbGF0ZUVsZW1lbnR9ICovICh0YXJnZXQpLmNvbnRlbnQ7XG5cdFx0XHR0aGlzLmMoaHRtbCk7XG5cdFx0fVxuXHRcdHRoaXMuaShhbmNob3IpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0aChodG1sKSB7XG5cdFx0dGhpcy5lLmlubmVySFRNTCA9IGh0bWw7XG5cdFx0dGhpcy5uID0gQXJyYXkuZnJvbShcblx0XHRcdHRoaXMuZS5ub2RlTmFtZSA9PT0gJ1RFTVBMQVRFJyA/IHRoaXMuZS5jb250ZW50LmNoaWxkTm9kZXMgOiB0aGlzLmUuY2hpbGROb2Rlc1xuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge3ZvaWR9ICovXG5cdGkoYW5jaG9yKSB7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm4ubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRcdGluc2VydCh0aGlzLnQsIHRoaXMubltpXSwgYW5jaG9yKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRwKGh0bWwpIHtcblx0XHR0aGlzLmQoKTtcblx0XHR0aGlzLmgoaHRtbCk7XG5cdFx0dGhpcy5pKHRoaXMuYSk7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge3ZvaWR9ICovXG5cdGQoKSB7XG5cdFx0dGhpcy5uLmZvckVhY2goZGV0YWNoKTtcblx0fVxufVxuXG5leHBvcnQgY2xhc3MgSHRtbFRhZ0h5ZHJhdGlvbiBleHRlbmRzIEh0bWxUYWcge1xuXHQvKiogQHR5cGUge0VsZW1lbnRbXX0gaHlkcmF0aW9uIGNsYWltZWQgbm9kZXMgKi9cblx0bCA9IHVuZGVmaW5lZDtcblxuXHRjb25zdHJ1Y3Rvcihpc19zdmcgPSBmYWxzZSwgY2xhaW1lZF9ub2Rlcykge1xuXHRcdHN1cGVyKGlzX3N2Zyk7XG5cdFx0dGhpcy5lID0gdGhpcy5uID0gbnVsbDtcblx0XHR0aGlzLmwgPSBjbGFpbWVkX25vZGVzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0YyhodG1sKSB7XG5cdFx0aWYgKHRoaXMubCkge1xuXHRcdFx0dGhpcy5uID0gdGhpcy5sO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdXBlci5jKGh0bWwpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7dm9pZH0gKi9cblx0aShhbmNob3IpIHtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubi5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdFx0aW5zZXJ0X2h5ZHJhdGlvbih0aGlzLnQsIHRoaXMubltpXSwgYW5jaG9yKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge05hbWVkTm9kZU1hcH0gYXR0cmlidXRlc1xuICogQHJldHVybnMge3t9fVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXR0cmlidXRlX3RvX29iamVjdChhdHRyaWJ1dGVzKSB7XG5cdGNvbnN0IHJlc3VsdCA9IHt9O1xuXHRmb3IgKGNvbnN0IGF0dHJpYnV0ZSBvZiBhdHRyaWJ1dGVzKSB7XG5cdFx0cmVzdWx0W2F0dHJpYnV0ZS5uYW1lXSA9IGF0dHJpYnV0ZS52YWx1ZTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG5jb25zdCBlc2NhcGVkID0ge1xuXHQnXCInOiAnJnF1b3Q7Jyxcblx0JyYnOiAnJmFtcDsnLFxuXHQnPCc6ICcmbHQ7J1xufTtcblxuY29uc3QgcmVnZXhfYXR0cmlidXRlX2NoYXJhY3RlcnNfdG9fZXNjYXBlID0gL1tcIiY8XS9nO1xuXG4vKipcbiAqIE5vdGUgdGhhdCB0aGUgYXR0cmlidXRlIGl0c2VsZiBzaG91bGQgYmUgc3Vycm91bmRlZCBpbiBkb3VibGUgcXVvdGVzXG4gKiBAcGFyYW0ge2FueX0gYXR0cmlidXRlXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZV9hdHRyaWJ1dGUoYXR0cmlidXRlKSB7XG5cdHJldHVybiBTdHJpbmcoYXR0cmlidXRlKS5yZXBsYWNlKHJlZ2V4X2F0dHJpYnV0ZV9jaGFyYWN0ZXJzX3RvX2VzY2FwZSwgKG1hdGNoKSA9PiBlc2NhcGVkW21hdGNoXSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fSBhdHRyaWJ1dGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnlfc3ByZWFkKGF0dHJpYnV0ZXMpIHtcblx0bGV0IHN0ciA9ICcgJztcblx0Zm9yIChjb25zdCBrZXkgaW4gYXR0cmlidXRlcykge1xuXHRcdGlmIChhdHRyaWJ1dGVzW2tleV0gIT0gbnVsbCkge1xuXHRcdFx0c3RyICs9IGAke2tleX09XCIke2VzY2FwZV9hdHRyaWJ1dGUoYXR0cmlidXRlc1trZXldKX1cIiBgO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBzdHI7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge3t9fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0X2N1c3RvbV9lbGVtZW50c19zbG90cyhlbGVtZW50KSB7XG5cdGNvbnN0IHJlc3VsdCA9IHt9O1xuXHRlbGVtZW50LmNoaWxkTm9kZXMuZm9yRWFjaChcblx0XHQvKiogQHBhcmFtIHtFbGVtZW50fSBub2RlICovIChub2RlKSA9PiB7XG5cdFx0XHRyZXN1bHRbbm9kZS5zbG90IHx8ICdkZWZhdWx0J10gPSB0cnVlO1xuXHRcdH1cblx0KTtcblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnN0cnVjdF9zdmVsdGVfY29tcG9uZW50KGNvbXBvbmVudCwgcHJvcHMpIHtcblx0cmV0dXJuIG5ldyBjb21wb25lbnQocHJvcHMpO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtOb2RlICYge1xuICogXHRjbGFpbV9vcmRlcj86IG51bWJlcjtcbiAqIFx0aHlkcmF0ZV9pbml0PzogdHJ1ZTtcbiAqIFx0YWN0dWFsX2VuZF9jaGlsZD86IE5vZGVFeDtcbiAqIFx0Y2hpbGROb2RlczogTm9kZUxpc3RPZjxOb2RlRXg+O1xuICogfX0gTm9kZUV4XG4gKi9cblxuLyoqIEB0eXBlZGVmIHtDaGlsZE5vZGUgJiBOb2RlRXh9IENoaWxkTm9kZUV4ICovXG5cbi8qKiBAdHlwZWRlZiB7Tm9kZUV4ICYgeyBjbGFpbV9vcmRlcjogbnVtYmVyIH19IE5vZGVFeDIgKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7Q2hpbGROb2RlRXhbXSAmIHtcbiAqIFx0Y2xhaW1faW5mbz86IHtcbiAqIFx0XHRsYXN0X2luZGV4OiBudW1iZXI7XG4gKiBcdFx0dG90YWxfY2xhaW1lZDogbnVtYmVyO1xuICogXHR9O1xuICogfX0gQ2hpbGROb2RlQXJyYXlcbiAqL1xuIiwgImltcG9ydCB7IGN1c3RvbV9ldmVudCB9IGZyb20gJy4vZG9tLmpzJztcblxuZXhwb3J0IGxldCBjdXJyZW50X2NvbXBvbmVudDtcblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9jdXJyZW50X2NvbXBvbmVudChjb21wb25lbnQpIHtcblx0Y3VycmVudF9jb21wb25lbnQgPSBjb21wb25lbnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRfY3VycmVudF9jb21wb25lbnQoKSB7XG5cdGlmICghY3VycmVudF9jb21wb25lbnQpIHRocm93IG5ldyBFcnJvcignRnVuY3Rpb24gY2FsbGVkIG91dHNpZGUgY29tcG9uZW50IGluaXRpYWxpemF0aW9uJyk7XG5cdHJldHVybiBjdXJyZW50X2NvbXBvbmVudDtcbn1cblxuLyoqXG4gKiBTY2hlZHVsZXMgYSBjYWxsYmFjayB0byBydW4gaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgdXBkYXRlZCBhZnRlciBhbnkgc3RhdGUgY2hhbmdlLlxuICpcbiAqIFRoZSBmaXJzdCB0aW1lIHRoZSBjYWxsYmFjayBydW5zIHdpbGwgYmUgYmVmb3JlIHRoZSBpbml0aWFsIGBvbk1vdW50YFxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZSNiZWZvcmV1cGRhdGVcbiAqIEBwYXJhbSB7KCkgPT4gYW55fSBmblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiZWZvcmVVcGRhdGUoZm4pIHtcblx0Z2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuYmVmb3JlX3VwZGF0ZS5wdXNoKGZuKTtcbn1cblxuLyoqXG4gKiBUaGUgYG9uTW91bnRgIGZ1bmN0aW9uIHNjaGVkdWxlcyBhIGNhbGxiYWNrIHRvIHJ1biBhcyBzb29uIGFzIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZCB0byB0aGUgRE9NLlxuICogSXQgbXVzdCBiZSBjYWxsZWQgZHVyaW5nIHRoZSBjb21wb25lbnQncyBpbml0aWFsaXNhdGlvbiAoYnV0IGRvZXNuJ3QgbmVlZCB0byBsaXZlICppbnNpZGUqIHRoZSBjb21wb25lbnQ7XG4gKiBpdCBjYW4gYmUgY2FsbGVkIGZyb20gYW4gZXh0ZXJuYWwgbW9kdWxlKS5cbiAqXG4gKiBJZiBhIGZ1bmN0aW9uIGlzIHJldHVybmVkIF9zeW5jaHJvbm91c2x5XyBmcm9tIGBvbk1vdW50YCwgaXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIHVubW91bnRlZC5cbiAqXG4gKiBgb25Nb3VudGAgZG9lcyBub3QgcnVuIGluc2lkZSBhIFtzZXJ2ZXItc2lkZSBjb21wb25lbnRdKGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzI3J1bi10aW1lLXNlcnZlci1zaWRlLWNvbXBvbmVudC1hcGkpLlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZSNvbm1vdW50XG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHsoKSA9PiBpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLk5vdEZ1bmN0aW9uPFQ+IHwgUHJvbWlzZTxpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLk5vdEZ1bmN0aW9uPFQ+PiB8ICgoKSA9PiBhbnkpfSBmblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvbk1vdW50KGZuKSB7XG5cdGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLm9uX21vdW50LnB1c2goZm4pO1xufVxuXG4vKipcbiAqIFNjaGVkdWxlcyBhIGNhbGxiYWNrIHRvIHJ1biBpbW1lZGlhdGVseSBhZnRlciB0aGUgY29tcG9uZW50IGhhcyBiZWVuIHVwZGF0ZWQuXG4gKlxuICogVGhlIGZpcnN0IHRpbWUgdGhlIGNhbGxiYWNrIHJ1bnMgd2lsbCBiZSBhZnRlciB0aGUgaW5pdGlhbCBgb25Nb3VudGBcbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUjYWZ0ZXJ1cGRhdGVcbiAqIEBwYXJhbSB7KCkgPT4gYW55fSBmblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZnRlclVwZGF0ZShmbikge1xuXHRnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5hZnRlcl91cGRhdGUucHVzaChmbik7XG59XG5cbi8qKlxuICogU2NoZWR1bGVzIGEgY2FsbGJhY2sgdG8gcnVuIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIHVubW91bnRlZC5cbiAqXG4gKiBPdXQgb2YgYG9uTW91bnRgLCBgYmVmb3JlVXBkYXRlYCwgYGFmdGVyVXBkYXRlYCBhbmQgYG9uRGVzdHJveWAsIHRoaXMgaXMgdGhlXG4gKiBvbmx5IG9uZSB0aGF0IHJ1bnMgaW5zaWRlIGEgc2VydmVyLXNpZGUgY29tcG9uZW50LlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZSNvbmRlc3Ryb3lcbiAqIEBwYXJhbSB7KCkgPT4gYW55fSBmblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvbkRlc3Ryb3koZm4pIHtcblx0Z2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQub25fZGVzdHJveS5wdXNoKGZuKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGV2ZW50IGRpc3BhdGNoZXIgdGhhdCBjYW4gYmUgdXNlZCB0byBkaXNwYXRjaCBbY29tcG9uZW50IGV2ZW50c10oaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3MjdGVtcGxhdGUtc3ludGF4LWNvbXBvbmVudC1kaXJlY3RpdmVzLW9uLWV2ZW50bmFtZSkuXG4gKiBFdmVudCBkaXNwYXRjaGVycyBhcmUgZnVuY3Rpb25zIHRoYXQgY2FuIHRha2UgdHdvIGFyZ3VtZW50czogYG5hbWVgIGFuZCBgZGV0YWlsYC5cbiAqXG4gKiBDb21wb25lbnQgZXZlbnRzIGNyZWF0ZWQgd2l0aCBgY3JlYXRlRXZlbnREaXNwYXRjaGVyYCBjcmVhdGUgYVxuICogW0N1c3RvbUV2ZW50XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3VzdG9tRXZlbnQpLlxuICogVGhlc2UgZXZlbnRzIGRvIG5vdCBbYnViYmxlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0xlYXJuL0phdmFTY3JpcHQvQnVpbGRpbmdfYmxvY2tzL0V2ZW50cyNFdmVudF9idWJibGluZ19hbmRfY2FwdHVyZSkuXG4gKiBUaGUgYGRldGFpbGAgYXJndW1lbnQgY29ycmVzcG9uZHMgdG8gdGhlIFtDdXN0b21FdmVudC5kZXRhaWxdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DdXN0b21FdmVudC9kZXRhaWwpXG4gKiBwcm9wZXJ0eSBhbmQgY2FuIGNvbnRhaW4gYW55IHR5cGUgb2YgZGF0YS5cbiAqXG4gKiBUaGUgZXZlbnQgZGlzcGF0Y2hlciBjYW4gYmUgdHlwZWQgdG8gbmFycm93IHRoZSBhbGxvd2VkIGV2ZW50IG5hbWVzIGFuZCB0aGUgdHlwZSBvZiB0aGUgYGRldGFpbGAgYXJndW1lbnQ6XG4gKiBgYGB0c1xuICogY29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXI8e1xuICogIGxvYWRlZDogbmV2ZXI7IC8vIGRvZXMgbm90IHRha2UgYSBkZXRhaWwgYXJndW1lbnRcbiAqICBjaGFuZ2U6IHN0cmluZzsgLy8gdGFrZXMgYSBkZXRhaWwgYXJndW1lbnQgb2YgdHlwZSBzdHJpbmcsIHdoaWNoIGlzIHJlcXVpcmVkXG4gKiAgb3B0aW9uYWw6IG51bWJlciB8IG51bGw7IC8vIHRha2VzIGFuIG9wdGlvbmFsIGRldGFpbCBhcmd1bWVudCBvZiB0eXBlIG51bWJlclxuICogfT4oKTtcbiAqIGBgYFxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZSNjcmVhdGVldmVudGRpc3BhdGNoZXJcbiAqIEB0ZW1wbGF0ZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gW0V2ZW50TWFwPWFueV1cbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vcHVibGljLmpzJykuRXZlbnREaXNwYXRjaGVyPEV2ZW50TWFwPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpIHtcblx0Y29uc3QgY29tcG9uZW50ID0gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCk7XG5cdHJldHVybiAodHlwZSwgZGV0YWlsLCB7IGNhbmNlbGFibGUgPSBmYWxzZSB9ID0ge30pID0+IHtcblx0XHRjb25zdCBjYWxsYmFja3MgPSBjb21wb25lbnQuJCQuY2FsbGJhY2tzW3R5cGVdO1xuXHRcdGlmIChjYWxsYmFja3MpIHtcblx0XHRcdC8vIFRPRE8gYXJlIHRoZXJlIHNpdHVhdGlvbnMgd2hlcmUgZXZlbnRzIGNvdWxkIGJlIGRpc3BhdGNoZWRcblx0XHRcdC8vIGluIGEgc2VydmVyIChub24tRE9NKSBlbnZpcm9ubWVudD9cblx0XHRcdGNvbnN0IGV2ZW50ID0gY3VzdG9tX2V2ZW50KC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAodHlwZSksIGRldGFpbCwgeyBjYW5jZWxhYmxlIH0pO1xuXHRcdFx0Y2FsbGJhY2tzLnNsaWNlKCkuZm9yRWFjaCgoZm4pID0+IHtcblx0XHRcdFx0Zm4uY2FsbChjb21wb25lbnQsIGV2ZW50KTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuICFldmVudC5kZWZhdWx0UHJldmVudGVkO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcbn1cblxuLyoqXG4gKiBBc3NvY2lhdGVzIGFuIGFyYml0cmFyeSBgY29udGV4dGAgb2JqZWN0IHdpdGggdGhlIGN1cnJlbnQgY29tcG9uZW50IGFuZCB0aGUgc3BlY2lmaWVkIGBrZXlgXG4gKiBhbmQgcmV0dXJucyB0aGF0IG9iamVjdC4gVGhlIGNvbnRleHQgaXMgdGhlbiBhdmFpbGFibGUgdG8gY2hpbGRyZW4gb2YgdGhlIGNvbXBvbmVudFxuICogKGluY2x1ZGluZyBzbG90dGVkIGNvbnRlbnQpIHdpdGggYGdldENvbnRleHRgLlxuICpcbiAqIExpa2UgbGlmZWN5Y2xlIGZ1bmN0aW9ucywgdGhpcyBtdXN0IGJlIGNhbGxlZCBkdXJpbmcgY29tcG9uZW50IGluaXRpYWxpc2F0aW9uLlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZSNzZXRjb250ZXh0XG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHthbnl9IGtleVxuICogQHBhcmFtIHtUfSBjb250ZXh0XG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldENvbnRleHQoa2V5LCBjb250ZXh0KSB7XG5cdGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmNvbnRleHQuc2V0KGtleSwgY29udGV4dCk7XG5cdHJldHVybiBjb250ZXh0O1xufVxuXG4vKipcbiAqIFJldHJpZXZlcyB0aGUgY29udGV4dCB0aGF0IGJlbG9uZ3MgdG8gdGhlIGNsb3Nlc3QgcGFyZW50IGNvbXBvbmVudCB3aXRoIHRoZSBzcGVjaWZpZWQgYGtleWAuXG4gKiBNdXN0IGJlIGNhbGxlZCBkdXJpbmcgY29tcG9uZW50IGluaXRpYWxpc2F0aW9uLlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZSNnZXRjb250ZXh0XG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHthbnl9IGtleVxuICogQHJldHVybnMge1R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb250ZXh0KGtleSkge1xuXHRyZXR1cm4gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuY29udGV4dC5nZXQoa2V5KTtcbn1cblxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIHdob2xlIGNvbnRleHQgbWFwIHRoYXQgYmVsb25ncyB0byB0aGUgY2xvc2VzdCBwYXJlbnQgY29tcG9uZW50LlxuICogTXVzdCBiZSBjYWxsZWQgZHVyaW5nIGNvbXBvbmVudCBpbml0aWFsaXNhdGlvbi4gVXNlZnVsLCBmb3IgZXhhbXBsZSwgaWYgeW91XG4gKiBwcm9ncmFtbWF0aWNhbGx5IGNyZWF0ZSBhIGNvbXBvbmVudCBhbmQgd2FudCB0byBwYXNzIHRoZSBleGlzdGluZyBjb250ZXh0IHRvIGl0LlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZSNnZXRhbGxjb250ZXh0c1xuICogQHRlbXBsYXRlIHtNYXA8YW55LCBhbnk+fSBbVD1NYXA8YW55LCBhbnk+XVxuICogQHJldHVybnMge1R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBbGxDb250ZXh0cygpIHtcblx0cmV0dXJuIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmNvbnRleHQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYSBnaXZlbiBga2V5YCBoYXMgYmVlbiBzZXQgaW4gdGhlIGNvbnRleHQgb2YgYSBwYXJlbnQgY29tcG9uZW50LlxuICogTXVzdCBiZSBjYWxsZWQgZHVyaW5nIGNvbXBvbmVudCBpbml0aWFsaXNhdGlvbi5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUjaGFzY29udGV4dFxuICogQHBhcmFtIHthbnl9IGtleVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNDb250ZXh0KGtleSkge1xuXHRyZXR1cm4gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuY29udGV4dC5oYXMoa2V5KTtcbn1cblxuLy8gVE9ETyBmaWd1cmUgb3V0IGlmIHdlIHN0aWxsIHdhbnQgdG8gc3VwcG9ydFxuLy8gc2hvcnRoYW5kIGV2ZW50cywgb3IgaWYgd2Ugd2FudCB0byBpbXBsZW1lbnRcbi8vIGEgcmVhbCBidWJibGluZyBtZWNoYW5pc21cbi8qKlxuICogQHBhcmFtIGNvbXBvbmVudFxuICogQHBhcmFtIGV2ZW50XG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1YmJsZShjb21wb25lbnQsIGV2ZW50KSB7XG5cdGNvbnN0IGNhbGxiYWNrcyA9IGNvbXBvbmVudC4kJC5jYWxsYmFja3NbZXZlbnQudHlwZV07XG5cdGlmIChjYWxsYmFja3MpIHtcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0Y2FsbGJhY2tzLnNsaWNlKCkuZm9yRWFjaCgoZm4pID0+IGZuLmNhbGwodGhpcywgZXZlbnQpKTtcblx0fVxufVxuIiwgImltcG9ydCB7IHJ1bl9hbGwgfSBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7IGN1cnJlbnRfY29tcG9uZW50LCBzZXRfY3VycmVudF9jb21wb25lbnQgfSBmcm9tICcuL2xpZmVjeWNsZS5qcyc7XG5cbmV4cG9ydCBjb25zdCBkaXJ0eV9jb21wb25lbnRzID0gW107XG5leHBvcnQgY29uc3QgaW50cm9zID0geyBlbmFibGVkOiBmYWxzZSB9O1xuZXhwb3J0IGNvbnN0IGJpbmRpbmdfY2FsbGJhY2tzID0gW107XG5cbmxldCByZW5kZXJfY2FsbGJhY2tzID0gW107XG5cbmNvbnN0IGZsdXNoX2NhbGxiYWNrcyA9IFtdO1xuXG5jb25zdCByZXNvbHZlZF9wcm9taXNlID0gLyogQF9fUFVSRV9fICovIFByb21pc2UucmVzb2x2ZSgpO1xuXG5sZXQgdXBkYXRlX3NjaGVkdWxlZCA9IGZhbHNlO1xuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gc2NoZWR1bGVfdXBkYXRlKCkge1xuXHRpZiAoIXVwZGF0ZV9zY2hlZHVsZWQpIHtcblx0XHR1cGRhdGVfc2NoZWR1bGVkID0gdHJ1ZTtcblx0XHRyZXNvbHZlZF9wcm9taXNlLnRoZW4oZmx1c2gpO1xuXHR9XG59XG5cbi8qKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gKi9cbmV4cG9ydCBmdW5jdGlvbiB0aWNrKCkge1xuXHRzY2hlZHVsZV91cGRhdGUoKTtcblx0cmV0dXJuIHJlc29sdmVkX3Byb21pc2U7XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRfcmVuZGVyX2NhbGxiYWNrKGZuKSB7XG5cdHJlbmRlcl9jYWxsYmFja3MucHVzaChmbik7XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRfZmx1c2hfY2FsbGJhY2soZm4pIHtcblx0Zmx1c2hfY2FsbGJhY2tzLnB1c2goZm4pO1xufVxuXG4vLyBmbHVzaCgpIGNhbGxzIGNhbGxiYWNrcyBpbiB0aGlzIG9yZGVyOlxuLy8gMS4gQWxsIGJlZm9yZVVwZGF0ZSBjYWxsYmFja3MsIGluIG9yZGVyOiBwYXJlbnRzIGJlZm9yZSBjaGlsZHJlblxuLy8gMi4gQWxsIGJpbmQ6dGhpcyBjYWxsYmFja3MsIGluIHJldmVyc2Ugb3JkZXI6IGNoaWxkcmVuIGJlZm9yZSBwYXJlbnRzLlxuLy8gMy4gQWxsIGFmdGVyVXBkYXRlIGNhbGxiYWNrcywgaW4gb3JkZXI6IHBhcmVudHMgYmVmb3JlIGNoaWxkcmVuLiBFWENFUFRcbi8vICAgIGZvciBhZnRlclVwZGF0ZXMgY2FsbGVkIGR1cmluZyB0aGUgaW5pdGlhbCBvbk1vdW50LCB3aGljaCBhcmUgY2FsbGVkIGluXG4vLyAgICByZXZlcnNlIG9yZGVyOiBjaGlsZHJlbiBiZWZvcmUgcGFyZW50cy5cbi8vIFNpbmNlIGNhbGxiYWNrcyBtaWdodCB1cGRhdGUgY29tcG9uZW50IHZhbHVlcywgd2hpY2ggY291bGQgdHJpZ2dlciBhbm90aGVyXG4vLyBjYWxsIHRvIGZsdXNoKCksIHRoZSBmb2xsb3dpbmcgc3RlcHMgZ3VhcmQgYWdhaW5zdCB0aGlzOlxuLy8gMS4gRHVyaW5nIGJlZm9yZVVwZGF0ZSwgYW55IHVwZGF0ZWQgY29tcG9uZW50cyB3aWxsIGJlIGFkZGVkIHRvIHRoZVxuLy8gICAgZGlydHlfY29tcG9uZW50cyBhcnJheSBhbmQgd2lsbCBjYXVzZSBhIHJlZW50cmFudCBjYWxsIHRvIGZsdXNoKCkuIEJlY2F1c2Vcbi8vICAgIHRoZSBmbHVzaCBpbmRleCBpcyBrZXB0IG91dHNpZGUgdGhlIGZ1bmN0aW9uLCB0aGUgcmVlbnRyYW50IGNhbGwgd2lsbCBwaWNrXG4vLyAgICB1cCB3aGVyZSB0aGUgZWFybGllciBjYWxsIGxlZnQgb2ZmIGFuZCBnbyB0aHJvdWdoIGFsbCBkaXJ0eSBjb21wb25lbnRzLiBUaGVcbi8vICAgIGN1cnJlbnRfY29tcG9uZW50IHZhbHVlIGlzIHNhdmVkIGFuZCByZXN0b3JlZCBzbyB0aGF0IHRoZSByZWVudHJhbnQgY2FsbCB3aWxsXG4vLyAgICBub3QgaW50ZXJmZXJlIHdpdGggdGhlIFwicGFyZW50XCIgZmx1c2goKSBjYWxsLlxuLy8gMi4gYmluZDp0aGlzIGNhbGxiYWNrcyBjYW5ub3QgdHJpZ2dlciBuZXcgZmx1c2goKSBjYWxscy5cbi8vIDMuIER1cmluZyBhZnRlclVwZGF0ZSwgYW55IHVwZGF0ZWQgY29tcG9uZW50cyB3aWxsIE5PVCBoYXZlIHRoZWlyIGFmdGVyVXBkYXRlXG4vLyAgICBjYWxsYmFjayBjYWxsZWQgYSBzZWNvbmQgdGltZTsgdGhlIHNlZW5fY2FsbGJhY2tzIHNldCwgb3V0c2lkZSB0aGUgZmx1c2goKVxuLy8gICAgZnVuY3Rpb24sIGd1YXJhbnRlZXMgdGhpcyBiZWhhdmlvci5cbmNvbnN0IHNlZW5fY2FsbGJhY2tzID0gbmV3IFNldCgpO1xuXG5sZXQgZmx1c2hpZHggPSAwOyAvLyBEbyAqbm90KiBtb3ZlIHRoaXMgaW5zaWRlIHRoZSBmbHVzaCgpIGZ1bmN0aW9uXG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBmbHVzaCgpIHtcblx0Ly8gRG8gbm90IHJlZW50ZXIgZmx1c2ggd2hpbGUgZGlydHkgY29tcG9uZW50cyBhcmUgdXBkYXRlZCwgYXMgdGhpcyBjYW5cblx0Ly8gcmVzdWx0IGluIGFuIGluZmluaXRlIGxvb3AuIEluc3RlYWQsIGxldCB0aGUgaW5uZXIgZmx1c2ggaGFuZGxlIGl0LlxuXHQvLyBSZWVudHJhbmN5IGlzIG9rIGFmdGVyd2FyZHMgZm9yIGJpbmRpbmdzIGV0Yy5cblx0aWYgKGZsdXNoaWR4ICE9PSAwKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdGNvbnN0IHNhdmVkX2NvbXBvbmVudCA9IGN1cnJlbnRfY29tcG9uZW50O1xuXHRkbyB7XG5cdFx0Ly8gZmlyc3QsIGNhbGwgYmVmb3JlVXBkYXRlIGZ1bmN0aW9uc1xuXHRcdC8vIGFuZCB1cGRhdGUgY29tcG9uZW50c1xuXHRcdHRyeSB7XG5cdFx0XHR3aGlsZSAoZmx1c2hpZHggPCBkaXJ0eV9jb21wb25lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRjb25zdCBjb21wb25lbnQgPSBkaXJ0eV9jb21wb25lbnRzW2ZsdXNoaWR4XTtcblx0XHRcdFx0Zmx1c2hpZHgrKztcblx0XHRcdFx0c2V0X2N1cnJlbnRfY29tcG9uZW50KGNvbXBvbmVudCk7XG5cdFx0XHRcdHVwZGF0ZShjb21wb25lbnQuJCQpO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdC8vIHJlc2V0IGRpcnR5IHN0YXRlIHRvIG5vdCBlbmQgdXAgaW4gYSBkZWFkbG9ja2VkIHN0YXRlIGFuZCB0aGVuIHJldGhyb3dcblx0XHRcdGRpcnR5X2NvbXBvbmVudHMubGVuZ3RoID0gMDtcblx0XHRcdGZsdXNoaWR4ID0gMDtcblx0XHRcdHRocm93IGU7XG5cdFx0fVxuXHRcdHNldF9jdXJyZW50X2NvbXBvbmVudChudWxsKTtcblx0XHRkaXJ0eV9jb21wb25lbnRzLmxlbmd0aCA9IDA7XG5cdFx0Zmx1c2hpZHggPSAwO1xuXHRcdHdoaWxlIChiaW5kaW5nX2NhbGxiYWNrcy5sZW5ndGgpIGJpbmRpbmdfY2FsbGJhY2tzLnBvcCgpKCk7XG5cdFx0Ly8gdGhlbiwgb25jZSBjb21wb25lbnRzIGFyZSB1cGRhdGVkLCBjYWxsXG5cdFx0Ly8gYWZ0ZXJVcGRhdGUgZnVuY3Rpb25zLiBUaGlzIG1heSBjYXVzZVxuXHRcdC8vIHN1YnNlcXVlbnQgdXBkYXRlcy4uLlxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcmVuZGVyX2NhbGxiYWNrcy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdFx0Y29uc3QgY2FsbGJhY2sgPSByZW5kZXJfY2FsbGJhY2tzW2ldO1xuXHRcdFx0aWYgKCFzZWVuX2NhbGxiYWNrcy5oYXMoY2FsbGJhY2spKSB7XG5cdFx0XHRcdC8vIC4uLnNvIGd1YXJkIGFnYWluc3QgaW5maW5pdGUgbG9vcHNcblx0XHRcdFx0c2Vlbl9jYWxsYmFja3MuYWRkKGNhbGxiYWNrKTtcblx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmVuZGVyX2NhbGxiYWNrcy5sZW5ndGggPSAwO1xuXHR9IHdoaWxlIChkaXJ0eV9jb21wb25lbnRzLmxlbmd0aCk7XG5cdHdoaWxlIChmbHVzaF9jYWxsYmFja3MubGVuZ3RoKSB7XG5cdFx0Zmx1c2hfY2FsbGJhY2tzLnBvcCgpKCk7XG5cdH1cblx0dXBkYXRlX3NjaGVkdWxlZCA9IGZhbHNlO1xuXHRzZWVuX2NhbGxiYWNrcy5jbGVhcigpO1xuXHRzZXRfY3VycmVudF9jb21wb25lbnQoc2F2ZWRfY29tcG9uZW50KTtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZnVuY3Rpb24gdXBkYXRlKCQkKSB7XG5cdGlmICgkJC5mcmFnbWVudCAhPT0gbnVsbCkge1xuXHRcdCQkLnVwZGF0ZSgpO1xuXHRcdHJ1bl9hbGwoJCQuYmVmb3JlX3VwZGF0ZSk7XG5cdFx0Y29uc3QgZGlydHkgPSAkJC5kaXJ0eTtcblx0XHQkJC5kaXJ0eSA9IFstMV07XG5cdFx0JCQuZnJhZ21lbnQgJiYgJCQuZnJhZ21lbnQucCgkJC5jdHgsIGRpcnR5KTtcblx0XHQkJC5hZnRlcl91cGRhdGUuZm9yRWFjaChhZGRfcmVuZGVyX2NhbGxiYWNrKTtcblx0fVxufVxuXG4vKipcbiAqIFVzZWZ1bCBmb3IgZXhhbXBsZSB0byBleGVjdXRlIHJlbWFpbmluZyBgYWZ0ZXJVcGRhdGVgIGNhbGxiYWNrcyBiZWZvcmUgZXhlY3V0aW5nIGBkZXN0cm95YC5cbiAqIEBwYXJhbSB7RnVuY3Rpb25bXX0gZm5zXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZsdXNoX3JlbmRlcl9jYWxsYmFja3MoZm5zKSB7XG5cdGNvbnN0IGZpbHRlcmVkID0gW107XG5cdGNvbnN0IHRhcmdldHMgPSBbXTtcblx0cmVuZGVyX2NhbGxiYWNrcy5mb3JFYWNoKChjKSA9PiAoZm5zLmluZGV4T2YoYykgPT09IC0xID8gZmlsdGVyZWQucHVzaChjKSA6IHRhcmdldHMucHVzaChjKSkpO1xuXHR0YXJnZXRzLmZvckVhY2goKGMpID0+IGMoKSk7XG5cdHJlbmRlcl9jYWxsYmFja3MgPSBmaWx0ZXJlZDtcbn1cbiIsICJpbXBvcnQgeyBpZGVudGl0eSBhcyBsaW5lYXIsIGlzX2Z1bmN0aW9uLCBub29wLCBydW5fYWxsIH0gZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyBub3cgfSBmcm9tICcuL2Vudmlyb25tZW50LmpzJztcbmltcG9ydCB7IGxvb3AgfSBmcm9tICcuL2xvb3AuanMnO1xuaW1wb3J0IHsgY3JlYXRlX3J1bGUsIGRlbGV0ZV9ydWxlIH0gZnJvbSAnLi9zdHlsZV9tYW5hZ2VyLmpzJztcbmltcG9ydCB7IGN1c3RvbV9ldmVudCB9IGZyb20gJy4vZG9tLmpzJztcbmltcG9ydCB7IGFkZF9yZW5kZXJfY2FsbGJhY2sgfSBmcm9tICcuL3NjaGVkdWxlci5qcyc7XG5cbi8qKlxuICogQHR5cGUge1Byb21pc2U8dm9pZD4gfCBudWxsfVxuICovXG5sZXQgcHJvbWlzZTtcblxuLyoqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAqL1xuZnVuY3Rpb24gd2FpdCgpIHtcblx0aWYgKCFwcm9taXNlKSB7XG5cdFx0cHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuXHRcdHByb21pc2UudGhlbigoKSA9PiB7XG5cdFx0XHRwcm9taXNlID0gbnVsbDtcblx0XHR9KTtcblx0fVxuXHRyZXR1cm4gcHJvbWlzZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7SU5UUk8gfCBPVVRSTyB8IGJvb2xlYW59IGRpcmVjdGlvblxuICogQHBhcmFtIHsnc3RhcnQnIHwgJ2VuZCd9IGtpbmRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBkaXNwYXRjaChub2RlLCBkaXJlY3Rpb24sIGtpbmQpIHtcblx0bm9kZS5kaXNwYXRjaEV2ZW50KGN1c3RvbV9ldmVudChgJHtkaXJlY3Rpb24gPyAnaW50cm8nIDogJ291dHJvJ30ke2tpbmR9YCkpO1xufVxuXG5jb25zdCBvdXRyb2luZyA9IG5ldyBTZXQoKTtcblxuLyoqXG4gKiBAdHlwZSB7T3V0cm99XG4gKi9cbmxldCBvdXRyb3M7XG5cbi8qKlxuICogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gZ3JvdXBfb3V0cm9zKCkge1xuXHRvdXRyb3MgPSB7XG5cdFx0cjogMCxcblx0XHRjOiBbXSxcblx0XHRwOiBvdXRyb3MgLy8gcGFyZW50IGdyb3VwXG5cdH07XG59XG5cbi8qKlxuICogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tfb3V0cm9zKCkge1xuXHRpZiAoIW91dHJvcy5yKSB7XG5cdFx0cnVuX2FsbChvdXRyb3MuYyk7XG5cdH1cblx0b3V0cm9zID0gb3V0cm9zLnA7XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLkZyYWdtZW50fSBibG9ja1xuICogQHBhcmFtIHswIHwgMX0gW2xvY2FsXVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2l0aW9uX2luKGJsb2NrLCBsb2NhbCkge1xuXHRpZiAoYmxvY2sgJiYgYmxvY2suaSkge1xuXHRcdG91dHJvaW5nLmRlbGV0ZShibG9jayk7XG5cdFx0YmxvY2suaShsb2NhbCk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9wcml2YXRlLmpzJykuRnJhZ21lbnR9IGJsb2NrXG4gKiBAcGFyYW0gezAgfCAxfSBsb2NhbFxuICogQHBhcmFtIHswIHwgMX0gW2RldGFjaF1cbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gW2NhbGxiYWNrXVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2l0aW9uX291dChibG9jaywgbG9jYWwsIGRldGFjaCwgY2FsbGJhY2spIHtcblx0aWYgKGJsb2NrICYmIGJsb2NrLm8pIHtcblx0XHRpZiAob3V0cm9pbmcuaGFzKGJsb2NrKSkgcmV0dXJuO1xuXHRcdG91dHJvaW5nLmFkZChibG9jayk7XG5cdFx0b3V0cm9zLmMucHVzaCgoKSA9PiB7XG5cdFx0XHRvdXRyb2luZy5kZWxldGUoYmxvY2spO1xuXHRcdFx0aWYgKGNhbGxiYWNrKSB7XG5cdFx0XHRcdGlmIChkZXRhY2gpIGJsb2NrLmQoMSk7XG5cdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0YmxvY2subyhsb2NhbCk7XG5cdH0gZWxzZSBpZiAoY2FsbGJhY2spIHtcblx0XHRjYWxsYmFjaygpO1xuXHR9XG59XG5cbi8qKlxuICogQHR5cGUge2ltcG9ydCgnLi4vdHJhbnNpdGlvbi9wdWJsaWMuanMnKS5UcmFuc2l0aW9uQ29uZmlnfVxuICovXG5jb25zdCBudWxsX3RyYW5zaXRpb24gPSB7IGR1cmF0aW9uOiAwIH07XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50ICYgRWxlbWVudENTU0lubGluZVN0eWxlfSBub2RlXG4gKiBAcGFyYW0ge1RyYW5zaXRpb25Gbn0gZm5cbiAqIEBwYXJhbSB7YW55fSBwYXJhbXNcbiAqIEByZXR1cm5zIHt7IHN0YXJ0KCk6IHZvaWQ7IGludmFsaWRhdGUoKTogdm9pZDsgZW5kKCk6IHZvaWQ7IH19XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVfaW5fdHJhbnNpdGlvbihub2RlLCBmbiwgcGFyYW1zKSB7XG5cdC8qKlxuXHQgKiBAdHlwZSB7VHJhbnNpdGlvbk9wdGlvbnN9ICovXG5cdGNvbnN0IG9wdGlvbnMgPSB7IGRpcmVjdGlvbjogJ2luJyB9O1xuXHRsZXQgY29uZmlnID0gZm4obm9kZSwgcGFyYW1zLCBvcHRpb25zKTtcblx0bGV0IHJ1bm5pbmcgPSBmYWxzZTtcblx0bGV0IGFuaW1hdGlvbl9uYW1lO1xuXHRsZXQgdGFzaztcblx0bGV0IHVpZCA9IDA7XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHt2b2lkfSAqL1xuXHRmdW5jdGlvbiBjbGVhbnVwKCkge1xuXHRcdGlmIChhbmltYXRpb25fbmFtZSkgZGVsZXRlX3J1bGUobm9kZSwgYW5pbWF0aW9uX25hbWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHt2b2lkfSAqL1xuXHRmdW5jdGlvbiBnbygpIHtcblx0XHRjb25zdCB7XG5cdFx0XHRkZWxheSA9IDAsXG5cdFx0XHRkdXJhdGlvbiA9IDMwMCxcblx0XHRcdGVhc2luZyA9IGxpbmVhcixcblx0XHRcdHRpY2sgPSBub29wLFxuXHRcdFx0Y3NzXG5cdFx0fSA9IGNvbmZpZyB8fCBudWxsX3RyYW5zaXRpb247XG5cdFx0aWYgKGNzcykgYW5pbWF0aW9uX25hbWUgPSBjcmVhdGVfcnVsZShub2RlLCAwLCAxLCBkdXJhdGlvbiwgZGVsYXksIGVhc2luZywgY3NzLCB1aWQrKyk7XG5cdFx0dGljaygwLCAxKTtcblx0XHRjb25zdCBzdGFydF90aW1lID0gbm93KCkgKyBkZWxheTtcblx0XHRjb25zdCBlbmRfdGltZSA9IHN0YXJ0X3RpbWUgKyBkdXJhdGlvbjtcblx0XHRpZiAodGFzaykgdGFzay5hYm9ydCgpO1xuXHRcdHJ1bm5pbmcgPSB0cnVlO1xuXHRcdGFkZF9yZW5kZXJfY2FsbGJhY2soKCkgPT4gZGlzcGF0Y2gobm9kZSwgdHJ1ZSwgJ3N0YXJ0JykpO1xuXHRcdHRhc2sgPSBsb29wKChub3cpID0+IHtcblx0XHRcdGlmIChydW5uaW5nKSB7XG5cdFx0XHRcdGlmIChub3cgPj0gZW5kX3RpbWUpIHtcblx0XHRcdFx0XHR0aWNrKDEsIDApO1xuXHRcdFx0XHRcdGRpc3BhdGNoKG5vZGUsIHRydWUsICdlbmQnKTtcblx0XHRcdFx0XHRjbGVhbnVwKCk7XG5cdFx0XHRcdFx0cmV0dXJuIChydW5uaW5nID0gZmFsc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChub3cgPj0gc3RhcnRfdGltZSkge1xuXHRcdFx0XHRcdGNvbnN0IHQgPSBlYXNpbmcoKG5vdyAtIHN0YXJ0X3RpbWUpIC8gZHVyYXRpb24pO1xuXHRcdFx0XHRcdHRpY2sodCwgMSAtIHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcnVubmluZztcblx0XHR9KTtcblx0fVxuXHRsZXQgc3RhcnRlZCA9IGZhbHNlO1xuXHRyZXR1cm4ge1xuXHRcdHN0YXJ0KCkge1xuXHRcdFx0aWYgKHN0YXJ0ZWQpIHJldHVybjtcblx0XHRcdHN0YXJ0ZWQgPSB0cnVlO1xuXHRcdFx0ZGVsZXRlX3J1bGUobm9kZSk7XG5cdFx0XHRpZiAoaXNfZnVuY3Rpb24oY29uZmlnKSkge1xuXHRcdFx0XHRjb25maWcgPSBjb25maWcob3B0aW9ucyk7XG5cdFx0XHRcdHdhaXQoKS50aGVuKGdvKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGdvKCk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRpbnZhbGlkYXRlKCkge1xuXHRcdFx0c3RhcnRlZCA9IGZhbHNlO1xuXHRcdH0sXG5cdFx0ZW5kKCkge1xuXHRcdFx0aWYgKHJ1bm5pbmcpIHtcblx0XHRcdFx0Y2xlYW51cCgpO1xuXHRcdFx0XHRydW5uaW5nID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudCAmIEVsZW1lbnRDU1NJbmxpbmVTdHlsZX0gbm9kZVxuICogQHBhcmFtIHtUcmFuc2l0aW9uRm59IGZuXG4gKiBAcGFyYW0ge2FueX0gcGFyYW1zXG4gKiBAcmV0dXJucyB7eyBlbmQocmVzZXQ6IGFueSk6IHZvaWQ7IH19XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVfb3V0X3RyYW5zaXRpb24obm9kZSwgZm4sIHBhcmFtcykge1xuXHQvKiogQHR5cGUge1RyYW5zaXRpb25PcHRpb25zfSAqL1xuXHRjb25zdCBvcHRpb25zID0geyBkaXJlY3Rpb246ICdvdXQnIH07XG5cdGxldCBjb25maWcgPSBmbihub2RlLCBwYXJhbXMsIG9wdGlvbnMpO1xuXHRsZXQgcnVubmluZyA9IHRydWU7XG5cdGxldCBhbmltYXRpb25fbmFtZTtcblx0Y29uc3QgZ3JvdXAgPSBvdXRyb3M7XG5cdGdyb3VwLnIgKz0gMTtcblx0LyoqIEB0eXBlIHtib29sZWFufSAqL1xuXHRsZXQgb3JpZ2luYWxfaW5lcnRfdmFsdWU7XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHt2b2lkfSAqL1xuXHRmdW5jdGlvbiBnbygpIHtcblx0XHRjb25zdCB7XG5cdFx0XHRkZWxheSA9IDAsXG5cdFx0XHRkdXJhdGlvbiA9IDMwMCxcblx0XHRcdGVhc2luZyA9IGxpbmVhcixcblx0XHRcdHRpY2sgPSBub29wLFxuXHRcdFx0Y3NzXG5cdFx0fSA9IGNvbmZpZyB8fCBudWxsX3RyYW5zaXRpb247XG5cblx0XHRpZiAoY3NzKSBhbmltYXRpb25fbmFtZSA9IGNyZWF0ZV9ydWxlKG5vZGUsIDEsIDAsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nLCBjc3MpO1xuXG5cdFx0Y29uc3Qgc3RhcnRfdGltZSA9IG5vdygpICsgZGVsYXk7XG5cdFx0Y29uc3QgZW5kX3RpbWUgPSBzdGFydF90aW1lICsgZHVyYXRpb247XG5cdFx0YWRkX3JlbmRlcl9jYWxsYmFjaygoKSA9PiBkaXNwYXRjaChub2RlLCBmYWxzZSwgJ3N0YXJ0JykpO1xuXG5cdFx0aWYgKCdpbmVydCcgaW4gbm9kZSkge1xuXHRcdFx0b3JpZ2luYWxfaW5lcnRfdmFsdWUgPSAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyAobm9kZSkuaW5lcnQ7XG5cdFx0XHRub2RlLmluZXJ0ID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRsb29wKChub3cpID0+IHtcblx0XHRcdGlmIChydW5uaW5nKSB7XG5cdFx0XHRcdGlmIChub3cgPj0gZW5kX3RpbWUpIHtcblx0XHRcdFx0XHR0aWNrKDAsIDEpO1xuXHRcdFx0XHRcdGRpc3BhdGNoKG5vZGUsIGZhbHNlLCAnZW5kJyk7XG5cdFx0XHRcdFx0aWYgKCEtLWdyb3VwLnIpIHtcblx0XHRcdFx0XHRcdC8vIHRoaXMgd2lsbCByZXN1bHQgaW4gYGVuZCgpYCBiZWluZyBjYWxsZWQsXG5cdFx0XHRcdFx0XHQvLyBzbyB3ZSBkb24ndCBuZWVkIHRvIGNsZWFuIHVwIGhlcmVcblx0XHRcdFx0XHRcdHJ1bl9hbGwoZ3JvdXAuYyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobm93ID49IHN0YXJ0X3RpbWUpIHtcblx0XHRcdFx0XHRjb25zdCB0ID0gZWFzaW5nKChub3cgLSBzdGFydF90aW1lKSAvIGR1cmF0aW9uKTtcblx0XHRcdFx0XHR0aWNrKDEgLSB0LCB0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJ1bm5pbmc7XG5cdFx0fSk7XG5cdH1cblxuXHRpZiAoaXNfZnVuY3Rpb24oY29uZmlnKSkge1xuXHRcdHdhaXQoKS50aGVuKCgpID0+IHtcblx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdGNvbmZpZyA9IGNvbmZpZyhvcHRpb25zKTtcblx0XHRcdGdvKCk7XG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0Z28oKTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0ZW5kKHJlc2V0KSB7XG5cdFx0XHRpZiAocmVzZXQgJiYgJ2luZXJ0JyBpbiBub2RlKSB7XG5cdFx0XHRcdG5vZGUuaW5lcnQgPSBvcmlnaW5hbF9pbmVydF92YWx1ZTtcblx0XHRcdH1cblx0XHRcdGlmIChyZXNldCAmJiBjb25maWcudGljaykge1xuXHRcdFx0XHRjb25maWcudGljaygxLCAwKTtcblx0XHRcdH1cblx0XHRcdGlmIChydW5uaW5nKSB7XG5cdFx0XHRcdGlmIChhbmltYXRpb25fbmFtZSkgZGVsZXRlX3J1bGUobm9kZSwgYW5pbWF0aW9uX25hbWUpO1xuXHRcdFx0XHRydW5uaW5nID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudCAmIEVsZW1lbnRDU1NJbmxpbmVTdHlsZX0gbm9kZVxuICogQHBhcmFtIHtUcmFuc2l0aW9uRm59IGZuXG4gKiBAcGFyYW0ge2FueX0gcGFyYW1zXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGludHJvXG4gKiBAcmV0dXJucyB7eyBydW4oYjogMCB8IDEpOiB2b2lkOyBlbmQoKTogdm9pZDsgfX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZV9iaWRpcmVjdGlvbmFsX3RyYW5zaXRpb24obm9kZSwgZm4sIHBhcmFtcywgaW50cm8pIHtcblx0LyoqXG5cdCAqIEB0eXBlIHtUcmFuc2l0aW9uT3B0aW9uc30gKi9cblx0Y29uc3Qgb3B0aW9ucyA9IHsgZGlyZWN0aW9uOiAnYm90aCcgfTtcblx0bGV0IGNvbmZpZyA9IGZuKG5vZGUsIHBhcmFtcywgb3B0aW9ucyk7XG5cdGxldCB0ID0gaW50cm8gPyAwIDogMTtcblxuXHQvKipcblx0ICogQHR5cGUge1Byb2dyYW0gfCBudWxsfSAqL1xuXHRsZXQgcnVubmluZ19wcm9ncmFtID0gbnVsbDtcblxuXHQvKipcblx0ICogQHR5cGUge1BlbmRpbmdQcm9ncmFtIHwgbnVsbH0gKi9cblx0bGV0IHBlbmRpbmdfcHJvZ3JhbSA9IG51bGw7XG5cdGxldCBhbmltYXRpb25fbmFtZSA9IG51bGw7XG5cblx0LyoqIEB0eXBlIHtib29sZWFufSAqL1xuXHRsZXQgb3JpZ2luYWxfaW5lcnRfdmFsdWU7XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHt2b2lkfSAqL1xuXHRmdW5jdGlvbiBjbGVhcl9hbmltYXRpb24oKSB7XG5cdFx0aWYgKGFuaW1hdGlvbl9uYW1lKSBkZWxldGVfcnVsZShub2RlLCBhbmltYXRpb25fbmFtZSk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtQZW5kaW5nUHJvZ3JhbX0gcHJvZ3JhbVxuXHQgKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb25cblx0ICogQHJldHVybnMge1Byb2dyYW19XG5cdCAqL1xuXHRmdW5jdGlvbiBpbml0KHByb2dyYW0sIGR1cmF0aW9uKSB7XG5cdFx0Y29uc3QgZCA9IC8qKiBAdHlwZSB7UHJvZ3JhbVsnZCddfSAqLyAocHJvZ3JhbS5iIC0gdCk7XG5cdFx0ZHVyYXRpb24gKj0gTWF0aC5hYnMoZCk7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGE6IHQsXG5cdFx0XHRiOiBwcm9ncmFtLmIsXG5cdFx0XHRkLFxuXHRcdFx0ZHVyYXRpb24sXG5cdFx0XHRzdGFydDogcHJvZ3JhbS5zdGFydCxcblx0XHRcdGVuZDogcHJvZ3JhbS5zdGFydCArIGR1cmF0aW9uLFxuXHRcdFx0Z3JvdXA6IHByb2dyYW0uZ3JvdXBcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7SU5UUk8gfCBPVVRST30gYlxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdGZ1bmN0aW9uIGdvKGIpIHtcblx0XHRjb25zdCB7XG5cdFx0XHRkZWxheSA9IDAsXG5cdFx0XHRkdXJhdGlvbiA9IDMwMCxcblx0XHRcdGVhc2luZyA9IGxpbmVhcixcblx0XHRcdHRpY2sgPSBub29wLFxuXHRcdFx0Y3NzXG5cdFx0fSA9IGNvbmZpZyB8fCBudWxsX3RyYW5zaXRpb247XG5cblx0XHQvKipcblx0XHQgKiBAdHlwZSB7UGVuZGluZ1Byb2dyYW19ICovXG5cdFx0Y29uc3QgcHJvZ3JhbSA9IHtcblx0XHRcdHN0YXJ0OiBub3coKSArIGRlbGF5LFxuXHRcdFx0YlxuXHRcdH07XG5cblx0XHRpZiAoIWIpIHtcblx0XHRcdC8vIEB0cy1pZ25vcmUgdG9kbzogaW1wcm92ZSB0eXBpbmdzXG5cdFx0XHRwcm9ncmFtLmdyb3VwID0gb3V0cm9zO1xuXHRcdFx0b3V0cm9zLnIgKz0gMTtcblx0XHR9XG5cblx0XHRpZiAoJ2luZXJ0JyBpbiBub2RlKSB7XG5cdFx0XHRpZiAoYikge1xuXHRcdFx0XHRpZiAob3JpZ2luYWxfaW5lcnRfdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdC8vIGFib3J0ZWQvcmV2ZXJzZWQgb3V0cm8gXHUyMDE0IHJlc3RvcmUgcHJldmlvdXMgaW5lcnQgdmFsdWVcblx0XHRcdFx0XHRub2RlLmluZXJ0ID0gb3JpZ2luYWxfaW5lcnRfdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9yaWdpbmFsX2luZXJ0X3ZhbHVlID0gLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8gKG5vZGUpLmluZXJ0O1xuXHRcdFx0XHRub2RlLmluZXJ0ID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAocnVubmluZ19wcm9ncmFtIHx8IHBlbmRpbmdfcHJvZ3JhbSkge1xuXHRcdFx0cGVuZGluZ19wcm9ncmFtID0gcHJvZ3JhbTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gaWYgdGhpcyBpcyBhbiBpbnRybywgYW5kIHRoZXJlJ3MgYSBkZWxheSwgd2UgbmVlZCB0byBkb1xuXHRcdFx0Ly8gYW4gaW5pdGlhbCB0aWNrIGFuZC9vciBhcHBseSBDU1MgYW5pbWF0aW9uIGltbWVkaWF0ZWx5XG5cdFx0XHRpZiAoY3NzKSB7XG5cdFx0XHRcdGNsZWFyX2FuaW1hdGlvbigpO1xuXHRcdFx0XHRhbmltYXRpb25fbmFtZSA9IGNyZWF0ZV9ydWxlKG5vZGUsIHQsIGIsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nLCBjc3MpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGIpIHRpY2soMCwgMSk7XG5cdFx0XHRydW5uaW5nX3Byb2dyYW0gPSBpbml0KHByb2dyYW0sIGR1cmF0aW9uKTtcblx0XHRcdGFkZF9yZW5kZXJfY2FsbGJhY2soKCkgPT4gZGlzcGF0Y2gobm9kZSwgYiwgJ3N0YXJ0JykpO1xuXHRcdFx0bG9vcCgobm93KSA9PiB7XG5cdFx0XHRcdGlmIChwZW5kaW5nX3Byb2dyYW0gJiYgbm93ID4gcGVuZGluZ19wcm9ncmFtLnN0YXJ0KSB7XG5cdFx0XHRcdFx0cnVubmluZ19wcm9ncmFtID0gaW5pdChwZW5kaW5nX3Byb2dyYW0sIGR1cmF0aW9uKTtcblx0XHRcdFx0XHRwZW5kaW5nX3Byb2dyYW0gPSBudWxsO1xuXHRcdFx0XHRcdGRpc3BhdGNoKG5vZGUsIHJ1bm5pbmdfcHJvZ3JhbS5iLCAnc3RhcnQnKTtcblx0XHRcdFx0XHRpZiAoY3NzKSB7XG5cdFx0XHRcdFx0XHRjbGVhcl9hbmltYXRpb24oKTtcblx0XHRcdFx0XHRcdGFuaW1hdGlvbl9uYW1lID0gY3JlYXRlX3J1bGUoXG5cdFx0XHRcdFx0XHRcdG5vZGUsXG5cdFx0XHRcdFx0XHRcdHQsXG5cdFx0XHRcdFx0XHRcdHJ1bm5pbmdfcHJvZ3JhbS5iLFxuXHRcdFx0XHRcdFx0XHRydW5uaW5nX3Byb2dyYW0uZHVyYXRpb24sXG5cdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdGVhc2luZyxcblx0XHRcdFx0XHRcdFx0Y29uZmlnLmNzc1xuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHJ1bm5pbmdfcHJvZ3JhbSkge1xuXHRcdFx0XHRcdGlmIChub3cgPj0gcnVubmluZ19wcm9ncmFtLmVuZCkge1xuXHRcdFx0XHRcdFx0dGljaygodCA9IHJ1bm5pbmdfcHJvZ3JhbS5iKSwgMSAtIHQpO1xuXHRcdFx0XHRcdFx0ZGlzcGF0Y2gobm9kZSwgcnVubmluZ19wcm9ncmFtLmIsICdlbmQnKTtcblx0XHRcdFx0XHRcdGlmICghcGVuZGluZ19wcm9ncmFtKSB7XG5cdFx0XHRcdFx0XHRcdC8vIHdlJ3JlIGRvbmVcblx0XHRcdFx0XHRcdFx0aWYgKHJ1bm5pbmdfcHJvZ3JhbS5iKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gaW50cm8gXHUyMDE0IHdlIGNhbiB0aWR5IHVwIGltbWVkaWF0ZWx5XG5cdFx0XHRcdFx0XHRcdFx0Y2xlYXJfYW5pbWF0aW9uKCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gb3V0cm8gXHUyMDE0IG5lZWRzIHRvIGJlIGNvb3JkaW5hdGVkXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCEtLXJ1bm5pbmdfcHJvZ3JhbS5ncm91cC5yKSBydW5fYWxsKHJ1bm5pbmdfcHJvZ3JhbS5ncm91cC5jKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cnVubmluZ19wcm9ncmFtID0gbnVsbDtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKG5vdyA+PSBydW5uaW5nX3Byb2dyYW0uc3RhcnQpIHtcblx0XHRcdFx0XHRcdGNvbnN0IHAgPSBub3cgLSBydW5uaW5nX3Byb2dyYW0uc3RhcnQ7XG5cdFx0XHRcdFx0XHR0ID0gcnVubmluZ19wcm9ncmFtLmEgKyBydW5uaW5nX3Byb2dyYW0uZCAqIGVhc2luZyhwIC8gcnVubmluZ19wcm9ncmFtLmR1cmF0aW9uKTtcblx0XHRcdFx0XHRcdHRpY2sodCwgMSAtIHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gISEocnVubmluZ19wcm9ncmFtIHx8IHBlbmRpbmdfcHJvZ3JhbSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHtcblx0XHRydW4oYikge1xuXHRcdFx0aWYgKGlzX2Z1bmN0aW9uKGNvbmZpZykpIHtcblx0XHRcdFx0d2FpdCgpLnRoZW4oKCkgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IG9wdHMgPSB7IGRpcmVjdGlvbjogYiA/ICdpbicgOiAnb3V0JyB9O1xuXHRcdFx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdFx0XHRjb25maWcgPSBjb25maWcob3B0cyk7XG5cdFx0XHRcdFx0Z28oYik7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Z28oYik7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRlbmQoKSB7XG5cdFx0XHRjbGVhcl9hbmltYXRpb24oKTtcblx0XHRcdHJ1bm5pbmdfcHJvZ3JhbSA9IHBlbmRpbmdfcHJvZ3JhbSA9IG51bGw7XG5cdFx0fVxuXHR9O1xufVxuXG4vKiogQHR5cGVkZWYgezF9IElOVFJPICovXG4vKiogQHR5cGVkZWYgezB9IE9VVFJPICovXG4vKiogQHR5cGVkZWYge3sgZGlyZWN0aW9uOiAnaW4nIHwgJ291dCcgfCAnYm90aCcgfX0gVHJhbnNpdGlvbk9wdGlvbnMgKi9cbi8qKiBAdHlwZWRlZiB7KG5vZGU6IEVsZW1lbnQsIHBhcmFtczogYW55LCBvcHRpb25zOiBUcmFuc2l0aW9uT3B0aW9ucykgPT4gaW1wb3J0KCcuLi90cmFuc2l0aW9uL3B1YmxpYy5qcycpLlRyYW5zaXRpb25Db25maWd9IFRyYW5zaXRpb25GbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE91dHJvXG4gKiBAcHJvcGVydHkge251bWJlcn0gclxuICogQHByb3BlcnR5IHtGdW5jdGlvbltdfSBjXG4gKiBAcHJvcGVydHkge09iamVjdH0gcFxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUGVuZGluZ1Byb2dyYW1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzdGFydFxuICogQHByb3BlcnR5IHtJTlRST3xPVVRST30gYlxuICogQHByb3BlcnR5IHtPdXRyb30gW2dyb3VwXVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUHJvZ3JhbVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGFcbiAqIEBwcm9wZXJ0eSB7SU5UUk98T1VUUk99IGJcbiAqIEBwcm9wZXJ0eSB7MXwtMX0gZFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGR1cmF0aW9uXG4gKiBAcHJvcGVydHkge251bWJlcn0gc3RhcnRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBlbmRcbiAqIEBwcm9wZXJ0eSB7T3V0cm99IFtncm91cF1cbiAqL1xuIiwgImltcG9ydCB7IHRyYW5zaXRpb25faW4sIHRyYW5zaXRpb25fb3V0IH0gZnJvbSAnLi90cmFuc2l0aW9ucy5qcyc7XG5pbXBvcnQgeyBydW5fYWxsIH0gZnJvbSAnLi91dGlscy5qcyc7XG5cbi8vIGdlbmVyYWwgZWFjaCBmdW5jdGlvbnM6XG5cbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVfYXJyYXlfbGlrZShhcnJheV9saWtlX29yX2l0ZXJhdG9yKSB7XG5cdHJldHVybiBhcnJheV9saWtlX29yX2l0ZXJhdG9yPy5sZW5ndGggIT09IHVuZGVmaW5lZFxuXHRcdD8gYXJyYXlfbGlrZV9vcl9pdGVyYXRvclxuXHRcdDogQXJyYXkuZnJvbShhcnJheV9saWtlX29yX2l0ZXJhdG9yKTtcbn1cblxuLy8ga2V5ZWQgZWFjaCBmdW5jdGlvbnM6XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApIHtcblx0YmxvY2suZCgxKTtcblx0bG9va3VwLmRlbGV0ZShibG9jay5rZXkpO1xufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gb3V0cm9fYW5kX2Rlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCkge1xuXHR0cmFuc2l0aW9uX291dChibG9jaywgMSwgMSwgKCkgPT4ge1xuXHRcdGxvb2t1cC5kZWxldGUoYmxvY2sua2V5KTtcblx0fSk7XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaXhfYW5kX2Rlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCkge1xuXHRibG9jay5mKCk7XG5cdGRlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCk7XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaXhfYW5kX291dHJvX2FuZF9kZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApIHtcblx0YmxvY2suZigpO1xuXHRvdXRyb19hbmRfZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKTtcbn1cblxuLyoqIEByZXR1cm5zIHthbnlbXX0gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVfa2V5ZWRfZWFjaChcblx0b2xkX2Jsb2Nrcyxcblx0ZGlydHksXG5cdGdldF9rZXksXG5cdGR5bmFtaWMsXG5cdGN0eCxcblx0bGlzdCxcblx0bG9va3VwLFxuXHRub2RlLFxuXHRkZXN0cm95LFxuXHRjcmVhdGVfZWFjaF9ibG9jayxcblx0bmV4dCxcblx0Z2V0X2NvbnRleHRcbikge1xuXHRsZXQgbyA9IG9sZF9ibG9ja3MubGVuZ3RoO1xuXHRsZXQgbiA9IGxpc3QubGVuZ3RoO1xuXHRsZXQgaSA9IG87XG5cdGNvbnN0IG9sZF9pbmRleGVzID0ge307XG5cdHdoaWxlIChpLS0pIG9sZF9pbmRleGVzW29sZF9ibG9ja3NbaV0ua2V5XSA9IGk7XG5cdGNvbnN0IG5ld19ibG9ja3MgPSBbXTtcblx0Y29uc3QgbmV3X2xvb2t1cCA9IG5ldyBNYXAoKTtcblx0Y29uc3QgZGVsdGFzID0gbmV3IE1hcCgpO1xuXHRjb25zdCB1cGRhdGVzID0gW107XG5cdGkgPSBuO1xuXHR3aGlsZSAoaS0tKSB7XG5cdFx0Y29uc3QgY2hpbGRfY3R4ID0gZ2V0X2NvbnRleHQoY3R4LCBsaXN0LCBpKTtcblx0XHRjb25zdCBrZXkgPSBnZXRfa2V5KGNoaWxkX2N0eCk7XG5cdFx0bGV0IGJsb2NrID0gbG9va3VwLmdldChrZXkpO1xuXHRcdGlmICghYmxvY2spIHtcblx0XHRcdGJsb2NrID0gY3JlYXRlX2VhY2hfYmxvY2soa2V5LCBjaGlsZF9jdHgpO1xuXHRcdFx0YmxvY2suYygpO1xuXHRcdH0gZWxzZSBpZiAoZHluYW1pYykge1xuXHRcdFx0Ly8gZGVmZXIgdXBkYXRlcyB1bnRpbCBhbGwgdGhlIERPTSBzaHVmZmxpbmcgaXMgZG9uZVxuXHRcdFx0dXBkYXRlcy5wdXNoKCgpID0+IGJsb2NrLnAoY2hpbGRfY3R4LCBkaXJ0eSkpO1xuXHRcdH1cblx0XHRuZXdfbG9va3VwLnNldChrZXksIChuZXdfYmxvY2tzW2ldID0gYmxvY2spKTtcblx0XHRpZiAoa2V5IGluIG9sZF9pbmRleGVzKSBkZWx0YXMuc2V0KGtleSwgTWF0aC5hYnMoaSAtIG9sZF9pbmRleGVzW2tleV0pKTtcblx0fVxuXHRjb25zdCB3aWxsX21vdmUgPSBuZXcgU2V0KCk7XG5cdGNvbnN0IGRpZF9tb3ZlID0gbmV3IFNldCgpO1xuXHQvKiogQHJldHVybnMge3ZvaWR9ICovXG5cdGZ1bmN0aW9uIGluc2VydChibG9jaykge1xuXHRcdHRyYW5zaXRpb25faW4oYmxvY2ssIDEpO1xuXHRcdGJsb2NrLm0obm9kZSwgbmV4dCk7XG5cdFx0bG9va3VwLnNldChibG9jay5rZXksIGJsb2NrKTtcblx0XHRuZXh0ID0gYmxvY2suZmlyc3Q7XG5cdFx0bi0tO1xuXHR9XG5cdHdoaWxlIChvICYmIG4pIHtcblx0XHRjb25zdCBuZXdfYmxvY2sgPSBuZXdfYmxvY2tzW24gLSAxXTtcblx0XHRjb25zdCBvbGRfYmxvY2sgPSBvbGRfYmxvY2tzW28gLSAxXTtcblx0XHRjb25zdCBuZXdfa2V5ID0gbmV3X2Jsb2NrLmtleTtcblx0XHRjb25zdCBvbGRfa2V5ID0gb2xkX2Jsb2NrLmtleTtcblx0XHRpZiAobmV3X2Jsb2NrID09PSBvbGRfYmxvY2spIHtcblx0XHRcdC8vIGRvIG5vdGhpbmdcblx0XHRcdG5leHQgPSBuZXdfYmxvY2suZmlyc3Q7XG5cdFx0XHRvLS07XG5cdFx0XHRuLS07XG5cdFx0fSBlbHNlIGlmICghbmV3X2xvb2t1cC5oYXMob2xkX2tleSkpIHtcblx0XHRcdC8vIHJlbW92ZSBvbGQgYmxvY2tcblx0XHRcdGRlc3Ryb3kob2xkX2Jsb2NrLCBsb29rdXApO1xuXHRcdFx0by0tO1xuXHRcdH0gZWxzZSBpZiAoIWxvb2t1cC5oYXMobmV3X2tleSkgfHwgd2lsbF9tb3ZlLmhhcyhuZXdfa2V5KSkge1xuXHRcdFx0aW5zZXJ0KG5ld19ibG9jayk7XG5cdFx0fSBlbHNlIGlmIChkaWRfbW92ZS5oYXMob2xkX2tleSkpIHtcblx0XHRcdG8tLTtcblx0XHR9IGVsc2UgaWYgKGRlbHRhcy5nZXQobmV3X2tleSkgPiBkZWx0YXMuZ2V0KG9sZF9rZXkpKSB7XG5cdFx0XHRkaWRfbW92ZS5hZGQobmV3X2tleSk7XG5cdFx0XHRpbnNlcnQobmV3X2Jsb2NrKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0d2lsbF9tb3ZlLmFkZChvbGRfa2V5KTtcblx0XHRcdG8tLTtcblx0XHR9XG5cdH1cblx0d2hpbGUgKG8tLSkge1xuXHRcdGNvbnN0IG9sZF9ibG9jayA9IG9sZF9ibG9ja3Nbb107XG5cdFx0aWYgKCFuZXdfbG9va3VwLmhhcyhvbGRfYmxvY2sua2V5KSkgZGVzdHJveShvbGRfYmxvY2ssIGxvb2t1cCk7XG5cdH1cblx0d2hpbGUgKG4pIGluc2VydChuZXdfYmxvY2tzW24gLSAxXSk7XG5cdHJ1bl9hbGwodXBkYXRlcyk7XG5cdHJldHVybiBuZXdfYmxvY2tzO1xufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVfZWFjaF9rZXlzKGN0eCwgbGlzdCwgZ2V0X2NvbnRleHQsIGdldF9rZXkpIHtcblx0Y29uc3Qga2V5cyA9IG5ldyBNYXAoKTtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0Y29uc3Qga2V5ID0gZ2V0X2tleShnZXRfY29udGV4dChjdHgsIGxpc3QsIGkpKTtcblx0XHRpZiAoa2V5cy5oYXMoa2V5KSkge1xuXHRcdFx0bGV0IHZhbHVlID0gJyc7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR2YWx1ZSA9IGB3aXRoIHZhbHVlICcke1N0cmluZyhrZXkpfScgYDtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0Ly8gY2FuJ3Qgc3RyaW5naWZ5XG5cdFx0XHR9XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdGBDYW5ub3QgaGF2ZSBkdXBsaWNhdGUga2V5cyBpbiBhIGtleWVkIGVhY2g6IEtleXMgYXQgaW5kZXggJHtrZXlzLmdldChcblx0XHRcdFx0XHRrZXlcblx0XHRcdFx0KX0gYW5kICR7aX0gJHt2YWx1ZX1hcmUgZHVwbGljYXRlc2Bcblx0XHRcdCk7XG5cdFx0fVxuXHRcdGtleXMuc2V0KGtleSwgaSk7XG5cdH1cbn1cbiIsICJjb25zdCBfYm9vbGVhbl9hdHRyaWJ1dGVzID0gLyoqIEB0eXBlIHtjb25zdH0gKi8gKFtcblx0J2FsbG93ZnVsbHNjcmVlbicsXG5cdCdhbGxvd3BheW1lbnRyZXF1ZXN0Jyxcblx0J2FzeW5jJyxcblx0J2F1dG9mb2N1cycsXG5cdCdhdXRvcGxheScsXG5cdCdjaGVja2VkJyxcblx0J2NvbnRyb2xzJyxcblx0J2RlZmF1bHQnLFxuXHQnZGVmZXInLFxuXHQnZGlzYWJsZWQnLFxuXHQnZm9ybW5vdmFsaWRhdGUnLFxuXHQnaGlkZGVuJyxcblx0J2luZXJ0Jyxcblx0J2lzbWFwJyxcblx0J2xvb3AnLFxuXHQnbXVsdGlwbGUnLFxuXHQnbXV0ZWQnLFxuXHQnbm9tb2R1bGUnLFxuXHQnbm92YWxpZGF0ZScsXG5cdCdvcGVuJyxcblx0J3BsYXlzaW5saW5lJyxcblx0J3JlYWRvbmx5Jyxcblx0J3JlcXVpcmVkJyxcblx0J3JldmVyc2VkJyxcblx0J3NlbGVjdGVkJ1xuXSk7XG5cbi8qKlxuICogTGlzdCBvZiBIVE1MIGJvb2xlYW4gYXR0cmlidXRlcyAoZS5nLiBgPGlucHV0IGRpc2FibGVkPmApLlxuICogU291cmNlOiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmRpY2VzLmh0bWxcbiAqXG4gKiBAdHlwZSB7U2V0PHN0cmluZz59XG4gKi9cbmV4cG9ydCBjb25zdCBib29sZWFuX2F0dHJpYnV0ZXMgPSBuZXcgU2V0KFsuLi5fYm9vbGVhbl9hdHRyaWJ1dGVzXSk7XG5cbi8qKiBAdHlwZWRlZiB7dHlwZW9mIF9ib29sZWFuX2F0dHJpYnV0ZXNbbnVtYmVyXX0gQm9vbGVhbkF0dHJpYnV0ZXMgKi9cbiIsICJpbXBvcnQge1xuXHRhZGRfcmVuZGVyX2NhbGxiYWNrLFxuXHRmbHVzaCxcblx0Zmx1c2hfcmVuZGVyX2NhbGxiYWNrcyxcblx0c2NoZWR1bGVfdXBkYXRlLFxuXHRkaXJ0eV9jb21wb25lbnRzXG59IGZyb20gJy4vc2NoZWR1bGVyLmpzJztcbmltcG9ydCB7IGN1cnJlbnRfY29tcG9uZW50LCBzZXRfY3VycmVudF9jb21wb25lbnQgfSBmcm9tICcuL2xpZmVjeWNsZS5qcyc7XG5pbXBvcnQgeyBibGFua19vYmplY3QsIGlzX2VtcHR5LCBpc19mdW5jdGlvbiwgcnVuLCBydW5fYWxsLCBub29wIH0gZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQge1xuXHRjaGlsZHJlbixcblx0ZGV0YWNoLFxuXHRzdGFydF9oeWRyYXRpbmcsXG5cdGVuZF9oeWRyYXRpbmcsXG5cdGdldF9jdXN0b21fZWxlbWVudHNfc2xvdHMsXG5cdGluc2VydCxcblx0ZWxlbWVudCxcblx0YXR0clxufSBmcm9tICcuL2RvbS5qcyc7XG5pbXBvcnQgeyB0cmFuc2l0aW9uX2luIH0gZnJvbSAnLi90cmFuc2l0aW9ucy5qcyc7XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kKGNvbXBvbmVudCwgbmFtZSwgY2FsbGJhY2spIHtcblx0Y29uc3QgaW5kZXggPSBjb21wb25lbnQuJCQucHJvcHNbbmFtZV07XG5cdGlmIChpbmRleCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0Y29tcG9uZW50LiQkLmJvdW5kW2luZGV4XSA9IGNhbGxiYWNrO1xuXHRcdGNhbGxiYWNrKGNvbXBvbmVudC4kJC5jdHhbaW5kZXhdKTtcblx0fVxufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlX2NvbXBvbmVudChibG9jaykge1xuXHRibG9jayAmJiBibG9jay5jKCk7XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGFpbV9jb21wb25lbnQoYmxvY2ssIHBhcmVudF9ub2Rlcykge1xuXHRibG9jayAmJiBibG9jay5sKHBhcmVudF9ub2Rlcyk7XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBtb3VudF9jb21wb25lbnQoY29tcG9uZW50LCB0YXJnZXQsIGFuY2hvcikge1xuXHRjb25zdCB7IGZyYWdtZW50LCBhZnRlcl91cGRhdGUgfSA9IGNvbXBvbmVudC4kJDtcblx0ZnJhZ21lbnQgJiYgZnJhZ21lbnQubSh0YXJnZXQsIGFuY2hvcik7XG5cdC8vIG9uTW91bnQgaGFwcGVucyBiZWZvcmUgdGhlIGluaXRpYWwgYWZ0ZXJVcGRhdGVcblx0YWRkX3JlbmRlcl9jYWxsYmFjaygoKSA9PiB7XG5cdFx0Y29uc3QgbmV3X29uX2Rlc3Ryb3kgPSBjb21wb25lbnQuJCQub25fbW91bnQubWFwKHJ1bikuZmlsdGVyKGlzX2Z1bmN0aW9uKTtcblx0XHQvLyBpZiB0aGUgY29tcG9uZW50IHdhcyBkZXN0cm95ZWQgaW1tZWRpYXRlbHlcblx0XHQvLyBpdCB3aWxsIHVwZGF0ZSB0aGUgYCQkLm9uX2Rlc3Ryb3lgIHJlZmVyZW5jZSB0byBgbnVsbGAuXG5cdFx0Ly8gdGhlIGRlc3RydWN0dXJlZCBvbl9kZXN0cm95IG1heSBzdGlsbCByZWZlcmVuY2UgdG8gdGhlIG9sZCBhcnJheVxuXHRcdGlmIChjb21wb25lbnQuJCQub25fZGVzdHJveSkge1xuXHRcdFx0Y29tcG9uZW50LiQkLm9uX2Rlc3Ryb3kucHVzaCguLi5uZXdfb25fZGVzdHJveSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEVkZ2UgY2FzZSAtIGNvbXBvbmVudCB3YXMgZGVzdHJveWVkIGltbWVkaWF0ZWx5LFxuXHRcdFx0Ly8gbW9zdCBsaWtlbHkgYXMgYSByZXN1bHQgb2YgYSBiaW5kaW5nIGluaXRpYWxpc2luZ1xuXHRcdFx0cnVuX2FsbChuZXdfb25fZGVzdHJveSk7XG5cdFx0fVxuXHRcdGNvbXBvbmVudC4kJC5vbl9tb3VudCA9IFtdO1xuXHR9KTtcblx0YWZ0ZXJfdXBkYXRlLmZvckVhY2goYWRkX3JlbmRlcl9jYWxsYmFjayk7XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXN0cm95X2NvbXBvbmVudChjb21wb25lbnQsIGRldGFjaGluZykge1xuXHRjb25zdCAkJCA9IGNvbXBvbmVudC4kJDtcblx0aWYgKCQkLmZyYWdtZW50ICE9PSBudWxsKSB7XG5cdFx0Zmx1c2hfcmVuZGVyX2NhbGxiYWNrcygkJC5hZnRlcl91cGRhdGUpO1xuXHRcdHJ1bl9hbGwoJCQub25fZGVzdHJveSk7XG5cdFx0JCQuZnJhZ21lbnQgJiYgJCQuZnJhZ21lbnQuZChkZXRhY2hpbmcpO1xuXHRcdC8vIFRPRE8gbnVsbCBvdXQgb3RoZXIgcmVmcywgaW5jbHVkaW5nIGNvbXBvbmVudC4kJCAoYnV0IG5lZWQgdG9cblx0XHQvLyBwcmVzZXJ2ZSBmaW5hbCBzdGF0ZT8pXG5cdFx0JCQub25fZGVzdHJveSA9ICQkLmZyYWdtZW50ID0gbnVsbDtcblx0XHQkJC5jdHggPSBbXTtcblx0fVxufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5mdW5jdGlvbiBtYWtlX2RpcnR5KGNvbXBvbmVudCwgaSkge1xuXHRpZiAoY29tcG9uZW50LiQkLmRpcnR5WzBdID09PSAtMSkge1xuXHRcdGRpcnR5X2NvbXBvbmVudHMucHVzaChjb21wb25lbnQpO1xuXHRcdHNjaGVkdWxlX3VwZGF0ZSgpO1xuXHRcdGNvbXBvbmVudC4kJC5kaXJ0eS5maWxsKDApO1xuXHR9XG5cdGNvbXBvbmVudC4kJC5kaXJ0eVsoaSAvIDMxKSB8IDBdIHw9IDEgPDwgaSAlIDMxO1xufVxuXG4vLyBUT0RPOiBEb2N1bWVudCB0aGUgb3RoZXIgcGFyYW1zXG4vKipcbiAqIEBwYXJhbSB7U3ZlbHRlQ29tcG9uZW50fSBjb21wb25lbnRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3B1YmxpYy5qcycpLkNvbXBvbmVudENvbnN0cnVjdG9yT3B0aW9uc30gb3B0aW9uc1xuICpcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3V0aWxzLmpzJylbJ25vdF9lcXVhbCddfSBub3RfZXF1YWwgVXNlZCB0byBjb21wYXJlIHByb3BzIGFuZCBzdGF0ZSB2YWx1ZXMuXG4gKiBAcGFyYW0geyh0YXJnZXQ6IEVsZW1lbnQgfCBTaGFkb3dSb290KSA9PiB2b2lkfSBbYXBwZW5kX3N0eWxlc10gRnVuY3Rpb24gdGhhdCBhcHBlbmRzIHN0eWxlcyB0byB0aGUgRE9NIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBmaXJzdCBpbml0aWFsaXNlZC5cbiAqIFRoaXMgd2lsbCBiZSB0aGUgYGFkZF9jc3NgIGZ1bmN0aW9uIGZyb20gdGhlIGNvbXBpbGVkIGNvbXBvbmVudC5cbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluaXQoXG5cdGNvbXBvbmVudCxcblx0b3B0aW9ucyxcblx0aW5zdGFuY2UsXG5cdGNyZWF0ZV9mcmFnbWVudCxcblx0bm90X2VxdWFsLFxuXHRwcm9wcyxcblx0YXBwZW5kX3N0eWxlcyA9IG51bGwsXG5cdGRpcnR5ID0gWy0xXVxuKSB7XG5cdGNvbnN0IHBhcmVudF9jb21wb25lbnQgPSBjdXJyZW50X2NvbXBvbmVudDtcblx0c2V0X2N1cnJlbnRfY29tcG9uZW50KGNvbXBvbmVudCk7XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL3ByaXZhdGUuanMnKS5UJCR9ICovXG5cdGNvbnN0ICQkID0gKGNvbXBvbmVudC4kJCA9IHtcblx0XHRmcmFnbWVudDogbnVsbCxcblx0XHRjdHg6IFtdLFxuXHRcdC8vIHN0YXRlXG5cdFx0cHJvcHMsXG5cdFx0dXBkYXRlOiBub29wLFxuXHRcdG5vdF9lcXVhbCxcblx0XHRib3VuZDogYmxhbmtfb2JqZWN0KCksXG5cdFx0Ly8gbGlmZWN5Y2xlXG5cdFx0b25fbW91bnQ6IFtdLFxuXHRcdG9uX2Rlc3Ryb3k6IFtdLFxuXHRcdG9uX2Rpc2Nvbm5lY3Q6IFtdLFxuXHRcdGJlZm9yZV91cGRhdGU6IFtdLFxuXHRcdGFmdGVyX3VwZGF0ZTogW10sXG5cdFx0Y29udGV4dDogbmV3IE1hcChvcHRpb25zLmNvbnRleHQgfHwgKHBhcmVudF9jb21wb25lbnQgPyBwYXJlbnRfY29tcG9uZW50LiQkLmNvbnRleHQgOiBbXSkpLFxuXHRcdC8vIGV2ZXJ5dGhpbmcgZWxzZVxuXHRcdGNhbGxiYWNrczogYmxhbmtfb2JqZWN0KCksXG5cdFx0ZGlydHksXG5cdFx0c2tpcF9ib3VuZDogZmFsc2UsXG5cdFx0cm9vdDogb3B0aW9ucy50YXJnZXQgfHwgcGFyZW50X2NvbXBvbmVudC4kJC5yb290XG5cdH0pO1xuXHRhcHBlbmRfc3R5bGVzICYmIGFwcGVuZF9zdHlsZXMoJCQucm9vdCk7XG5cdGxldCByZWFkeSA9IGZhbHNlO1xuXHQkJC5jdHggPSBpbnN0YW5jZVxuXHRcdD8gaW5zdGFuY2UoY29tcG9uZW50LCBvcHRpb25zLnByb3BzIHx8IHt9LCAoaSwgcmV0LCAuLi5yZXN0KSA9PiB7XG5cdFx0XHRcdGNvbnN0IHZhbHVlID0gcmVzdC5sZW5ndGggPyByZXN0WzBdIDogcmV0O1xuXHRcdFx0XHRpZiAoJCQuY3R4ICYmIG5vdF9lcXVhbCgkJC5jdHhbaV0sICgkJC5jdHhbaV0gPSB2YWx1ZSkpKSB7XG5cdFx0XHRcdFx0aWYgKCEkJC5za2lwX2JvdW5kICYmICQkLmJvdW5kW2ldKSAkJC5ib3VuZFtpXSh2YWx1ZSk7XG5cdFx0XHRcdFx0aWYgKHJlYWR5KSBtYWtlX2RpcnR5KGNvbXBvbmVudCwgaSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHQgIH0pXG5cdFx0OiBbXTtcblx0JCQudXBkYXRlKCk7XG5cdHJlYWR5ID0gdHJ1ZTtcblx0cnVuX2FsbCgkJC5iZWZvcmVfdXBkYXRlKTtcblx0Ly8gYGZhbHNlYCBhcyBhIHNwZWNpYWwgY2FzZSBvZiBubyBET00gY29tcG9uZW50XG5cdCQkLmZyYWdtZW50ID0gY3JlYXRlX2ZyYWdtZW50ID8gY3JlYXRlX2ZyYWdtZW50KCQkLmN0eCkgOiBmYWxzZTtcblx0aWYgKG9wdGlvbnMudGFyZ2V0KSB7XG5cdFx0aWYgKG9wdGlvbnMuaHlkcmF0ZSkge1xuXHRcdFx0c3RhcnRfaHlkcmF0aW5nKCk7XG5cdFx0XHQvLyBUT0RPOiB3aGF0IGlzIHRoZSBjb3JyZWN0IHR5cGUgaGVyZT9cblx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRcdGNvbnN0IG5vZGVzID0gY2hpbGRyZW4ob3B0aW9ucy50YXJnZXQpO1xuXHRcdFx0JCQuZnJhZ21lbnQgJiYgJCQuZnJhZ21lbnQubChub2Rlcyk7XG5cdFx0XHRub2Rlcy5mb3JFYWNoKGRldGFjaCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG5cdFx0XHQkJC5mcmFnbWVudCAmJiAkJC5mcmFnbWVudC5jKCk7XG5cdFx0fVxuXHRcdGlmIChvcHRpb25zLmludHJvKSB0cmFuc2l0aW9uX2luKGNvbXBvbmVudC4kJC5mcmFnbWVudCk7XG5cdFx0bW91bnRfY29tcG9uZW50KGNvbXBvbmVudCwgb3B0aW9ucy50YXJnZXQsIG9wdGlvbnMuYW5jaG9yKTtcblx0XHRlbmRfaHlkcmF0aW5nKCk7XG5cdFx0Zmx1c2goKTtcblx0fVxuXHRzZXRfY3VycmVudF9jb21wb25lbnQocGFyZW50X2NvbXBvbmVudCk7XG59XG5cbmV4cG9ydCBsZXQgU3ZlbHRlRWxlbWVudDtcblxuaWYgKHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRTdmVsdGVFbGVtZW50ID0gY2xhc3MgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG5cdFx0LyoqIFRoZSBTdmVsdGUgY29tcG9uZW50IGNvbnN0cnVjdG9yICovXG5cdFx0JCRjdG9yO1xuXHRcdC8qKiBTbG90cyAqL1xuXHRcdCQkcztcblx0XHQvKiogVGhlIFN2ZWx0ZSBjb21wb25lbnQgaW5zdGFuY2UgKi9cblx0XHQkJGM7XG5cdFx0LyoqIFdoZXRoZXIgb3Igbm90IHRoZSBjdXN0b20gZWxlbWVudCBpcyBjb25uZWN0ZWQgKi9cblx0XHQkJGNuID0gZmFsc2U7XG5cdFx0LyoqIENvbXBvbmVudCBwcm9wcyBkYXRhICovXG5cdFx0JCRkID0ge307XG5cdFx0LyoqIGB0cnVlYCBpZiBjdXJyZW50bHkgaW4gdGhlIHByb2Nlc3Mgb2YgcmVmbGVjdGluZyBjb21wb25lbnQgcHJvcHMgYmFjayB0byBhdHRyaWJ1dGVzICovXG5cdFx0JCRyID0gZmFsc2U7XG5cdFx0LyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBDdXN0b21FbGVtZW50UHJvcERlZmluaXRpb24+fSBQcm9wcyBkZWZpbml0aW9uIChuYW1lLCByZWZsZWN0ZWQsIHR5cGUgZXRjKSAqL1xuXHRcdCQkcF9kID0ge307XG5cdFx0LyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBGdW5jdGlvbltdPn0gRXZlbnQgbGlzdGVuZXJzICovXG5cdFx0JCRsID0ge307XG5cdFx0LyoqIEB0eXBlIHtNYXA8RnVuY3Rpb24sIEZ1bmN0aW9uPn0gRXZlbnQgbGlzdGVuZXIgdW5zdWJzY3JpYmUgZnVuY3Rpb25zICovXG5cdFx0JCRsX3UgPSBuZXcgTWFwKCk7XG5cblx0XHRjb25zdHJ1Y3RvcigkJGNvbXBvbmVudEN0b3IsICQkc2xvdHMsIHVzZV9zaGFkb3dfZG9tKSB7XG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0dGhpcy4kJGN0b3IgPSAkJGNvbXBvbmVudEN0b3I7XG5cdFx0XHR0aGlzLiQkcyA9ICQkc2xvdHM7XG5cdFx0XHRpZiAodXNlX3NoYWRvd19kb20pIHtcblx0XHRcdFx0dGhpcy5hdHRhY2hTaGFkb3coeyBtb2RlOiAnb3BlbicgfSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0YWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuXHRcdFx0Ly8gV2UgY2FuJ3QgZGV0ZXJtaW5lIHVwZnJvbnQgaWYgdGhlIGV2ZW50IGlzIGEgY3VzdG9tIGV2ZW50IG9yIG5vdCwgc28gd2UgaGF2ZSB0b1xuXHRcdFx0Ly8gbGlzdGVuIHRvIGJvdGguIElmIHNvbWVvbmUgdXNlcyBhIGN1c3RvbSBldmVudCB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgYSByZWd1bGFyXG5cdFx0XHQvLyBicm93c2VyIGV2ZW50LCB0aGlzIGZpcmVzIHR3aWNlIC0gd2UgY2FuJ3QgYXZvaWQgdGhhdC5cblx0XHRcdHRoaXMuJCRsW3R5cGVdID0gdGhpcy4kJGxbdHlwZV0gfHwgW107XG5cdFx0XHR0aGlzLiQkbFt0eXBlXS5wdXNoKGxpc3RlbmVyKTtcblx0XHRcdGlmICh0aGlzLiQkYykge1xuXHRcdFx0XHRjb25zdCB1bnN1YiA9IHRoaXMuJCRjLiRvbih0eXBlLCBsaXN0ZW5lcik7XG5cdFx0XHRcdHRoaXMuJCRsX3Uuc2V0KGxpc3RlbmVyLCB1bnN1Yik7XG5cdFx0XHR9XG5cdFx0XHRzdXBlci5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKTtcblx0XHR9XG5cblx0XHRyZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG5cdFx0XHRzdXBlci5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKTtcblx0XHRcdGlmICh0aGlzLiQkYykge1xuXHRcdFx0XHRjb25zdCB1bnN1YiA9IHRoaXMuJCRsX3UuZ2V0KGxpc3RlbmVyKTtcblx0XHRcdFx0aWYgKHVuc3ViKSB7XG5cdFx0XHRcdFx0dW5zdWIoKTtcblx0XHRcdFx0XHR0aGlzLiQkbF91LmRlbGV0ZShsaXN0ZW5lcik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLiQkbFt0eXBlXSkge1xuXHRcdFx0XHRjb25zdCBpZHggPSB0aGlzLiQkbFt0eXBlXS5pbmRleE9mKGxpc3RlbmVyKTtcblx0XHRcdFx0aWYgKGlkeCA+PSAwKSB7XG5cdFx0XHRcdFx0dGhpcy4kJGxbdHlwZV0uc3BsaWNlKGlkeCwgMSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRhc3luYyBjb25uZWN0ZWRDYWxsYmFjaygpIHtcblx0XHRcdHRoaXMuJCRjbiA9IHRydWU7XG5cdFx0XHRpZiAoIXRoaXMuJCRjKSB7XG5cdFx0XHRcdC8vIFdlIHdhaXQgb25lIHRpY2sgdG8gbGV0IHBvc3NpYmxlIGNoaWxkIHNsb3QgZWxlbWVudHMgYmUgY3JlYXRlZC9tb3VudGVkXG5cdFx0XHRcdGF3YWl0IFByb21pc2UucmVzb2x2ZSgpO1xuXHRcdFx0XHRpZiAoIXRoaXMuJCRjbiB8fCB0aGlzLiQkYykge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRmdW5jdGlvbiBjcmVhdGVfc2xvdChuYW1lKSB7XG5cdFx0XHRcdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdFx0XHRcdGxldCBub2RlO1xuXHRcdFx0XHRcdFx0Y29uc3Qgb2JqID0ge1xuXHRcdFx0XHRcdFx0XHRjOiBmdW5jdGlvbiBjcmVhdGUoKSB7XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW1lbnQoJ3Nsb3QnKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAobmFtZSAhPT0gJ2RlZmF1bHQnKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRhdHRyKG5vZGUsICduYW1lJywgbmFtZSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHQvKipcblx0XHRcdFx0XHRcdFx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0XG5cdFx0XHRcdFx0XHRcdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IFthbmNob3JdXG5cdFx0XHRcdFx0XHRcdCAqL1xuXHRcdFx0XHRcdFx0XHRtOiBmdW5jdGlvbiBtb3VudCh0YXJnZXQsIGFuY2hvcikge1xuXHRcdFx0XHRcdFx0XHRcdGluc2VydCh0YXJnZXQsIG5vZGUsIGFuY2hvcik7XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGQ6IGZ1bmN0aW9uIGRlc3Ryb3koZGV0YWNoaW5nKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGRldGFjaGluZykge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGV0YWNoKG5vZGUpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdHJldHVybiBvYmo7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb25zdCAkJHNsb3RzID0ge307XG5cdFx0XHRcdGNvbnN0IGV4aXN0aW5nX3Nsb3RzID0gZ2V0X2N1c3RvbV9lbGVtZW50c19zbG90cyh0aGlzKTtcblx0XHRcdFx0Zm9yIChjb25zdCBuYW1lIG9mIHRoaXMuJCRzKSB7XG5cdFx0XHRcdFx0aWYgKG5hbWUgaW4gZXhpc3Rpbmdfc2xvdHMpIHtcblx0XHRcdFx0XHRcdCQkc2xvdHNbbmFtZV0gPSBbY3JlYXRlX3Nsb3QobmFtZSldO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKGNvbnN0IGF0dHJpYnV0ZSBvZiB0aGlzLmF0dHJpYnV0ZXMpIHtcblx0XHRcdFx0XHQvLyB0aGlzLiQkZGF0YSB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgdGhpcy5hdHRyaWJ1dGVzXG5cdFx0XHRcdFx0Y29uc3QgbmFtZSA9IHRoaXMuJCRnX3AoYXR0cmlidXRlLm5hbWUpO1xuXHRcdFx0XHRcdGlmICghKG5hbWUgaW4gdGhpcy4kJGQpKSB7XG5cdFx0XHRcdFx0XHR0aGlzLiQkZFtuYW1lXSA9IGdldF9jdXN0b21fZWxlbWVudF92YWx1ZShuYW1lLCBhdHRyaWJ1dGUudmFsdWUsIHRoaXMuJCRwX2QsICd0b1Byb3AnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gUG9ydCBvdmVyIHByb3BzIHRoYXQgd2VyZSBzZXQgcHJvZ3JhbW1hdGljYWxseSBiZWZvcmUgY2Ugd2FzIGluaXRpYWxpemVkXG5cdFx0XHRcdGZvciAoY29uc3Qga2V5IGluIHRoaXMuJCRwX2QpIHtcblx0XHRcdFx0XHRpZiAoIShrZXkgaW4gdGhpcy4kJGQpICYmIHRoaXNba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHR0aGlzLiQkZFtrZXldID0gdGhpc1trZXldOyAvLyBkb24ndCB0cmFuc2Zvcm0sIHRoZXNlIHdlcmUgc2V0IHRocm91Z2ggSmF2YVNjcmlwdFxuXHRcdFx0XHRcdFx0ZGVsZXRlIHRoaXNba2V5XTsgLy8gcmVtb3ZlIHRoZSBwcm9wZXJ0eSB0aGF0IHNoYWRvd3MgdGhlIGdldHRlci9zZXR0ZXJcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy4kJGMgPSBuZXcgdGhpcy4kJGN0b3Ioe1xuXHRcdFx0XHRcdHRhcmdldDogdGhpcy5zaGFkb3dSb290IHx8IHRoaXMsXG5cdFx0XHRcdFx0cHJvcHM6IHtcblx0XHRcdFx0XHRcdC4uLnRoaXMuJCRkLFxuXHRcdFx0XHRcdFx0JCRzbG90cyxcblx0XHRcdFx0XHRcdCQkc2NvcGU6IHtcblx0XHRcdFx0XHRcdFx0Y3R4OiBbXVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Ly8gUmVmbGVjdCBjb21wb25lbnQgcHJvcHMgYXMgYXR0cmlidXRlc1xuXHRcdFx0XHRjb25zdCByZWZsZWN0X2F0dHJpYnV0ZXMgPSAoKSA9PiB7XG5cdFx0XHRcdFx0dGhpcy4kJHIgPSB0cnVlO1xuXHRcdFx0XHRcdGZvciAoY29uc3Qga2V5IGluIHRoaXMuJCRwX2QpIHtcblx0XHRcdFx0XHRcdHRoaXMuJCRkW2tleV0gPSB0aGlzLiQkYy4kJC5jdHhbdGhpcy4kJGMuJCQucHJvcHNba2V5XV07XG5cdFx0XHRcdFx0XHRpZiAodGhpcy4kJHBfZFtrZXldLnJlZmxlY3QpIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgYXR0cmlidXRlX3ZhbHVlID0gZ2V0X2N1c3RvbV9lbGVtZW50X3ZhbHVlKFxuXHRcdFx0XHRcdFx0XHRcdGtleSxcblx0XHRcdFx0XHRcdFx0XHR0aGlzLiQkZFtrZXldLFxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuJCRwX2QsXG5cdFx0XHRcdFx0XHRcdFx0J3RvQXR0cmlidXRlJ1xuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRpZiAoYXR0cmlidXRlX3ZhbHVlID09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnJlbW92ZUF0dHJpYnV0ZSh0aGlzLiQkcF9kW2tleV0uYXR0cmlidXRlIHx8IGtleSk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUodGhpcy4kJHBfZFtrZXldLmF0dHJpYnV0ZSB8fCBrZXksIGF0dHJpYnV0ZV92YWx1ZSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy4kJHIgPSBmYWxzZTtcblx0XHRcdFx0fTtcblx0XHRcdFx0dGhpcy4kJGMuJCQuYWZ0ZXJfdXBkYXRlLnB1c2gocmVmbGVjdF9hdHRyaWJ1dGVzKTtcblx0XHRcdFx0cmVmbGVjdF9hdHRyaWJ1dGVzKCk7IC8vIG9uY2UgaW5pdGlhbGx5IGJlY2F1c2UgYWZ0ZXJfdXBkYXRlIGlzIGFkZGVkIHRvbyBsYXRlIGZvciBmaXJzdCByZW5kZXJcblxuXHRcdFx0XHRmb3IgKGNvbnN0IHR5cGUgaW4gdGhpcy4kJGwpIHtcblx0XHRcdFx0XHRmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuJCRsW3R5cGVdKSB7XG5cdFx0XHRcdFx0XHRjb25zdCB1bnN1YiA9IHRoaXMuJCRjLiRvbih0eXBlLCBsaXN0ZW5lcik7XG5cdFx0XHRcdFx0XHR0aGlzLiQkbF91LnNldChsaXN0ZW5lciwgdW5zdWIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLiQkbCA9IHt9O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFdlIGRvbid0IG5lZWQgdGhpcyB3aGVuIHdvcmtpbmcgd2l0aGluIFN2ZWx0ZSBjb2RlLCBidXQgZm9yIGNvbXBhdGliaWxpdHkgb2YgcGVvcGxlIHVzaW5nIHRoaXMgb3V0c2lkZSBvZiBTdmVsdGVcblx0XHQvLyBhbmQgc2V0dGluZyBhdHRyaWJ1dGVzIHRocm91Z2ggc2V0QXR0cmlidXRlIGV0YywgdGhpcyBpcyBoZWxwZnVsXG5cdFx0YXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGF0dHIsIF9vbGRWYWx1ZSwgbmV3VmFsdWUpIHtcblx0XHRcdGlmICh0aGlzLiQkcikgcmV0dXJuO1xuXHRcdFx0YXR0ciA9IHRoaXMuJCRnX3AoYXR0cik7XG5cdFx0XHR0aGlzLiQkZFthdHRyXSA9IGdldF9jdXN0b21fZWxlbWVudF92YWx1ZShhdHRyLCBuZXdWYWx1ZSwgdGhpcy4kJHBfZCwgJ3RvUHJvcCcpO1xuXHRcdFx0dGhpcy4kJGM/LiRzZXQoeyBbYXR0cl06IHRoaXMuJCRkW2F0dHJdIH0pO1xuXHRcdH1cblxuXHRcdGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuXHRcdFx0dGhpcy4kJGNuID0gZmFsc2U7XG5cdFx0XHQvLyBJbiBhIG1pY3JvdGFzaywgYmVjYXVzZSB0aGlzIGNvdWxkIGJlIGEgbW92ZSB3aXRoaW4gdGhlIERPTVxuXHRcdFx0UHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG5cdFx0XHRcdGlmICghdGhpcy4kJGNuICYmIHRoaXMuJCRjKSB7XG5cdFx0XHRcdFx0dGhpcy4kJGMuJGRlc3Ryb3koKTtcblx0XHRcdFx0XHR0aGlzLiQkYyA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0JCRnX3AoYXR0cmlidXRlX25hbWUpIHtcblx0XHRcdHJldHVybiAoXG5cdFx0XHRcdE9iamVjdC5rZXlzKHRoaXMuJCRwX2QpLmZpbmQoXG5cdFx0XHRcdFx0KGtleSkgPT5cblx0XHRcdFx0XHRcdHRoaXMuJCRwX2Rba2V5XS5hdHRyaWJ1dGUgPT09IGF0dHJpYnV0ZV9uYW1lIHx8XG5cdFx0XHRcdFx0XHQoIXRoaXMuJCRwX2Rba2V5XS5hdHRyaWJ1dGUgJiYga2V5LnRvTG93ZXJDYXNlKCkgPT09IGF0dHJpYnV0ZV9uYW1lKVxuXHRcdFx0XHQpIHx8IGF0dHJpYnV0ZV9uYW1lXG5cdFx0XHQpO1xuXHRcdH1cblx0fTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcFxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIEN1c3RvbUVsZW1lbnRQcm9wRGVmaW5pdGlvbj59IHByb3BzX2RlZmluaXRpb25cbiAqIEBwYXJhbSB7J3RvQXR0cmlidXRlJyB8ICd0b1Byb3AnfSBbdHJhbnNmb3JtXVxuICovXG5mdW5jdGlvbiBnZXRfY3VzdG9tX2VsZW1lbnRfdmFsdWUocHJvcCwgdmFsdWUsIHByb3BzX2RlZmluaXRpb24sIHRyYW5zZm9ybSkge1xuXHRjb25zdCB0eXBlID0gcHJvcHNfZGVmaW5pdGlvbltwcm9wXT8udHlwZTtcblx0dmFsdWUgPSB0eXBlID09PSAnQm9vbGVhbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbicgPyB2YWx1ZSAhPSBudWxsIDogdmFsdWU7XG5cdGlmICghdHJhbnNmb3JtIHx8ICFwcm9wc19kZWZpbml0aW9uW3Byb3BdKSB7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9IGVsc2UgaWYgKHRyYW5zZm9ybSA9PT0gJ3RvQXR0cmlidXRlJykge1xuXHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0Y2FzZSAnT2JqZWN0Jzpcblx0XHRcdGNhc2UgJ0FycmF5Jzpcblx0XHRcdFx0cmV0dXJuIHZhbHVlID09IG51bGwgPyBudWxsIDogSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuXHRcdFx0Y2FzZSAnQm9vbGVhbic6XG5cdFx0XHRcdHJldHVybiB2YWx1ZSA/ICcnIDogbnVsbDtcblx0XHRcdGNhc2UgJ051bWJlcic6XG5cdFx0XHRcdHJldHVybiB2YWx1ZSA9PSBudWxsID8gbnVsbCA6IHZhbHVlO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdGNhc2UgJ09iamVjdCc6XG5cdFx0XHRjYXNlICdBcnJheSc6XG5cdFx0XHRcdHJldHVybiB2YWx1ZSAmJiBKU09OLnBhcnNlKHZhbHVlKTtcblx0XHRcdGNhc2UgJ0Jvb2xlYW4nOlxuXHRcdFx0XHRyZXR1cm4gdmFsdWU7IC8vIGNvbnZlcnNpb24gYWxyZWFkeSBoYW5kbGVkIGFib3ZlXG5cdFx0XHRjYXNlICdOdW1iZXInOlxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgIT0gbnVsbCA/ICt2YWx1ZSA6IHZhbHVlO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICpcbiAqIFR1cm4gYSBTdmVsdGUgY29tcG9uZW50IGludG8gYSBjdXN0b20gZWxlbWVudC5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3B1YmxpYy5qcycpLkNvbXBvbmVudFR5cGV9IENvbXBvbmVudCAgQSBTdmVsdGUgY29tcG9uZW50IGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIEN1c3RvbUVsZW1lbnRQcm9wRGVmaW5pdGlvbj59IHByb3BzX2RlZmluaXRpb24gIFRoZSBwcm9wcyB0byBvYnNlcnZlXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBzbG90cyAgVGhlIHNsb3RzIHRvIGNyZWF0ZVxuICogQHBhcmFtIHtzdHJpbmdbXX0gYWNjZXNzb3JzICBPdGhlciBhY2Nlc3NvcnMgYmVzaWRlcyB0aGUgb25lcyBmb3IgcHJvcHMgdGhlIGNvbXBvbmVudCBoYXNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdXNlX3NoYWRvd19kb20gIFdoZXRoZXIgdG8gdXNlIHNoYWRvdyBET01cbiAqIEBwYXJhbSB7KGNlOiBuZXcgKCkgPT4gSFRNTEVsZW1lbnQpID0+IG5ldyAoKSA9PiBIVE1MRWxlbWVudH0gW2V4dGVuZF1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZV9jdXN0b21fZWxlbWVudChcblx0Q29tcG9uZW50LFxuXHRwcm9wc19kZWZpbml0aW9uLFxuXHRzbG90cyxcblx0YWNjZXNzb3JzLFxuXHR1c2Vfc2hhZG93X2RvbSxcblx0ZXh0ZW5kXG4pIHtcblx0bGV0IENsYXNzID0gY2xhc3MgZXh0ZW5kcyBTdmVsdGVFbGVtZW50IHtcblx0XHRjb25zdHJ1Y3RvcigpIHtcblx0XHRcdHN1cGVyKENvbXBvbmVudCwgc2xvdHMsIHVzZV9zaGFkb3dfZG9tKTtcblx0XHRcdHRoaXMuJCRwX2QgPSBwcm9wc19kZWZpbml0aW9uO1xuXHRcdH1cblx0XHRzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcblx0XHRcdHJldHVybiBPYmplY3Qua2V5cyhwcm9wc19kZWZpbml0aW9uKS5tYXAoKGtleSkgPT5cblx0XHRcdFx0KHByb3BzX2RlZmluaXRpb25ba2V5XS5hdHRyaWJ1dGUgfHwga2V5KS50b0xvd2VyQ2FzZSgpXG5cdFx0XHQpO1xuXHRcdH1cblx0fTtcblx0T2JqZWN0LmtleXMocHJvcHNfZGVmaW5pdGlvbikuZm9yRWFjaCgocHJvcCkgPT4ge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDbGFzcy5wcm90b3R5cGUsIHByb3AsIHtcblx0XHRcdGdldCgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuJCRjICYmIHByb3AgaW4gdGhpcy4kJGMgPyB0aGlzLiQkY1twcm9wXSA6IHRoaXMuJCRkW3Byb3BdO1xuXHRcdFx0fSxcblx0XHRcdHNldCh2YWx1ZSkge1xuXHRcdFx0XHR2YWx1ZSA9IGdldF9jdXN0b21fZWxlbWVudF92YWx1ZShwcm9wLCB2YWx1ZSwgcHJvcHNfZGVmaW5pdGlvbik7XG5cdFx0XHRcdHRoaXMuJCRkW3Byb3BdID0gdmFsdWU7XG5cdFx0XHRcdHRoaXMuJCRjPy4kc2V0KHsgW3Byb3BdOiB2YWx1ZSB9KTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG5cdGFjY2Vzc29ycy5mb3JFYWNoKChhY2Nlc3NvcikgPT4ge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDbGFzcy5wcm90b3R5cGUsIGFjY2Vzc29yLCB7XG5cdFx0XHRnZXQoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLiQkYz8uW2FjY2Vzc29yXTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG5cdGlmIChleHRlbmQpIHtcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yIC0gYXNzaWduaW5nIGhlcmUgaXMgZmluZVxuXHRcdENsYXNzID0gZXh0ZW5kKENsYXNzKTtcblx0fVxuXHRDb21wb25lbnQuZWxlbWVudCA9IC8qKiBAdHlwZSB7YW55fSAqLyAoQ2xhc3MpO1xuXHRyZXR1cm4gQ2xhc3M7XG59XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgU3ZlbHRlIGNvbXBvbmVudHMuIFVzZWQgd2hlbiBkZXY9ZmFsc2UuXG4gKlxuICogQHRlbXBsYXRlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBbUHJvcHM9YW55XVxuICogQHRlbXBsYXRlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBbRXZlbnRzPWFueV1cbiAqL1xuZXhwb3J0IGNsYXNzIFN2ZWx0ZUNvbXBvbmVudCB7XG5cdC8qKlxuXHQgKiAjIyMgUFJJVkFURSBBUElcblx0ICpcblx0ICogRG8gbm90IHVzZSwgbWF5IGNoYW5nZSBhdCBhbnkgdGltZVxuXHQgKlxuXHQgKiBAdHlwZSB7YW55fVxuXHQgKi9cblx0JCQgPSB1bmRlZmluZWQ7XG5cdC8qKlxuXHQgKiAjIyMgUFJJVkFURSBBUElcblx0ICpcblx0ICogRG8gbm90IHVzZSwgbWF5IGNoYW5nZSBhdCBhbnkgdGltZVxuXHQgKlxuXHQgKiBAdHlwZSB7YW55fVxuXHQgKi9cblx0JCRzZXQgPSB1bmRlZmluZWQ7XG5cblx0LyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuXHQkZGVzdHJveSgpIHtcblx0XHRkZXN0cm95X2NvbXBvbmVudCh0aGlzLCAxKTtcblx0XHR0aGlzLiRkZXN0cm95ID0gbm9vcDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAdGVtcGxhdGUge0V4dHJhY3Q8a2V5b2YgRXZlbnRzLCBzdHJpbmc+fSBLXG5cdCAqIEBwYXJhbSB7S30gdHlwZVxuXHQgKiBAcGFyYW0geygoZTogRXZlbnRzW0tdKSA9PiB2b2lkKSB8IG51bGwgfCB1bmRlZmluZWR9IGNhbGxiYWNrXG5cdCAqIEByZXR1cm5zIHsoKSA9PiB2b2lkfVxuXHQgKi9cblx0JG9uKHR5cGUsIGNhbGxiYWNrKSB7XG5cdFx0aWYgKCFpc19mdW5jdGlvbihjYWxsYmFjaykpIHtcblx0XHRcdHJldHVybiBub29wO1xuXHRcdH1cblx0XHRjb25zdCBjYWxsYmFja3MgPSB0aGlzLiQkLmNhbGxiYWNrc1t0eXBlXSB8fCAodGhpcy4kJC5jYWxsYmFja3NbdHlwZV0gPSBbXSk7XG5cdFx0Y2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuXHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHRjb25zdCBpbmRleCA9IGNhbGxiYWNrcy5pbmRleE9mKGNhbGxiYWNrKTtcblx0XHRcdGlmIChpbmRleCAhPT0gLTEpIGNhbGxiYWNrcy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtQYXJ0aWFsPFByb3BzPn0gcHJvcHNcblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHQkc2V0KHByb3BzKSB7XG5cdFx0aWYgKHRoaXMuJCRzZXQgJiYgIWlzX2VtcHR5KHByb3BzKSkge1xuXHRcdFx0dGhpcy4kJC5za2lwX2JvdW5kID0gdHJ1ZTtcblx0XHRcdHRoaXMuJCRzZXQocHJvcHMpO1xuXHRcdFx0dGhpcy4kJC5za2lwX2JvdW5kID0gZmFsc2U7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQ3VzdG9tRWxlbWVudFByb3BEZWZpbml0aW9uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2F0dHJpYnV0ZV1cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JlZmxlY3RdXG4gKiBAcHJvcGVydHkgeydTdHJpbmcnfCdCb29sZWFuJ3wnTnVtYmVyJ3wnQXJyYXknfCdPYmplY3QnfSBbdHlwZV1cbiAqL1xuIiwgIi8vIGdlbmVyYXRlZCBkdXJpbmcgcmVsZWFzZSwgZG8gbm90IG1vZGlmeVxuXG4vKipcbiAqIFRoZSBjdXJyZW50IHZlcnNpb24sIGFzIHNldCBpbiBwYWNrYWdlLmpzb24uXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLWNvbXBpbGVyI3N2ZWx0ZS12ZXJzaW9uXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgVkVSU0lPTiA9ICc0LjIuMjAnO1xuZXhwb3J0IGNvbnN0IFBVQkxJQ19WRVJTSU9OID0gJzQnO1xuIiwgImltcG9ydCB7IFBVQkxJQ19WRVJTSU9OIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL3ZlcnNpb24uanMnO1xuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpXG5cdC8vIEB0cy1pZ25vcmVcblx0KHdpbmRvdy5fX3N2ZWx0ZSB8fCAod2luZG93Ll9fc3ZlbHRlID0geyB2OiBuZXcgU2V0KCkgfSkpLnYuYWRkKFBVQkxJQ19WRVJTSU9OKTtcbiIsICIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH1cclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19jcmVhdGVCaW5kaW5nID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcclxuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XHJcbiAgICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XHJcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59KTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgbykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBwKSkgX19jcmVhdGVCaW5kaW5nKG8sIG0sIHApO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG4vKiogQGRlcHJlY2F0ZWQgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG4vKiogQGRlcHJlY2F0ZWQgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xyXG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXHJcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgcmV0dXJuIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XHJcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcclxuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcclxuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcblxyXG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XHJcbn0pIDogZnVuY3Rpb24obywgdikge1xyXG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XHJcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0RGVmYXVsdChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZFNldChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4oc3RhdGUsIHJlY2VpdmVyKSB7XHJcbiAgICBpZiAocmVjZWl2ZXIgPT09IG51bGwgfHwgKHR5cGVvZiByZWNlaXZlciAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgcmVjZWl2ZXIgIT09IFwiZnVuY3Rpb25cIikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgdXNlICdpbicgb3BlcmF0b3Igb24gbm9uLW9iamVjdFwiKTtcclxuICAgIHJldHVybiB0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyID09PSBzdGF0ZSA6IHN0YXRlLmhhcyhyZWNlaXZlcik7XHJcbn1cclxuIiwgIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7IG9uTW91bnQsIHRpY2sgfSBmcm9tIFwic3ZlbHRlXCI7XG5cblx0ZXhwb3J0IGxldCBpc0ZpcnN0OiBib29sZWFuO1xuXHRleHBvcnQgbGV0IHJlbW92ZUlucHV0OiAoaWQ6IG51bWJlcikgPT4gdm9pZDtcblx0ZXhwb3J0IGxldCBpZDogbnVtYmVyO1xuXG5cdGV4cG9ydCBsZXQgdHlwZVZhbDogc3RyaW5nID0gXCJ0ZXh0XCI7XG5cdGV4cG9ydCBsZXQgbmFtZVZhbDogc3RyaW5nID0gXCJcIjtcblx0ZXhwb3J0IGxldCB2YWx1ZVZhbDogc3RyaW5nID0gXCJcIjtcblxuXHRsZXQgaW5wdXRFbDogSFRNTElucHV0RWxlbWVudDtcblx0bGV0IHZhbHVlRWw6IEhUTUxJbnB1dEVsZW1lbnQ7XG5cblx0bGV0IG9wdGlvblZhbDogc3RyaW5nXG5cdC8vRm9ybSBuYW1lcyB0aWVkIHRvIGlucHV0IHR5cGVzLlxuXHRjb25zdCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xuXHRcdFRleHQ6IFwic3RyaW5nXCIsXG5cdFx0TnVtYmVyOiBcIm51bWJlclwiLFxuXHRcdENoZWNrYm94OiBcImNoZWNrYm94XCIsXG5cdFx0RGF0ZTogXCJkYXRlXCIsXG5cdFx0RGF0ZXRpbWU6IFwiZGF0ZXRpbWUtbG9jYWxcIixcblx0fTtcblx0Ly9NYXRjaCBPYnNpZGlhbiBkYXRhIHR5cGVzIHRvIGZvcm0gbmFtZXMuXG5cdGNvbnN0IGNvbnZlcnRQcm9wczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcblx0XHR0ZXh0OiBcIlRleHRcIixcblx0XHRtdWx0aXRleHQ6IFwiVGV4dFwiLFxuXHRcdG51bWJlcjogXCJOdW1iZXJcIixcblx0XHRjaGVja2JveDogXCJDaGVja2JveFwiLFxuXHRcdGRhdGU6IFwiRGF0ZVwiLFxuXHRcdGRhdGV0aW1lOiBcIkRhdGV0aW1lXCJcblx0fVxuXG5cdG9uTW91bnQoYXN5bmMgKCkgPT4ge1xuXHRcdGF3YWl0IHRpY2soKTsgIC8vRm9jdXMgd29uJ3Qgd29yayByaWdodCB3aXRob3V0IHRpY2soKS5cblx0XHRpbnB1dEVsLmZvY3VzKCk7XG5cdFx0aW5wdXRFbC5zZWxlY3QoKTtcblxuXHRcdG9wdGlvblZhbCA9IG9wdGlvbnNbY29udmVydFByb3BzW3R5cGVWYWxdXSAgLy9Mb2FkIGRlZmF1bHQgdHlwZS5cblxuXHR9KTtcblxuXHRmdW5jdGlvbiBjaGFuZ2VUeXBlKHR5cGU6IHN0cmluZyl7XG5cdFx0dmFsdWVFbC50eXBlID0gdHlwZVxuXHR9XG48L3NjcmlwdD5cblxuPGRpdiBjbGFzcz1cIm1vZGFsLWlucHV0LWNvbnRhaW5lclwiPlxuXHQ8YnV0dG9uXG5cdFx0dHlwZT1cImJ1dHRvblwiXG5cdFx0aWQ9XCJkZWwtYnRuXCJcblx0XHRvbjpjbGljaz17KCkgPT4ge1xuXHRcdFx0aWYgKCFpc0ZpcnN0KSB7XG5cdFx0XHRcdHJlbW92ZUlucHV0KGlkKTtcblx0XHRcdH1cblx0XHR9fVxuXHRcdGNsYXNzPVwiYnRuLWRlbCB7aXNGaXJzdCA/ICdidG4taW5hY3RpdmUnIDogJyd9XCJcblx0XHR0YWJpbmRleD17aXNGaXJzdCA/IC0xIDogMH1cblx0XHQ+WDwvYnV0dG9uXG5cdD5cblx0PHNlbGVjdCBpZD1cInR5cGUtaW5wdXRcIiBjbGFzcz1cImZsZXgtb2JqXCIgYmluZDp2YWx1ZT17b3B0aW9uVmFsfSBvbjpjaGFuZ2U9eygpID0+IGNoYW5nZVR5cGUob3B0aW9uVmFsKX0+XG5cdFx0eyNlYWNoIE9iamVjdC5rZXlzKG9wdGlvbnMpIGFzIGtleX1cblx0XHRcdDxvcHRpb24gdmFsdWU9e29wdGlvbnNba2V5XX0+e2tleX08L29wdGlvbj5cblx0XHR7L2VhY2h9XG5cdDwvc2VsZWN0PlxuXHQ8aW5wdXRcblx0XHRpZD1cIm5hbWUtaW5wdXRcIlxuXHRcdGJpbmQ6dGhpcz17aW5wdXRFbH1cblx0XHRjbGFzcz1cIm5hbWUtaW5wdXQgZmxleC1vYmpcIlxuXHRcdHR5cGU9XCJ0ZXh0XCJcblx0XHRuYW1lPVwibmFtZVtdXCJcblx0XHRwbGFjZWhvbGRlcj1cIm5hbWVcIlxuXHRcdGJpbmQ6dmFsdWU9e25hbWVWYWx9XG5cdFx0cmVxdWlyZWRcblx0Lz5cblx0PGlucHV0IGJpbmQ6dGhpcz17dmFsdWVFbH1cblx0XHRpZD1cInZhbHVlLWlucHV0XCJcblx0XHR0eXBlPVwidGV4dFwiXG5cdFx0bmFtZT1cInZhbHVlW11cIlxuXHRcdHBsYWNlaG9sZGVyPVwidmFsdWVcIlxuXHRcdGJpbmQ6dmFsdWU9e3ZhbHVlVmFsfVxuXHRcdGNsYXNzPVwidmFsdWUtaW5wdXQgZmxleC1vYmpcIlxuXHQvPlxuPC9kaXY+XG5cbjxzdHlsZT5cblx0aW5wdXQge1xuXHRcdG1heC1oZWlnaHQ6IDI1cHg7XG5cdFx0b3ZlcmZsb3cteDogYXV0bztcblx0fVxuXG5cdHNlbGVjdCB7XG5cdFx0aGVpZ2h0OiAyMXB4O1xuXHR9XG5cblx0I25hbWUtaW5wdXQge1xuXHRcdGZsZXgtZ3JvdzogMDtcblx0XHR3aWR0aDogYXV0bztcblx0fVxuXG5cdC5tb2RhbC1pbnB1dC1jb250YWluZXIge1xuXHRcdHdpZHRoOiA5NSU7XG5cdFx0ZGlzcGxheTogZmxleDtcblx0XHRmbGV4LWRpcmVjdGlvbjogcm93O1xuXHRcdGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cdFx0Z2FwOiAxMHB4O1xuXHRcdG1hcmdpbi10b3A6IDEwcHg7XG5cdH1cblxuXHQuYnRuLWluYWN0aXZlIHtcblx0XHRjdXJzb3I6IG5vdC1hbGxvd2VkO1xuXHRcdHBvaW50ZXItZXZlbnRzOiBub25lO1xuXHRcdG9wYWNpdHk6IDAuNztcblx0fVxuPC9zdHlsZT5cbiIsICIvKiogUmV0dXJuIHZhbHVlIGZyb20gSFRNTCBpbnB1dCBiYXNlZCBvbiB0aGUgaW5wdXQncyB0eXBlLiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VWYWx1ZShpbnB1dDogSFRNTElucHV0RWxlbWVudCwgdHlwZTogc3RyaW5nKSB7XHJcblx0c3dpdGNoICh0eXBlKSB7XHJcblx0XHRjYXNlIFwibnVtYmVyXCI6XHJcblx0XHRcdHJldHVybiBOdW1iZXIoaW5wdXQudmFsdWUpO1xyXG5cdFx0Y2FzZSBcImNoZWNrYm94XCI6XHJcblx0XHRcdHJldHVybiBCb29sZWFuKGlucHV0LmNoZWNrZWQpO1xyXG5cdFx0ZGVmYXVsdDpcclxuXHRcdFx0cmV0dXJuIGlucHV0LnZhbHVlO1xyXG5cdH1cclxufVxyXG5cclxuLyoqIFJlbW92ZSBsZWFkaW5nIGFuZCB0cmFpbGluZyBjb21tYXMsIHRoZW4gcmVwbGFjZSBtdWx0aXBsZSBjb25zZWN1dGl2ZSBjb21tYXMgd2l0aCBhIHNpbmdsZSBjb21tYS4qL1xyXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlRXh0cmFDb21tYXMoc3RyOiBzdHJpbmcpOiBzdHJpbmcge1xyXG5cdHJldHVybiBzdHIucmVwbGFjZSgvXiwqKC4qPyksKiQvZywgXCIkMVwiKS5yZXBsYWNlKC8sezIsfS9nLCBcIixcIik7XHJcbn1cclxuXHJcbi8qKiBSZW1vdmUgYW55IGludmFsaWQgdGFnIGNoYXJhY3RlcnMgZnJvbSBzdHJpbmcuKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFuVGFncyhzdHI6IHN0cmluZykge1xyXG5cdC8vVGFrZW4gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vR29ya3ljcmVhdG9yL29ic2lkaWFuLXF1aWNrLXRhZ2dlci9cclxuXHRsZXQgY2xlYW5TdHIgPSBzdHI7XHJcblx0Zm9yIChsZXQgaW5kZXggaW4gS05PV05fQkFEX0NIQVJBQ1RFUlMpIHtcclxuXHRcdGNsZWFuU3RyID0gY2xlYW5TdHIucmVwbGFjZUFsbChLTk9XTl9CQURfQ0hBUkFDVEVSU1tpbmRleF0sIFwiXCIpO1xyXG5cdH1cclxuXHRyZXR1cm4gY2xlYW5TdHI7XHJcbn1cclxuXHJcbi8vVGFrZW4gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vR29ya3ljcmVhdG9yL29ic2lkaWFuLXF1aWNrLXRhZ2dlci8uXHJcbi8vQ29tbWFzIHJlbW92ZWQuICBXaWxsIGluc3RlYWQgYmUgaGFuZGxlZCBieSByZW1vdmVFeHRyYUNvbW1hcy5cclxuY29uc3QgS05PV05fQkFEX0NIQVJBQ1RFUlMgPSBbXHJcblx0XCJcdTIwMTJcIixcclxuXHRcIlx1MjAxM1wiLFxyXG5cdFwiXHUyMDE0XCIsXHJcblx0XCJcdTIwMTVcIixcclxuXHRcIlx1MjA0RlwiLFxyXG5cdFwiXHUyMDNEXCIsXHJcblx0XCJcdTIwMThcIixcclxuXHRcIlx1MjAxQVwiLFxyXG5cdFwiXHUyMDFCXCIsXHJcblx0XCJcdTIwMzlcIixcclxuXHRcIlx1MjAzQVwiLFxyXG5cdFwiXHUyMDFDXCIsXHJcblx0XCJcdTIwMURcIixcclxuXHRcIlx1MjAxRVwiLFxyXG5cdFwiXHUyMDFGXCIsXHJcblx0XCJcdTIwNDVcIixcclxuXHRcIlx1MjA0NlwiLFxyXG5cdFwiXHUyMDRCXCIsXHJcblx0XCJcdTIwNEVcIixcclxuXHRcIlx1MjA1MVwiLFxyXG5cdFwiXHUyMDQ0XCIsXHJcblx0XCJcdTIwNEFcIixcclxuXHRcIlx1MjAzMFwiLFxyXG5cdFwiXHUyMDMxXCIsXHJcblx0XCJcdTIwNTJcIixcclxuXHRcIlx1MjAyMFwiLFxyXG5cdFwiXHUyMDIxXCIsXHJcblx0XCJcdTIwMjJcIixcclxuXHRcIlx1MjAyM1wiLFxyXG5cdFwiXHUyMDQzXCIsXHJcblx0XCJcdTIwNENcIixcclxuXHRcIlx1MjA0RFwiLFxyXG5cdFwiXHUyMDMyXCIsXHJcblx0XCJcdTIwMzVcIixcclxuXHRcIlx1MjAzOFwiLFxyXG5cdFwiXHUyMDNCXCIsXHJcblx0XCJcdTIwNTBcIixcclxuXHRcIlx1MjA0MVwiLFxyXG5cdFwiXHUyMDQyXCIsXHJcblx0XCJcdTIwMTZcIixcclxuXHRcIlx1MjAxMVwiLFxyXG5cdFwiXHUyMDMzXCIsXHJcblx0XCJcdTIwMzRcIixcclxuXHRcIlx1MjA1N1wiLFxyXG5cdFwiXHUyMDM2XCIsXHJcblx0XCJcdTIwMzdcIixcclxuXHRcImBcIixcclxuXHRcIl5cIixcclxuXHRcIlx1MjAzRVwiLFxyXG5cdFwiXHUyMDE3XCIsXHJcblx0XCJcdTIwNTNcIixcclxuXHRcIjtcIixcclxuXHRcIjpcIixcclxuXHRcIiFcIixcclxuXHRcIlx1MjAzQ1wiLFxyXG5cdFwiXHUyMDQ5XCIsXHJcblx0XCI/XCIsXHJcblx0XCJcdTIwNDhcIixcclxuXHRcIlx1MjA0N1wiLFxyXG5cdFwiLlwiLFxyXG5cdFwiXHUyMDI0XCIsXHJcblx0XCJcdTIwMjVcIixcclxuXHRcIlx1MjAyNlwiLFxyXG5cdFwiJ1wiLFxyXG5cdCdcIicsXHJcblx0XCIoXCIsXHJcblx0XCIpXCIsXHJcblx0XCJbXCIsXHJcblx0XCJdXCIsXHJcblx0XCJ7XCIsXHJcblx0XCJ9XCIsXHJcblx0XCJAXCIsXHJcblx0XCIqXCIsXHJcblx0XCImXCIsXHJcblx0XCIlXCIsXHJcblx0XCJcdTIwNTRcIixcclxuXHRcIitcIixcclxuXHRcIjxcIixcclxuXHRcIj1cIixcclxuXHRcIj5cIixcclxuXHRcInxcIixcclxuXHRcIn5cIixcclxuXHRcIiRcIixcclxuXHRcIlx1MjA1NVwiLFxyXG5cdFwiXHUyMDU2XCIsXHJcblx0XCJcdTIwNThcIixcclxuXHRcIlx1MjA1OVwiLFxyXG5cdFwiXHUyMDVBXCIsXHJcblx0XCJcdTIwNUJcIixcclxuXHRcIlx1MjA1Q1wiLFxyXG5cdFwiXHUyMDVEXCIsXHJcblx0XCJcdTIwNUVcIixcclxuXHRcIlx1MkUwMFwiLFxyXG5cdFwiXHUyRTAxXCIsXHJcblx0XCJcdTJFMDJcIixcclxuXHRcIlx1MkUwM1wiLFxyXG5cdFwiXHUyRTA0XCIsXHJcblx0XCJcdTJFMDVcIixcclxuXHRcIlx1MkUwNlwiLFxyXG5cdFwiXHUyRTA3XCIsXHJcblx0XCJcdTJFMDhcIixcclxuXHRcIlx1MkUwOVwiLFxyXG5cdFwiXHUyRTBBXCIsXHJcblx0XCJcdTJFMEJcIixcclxuXHRcIlx1MkUwQ1wiLFxyXG5cdFwiXHUyRTBEXCIsXHJcblx0XCJcdTJFMEVcIixcclxuXHRcIlx1MkUwRlwiLFxyXG5cdFwiXHUyRTEwXCIsXHJcblx0XCJcdTJFMTFcIixcclxuXHRcIlx1MkUxMlwiLFxyXG5cdFwiXHUyRTEzXCIsXHJcblx0XCJcdTJFMTRcIixcclxuXHRcIlx1MkUxNVwiLFxyXG5cdFwiXHUyRTE2XCIsXHJcblx0XCJcdTJFMTdcIixcclxuXHRcIlx1MkUxQ1wiLFxyXG5cdFwiXHUyRTFEXCIsXHJcblx0XCIgXCIsXHJcblx0XCIjXCIsXHJcbl07XHJcbiIsICI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuICBpbXBvcnQgeyBvbk1vdW50LCB0aWNrIH0gZnJvbSBcInN2ZWx0ZVwiO1xuICBpbXBvcnQgUHJvcElucHV0IGZyb20gXCIuL0FkZFByb3BJbnB1dC5zdmVsdGVcIjtcbiAgaW1wb3J0IHsgTmV3UHJvcERhdGEgfSBmcm9tIFwiLi9tYWluXCI7XG4gIGltcG9ydCB7IGNsZWFuVGFncywgcGFyc2VWYWx1ZSwgcmVtb3ZlRXh0cmFDb21tYXMgfSBmcm9tIFwiLi9oZWxwZXJzXCI7XG4gIGltcG9ydCB0eXBlIHsgUHJvcGVydHlUeXBlcyB9IGZyb20gXCIuL3R5cGVzL2N1c3RvbVwiO1xuXG4gIGV4cG9ydCBsZXQgc3VibWlzc2lvbjogKHByb3BzOiBNYXA8c3RyaW5nLCBOZXdQcm9wRGF0YT4pID0+IHZvaWQ7XG4gIGV4cG9ydCBsZXQgb3ZlcndyaXRlOiBib29sZWFuO1xuICBleHBvcnQgbGV0IGRlbGltaXRlcjogc3RyaW5nO1xuICBleHBvcnQgbGV0IGRlZmF1bHRQcm9wczogeyBuYW1lOiBzdHJpbmc7IHZhbHVlOiBhbnk7IHR5cGU6IFByb3BlcnR5VHlwZXMgfVtdO1xuICBleHBvcnQgbGV0IGNoYW5nZUJvb2w6IChib29sOiBib29sZWFuKSA9PiB2b2lkO1xuXG4gIGxldCBjb3VudElucHV0cyA9IDA7IC8vQ291bGQgcmVwbGFjZSB3aXRoIFVVSUQuXG4gIGxldCBmb3JtRWw6IEhUTUxGb3JtRWxlbWVudDtcbiAgbGV0IGVycm9yRWw6IEhUTUxEaXZFbGVtZW50O1xuICBsZXQgYWxlcnRUZXh0ID0gXCIuXCI7XG5cbiAgbGV0IGlucHV0RWxzOiB7XG4gICAgaWQ6IG51bWJlcjtcbiAgICBpc0ZpcnN0OiBib29sZWFuO1xuICAgIHR5cGVEZWY6IFByb3BlcnR5VHlwZXM7XG4gICAgbmFtZURlZjogc3RyaW5nO1xuICAgIHZhbHVlRGVmOiBhbnk7XG4gIH1bXSA9IFtdO1xuXG4gIGZ1bmN0aW9uIG9uQ2hlY2tib3hDaGFuZ2UoKSB7XG4gICAgb3ZlcndyaXRlID0gIW92ZXJ3cml0ZTtcbiAgICBjaGFuZ2VCb29sKG92ZXJ3cml0ZSk7XG4gIH1cblxuICBvbk1vdW50KCgpID0+IHtcbiAgICBkZWZhdWx0UHJvcHMubGVuZ3RoID4gMFxuICAgICAgPyBhZGRJbnB1dHMoZGVmYXVsdFByb3BzKVxuICAgICAgOiBhZGRJbnB1dHMoW3sgdHlwZTogXCJ0ZXh0XCIsIG5hbWU6IFwiXCIsIHZhbHVlOiBcIlwiIH1dKTtcbiAgfSk7XG5cbiAgLyoqIEFkZCBuZXcgaW5wdXQgdG8gaW5wdXRFbHMgKi9cbiAgZnVuY3Rpb24gYWRkSW5wdXRzKFxuICAgIGlucHV0czogeyB0eXBlOiBQcm9wZXJ0eVR5cGVzOyBuYW1lOiBzdHJpbmc7IHZhbHVlOiBhbnkgfVtdID0gW1xuICAgICAgeyB0eXBlOiBcInRleHRcIiwgbmFtZTogXCJcIiwgdmFsdWU6IFwiXCIgfSxcbiAgICBdXG4gICkge1xuICAgIGxldCBhcnIgPSBbXTtcbiAgICBmb3IgKGxldCBpbnB1dCBvZiBpbnB1dHMpIHtcbiAgICAgIGNvdW50SW5wdXRzKys7XG4gICAgICBhcnIucHVzaCh7XG4gICAgICAgIGlkOiBjb3VudElucHV0cyxcbiAgICAgICAgaXNGaXJzdDogY291bnRJbnB1dHMgPT09IDEgPyB0cnVlIDogZmFsc2UsXG4gICAgICAgIHR5cGVEZWY6IGlucHV0LnR5cGUsXG4gICAgICAgIG5hbWVEZWY6IGlucHV0Lm5hbWUsXG4gICAgICAgIHZhbHVlRGVmOiBpbnB1dC52YWx1ZSxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpbnB1dEVscyA9IFsuLi5pbnB1dEVscywgLi4uYXJyXTtcbiAgfVxuXG4gIC8qKiBSZW1vdmUgaW5wdXQgZnJvbSBpbnB1dEVscyAqL1xuICBhc3luYyBmdW5jdGlvbiByZW1vdmVJbnB1dChpZDogbnVtYmVyKSB7XG4gICAgaW5wdXRFbHMgPSBpbnB1dEVscy5maWx0ZXIoKGlucHV0KSA9PiBpbnB1dC5pZCAhPT0gaWQpO1xuICAgIGF3YWl0IHRpY2soKTtcblxuICAgIC8vU2V0IGZvY3VzIHRvIHByZXZpb3VzIGlucHV0LlxuICAgIGxldCBpbnB1dHM6IE5vZGVMaXN0T2Y8SFRNTElucHV0RWxlbWVudD4gPSBmb3JtRWwucXVlcnlTZWxlY3RvckFsbChcImlucHV0XCIpO1xuICAgIGlmICghaW5wdXRzKSByZXR1cm47XG5cbiAgICBpbnB1dHNbaW5wdXRzLmxlbmd0aCAtIDJdLmZvY3VzKCk7XG4gIH1cblxuICAvKiogU2VlIGlmIHRoZXJlIGFyZSBkdXBsaWNhdGUgcHJvcGVydHkgbmFtZXMuKi9cbiAgZnVuY3Rpb24gY2hlY2tEdXBsaWNhdGVOYW1lcygpIHtcbiAgICBsZXQgc2V0ID0gbmV3IFNldCgpO1xuICAgIGZvciAobGV0IGlucHV0IG9mIGlucHV0RWxzKSBzZXQuYWRkKGlucHV0Lm5hbWVEZWYpO1xuXG4gICAgaWYgKHNldC5zaXplIDwgaW5wdXRFbHMubGVuZ3RoKSByZXR1cm4gdHJ1ZTtcbiAgICBlbHNlIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKiBEaXNwbGF5IGFuIGVycm9yIG1lc3NhZ2UuICovXG4gIGZ1bmN0aW9uIHJ1bkVycm9yKGVycm9yVGV4dDogc3RyaW5nKSB7XG4gICAgYWxlcnRUZXh0ID0gZXJyb3JUZXh0O1xuICAgIGVycm9yRWwuY2xhc3NMaXN0LnJlbW92ZShcImhpZGRlblwiKTsgLy9TaG91bGQgSSBoYXZlIHRoaXMgZXJyb3IgbWVzc2FnZSBmYWRlIGF3YXk/XG4gIH1cblxuICAvKiogU2VhcmNoIGZvciBhbGwgbGFiZWxzIGFuZCB2YWx1ZXMsIGFkZCB0aGVtIHRvIGEgbWFwLCB0aGVuIHBhc3MgdGhlbSBiYWNrIHRvIG1vZGFsLiovXG4gIGZ1bmN0aW9uIG9uU3VibWl0KCkge1xuICAgIC8vTWFrZSBzdXJlIHRoZXJlIGFyZSBubyBkdXBsaWNhdGUgbmFtZXMuXG4gICAgaWYgKGNoZWNrRHVwbGljYXRlTmFtZXMoKSkge1xuICAgICAgcnVuRXJyb3IoXCJEdXBsaWNhdGUgcHJvcGVydHkgbmFtZXMgYXJlIG5vdCBhbGxvd2VkLlwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgb2JqOiBNYXA8c3RyaW5nLCBOZXdQcm9wRGF0YT4gPSBuZXcgTWFwKCk7XG5cbiAgICBsZXQgaW5wdXRzOiBOb2RlTGlzdE9mPEhUTUxJbnB1dEVsZW1lbnQ+ID0gZm9ybUVsLnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAnaW5wdXRbbmFtZV49XCJuYW1lW11cIl0nXG4gICAgKTtcblxuICAgIGlucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4ge1xuICAgICAgLy9DaGVjayBmb3IgcHJvcGVyIGlucHV0cyBiZWluZyBuZXh0IHRvIGVhY2ggb3RoZXIuXG4gICAgICBpZiAoIShpbnB1dC5uZXh0RWxlbWVudFNpYmxpbmcgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50KSkgcmV0dXJuO1xuICAgICAgaWYgKCEoaW5wdXQucHJldmlvdXNFbGVtZW50U2libGluZyBpbnN0YW5jZW9mIEhUTUxTZWxlY3RFbGVtZW50KSkgcmV0dXJuO1xuICAgICAgaWYgKFxuICAgICAgICAhKGlucHV0LnByZXZpb3VzRWxlbWVudFNpYmxpbmcuY2hpbGRyZW5bMF0gaW5zdGFuY2VvZiBIVE1MT3B0aW9uRWxlbWVudClcbiAgICAgIClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgLy9UT0RPOiBJbXBsZW1lbnQgZXJyb3IgaGFuZGxpbmcgaWYgaW5wdXRzIGFyZSBpbmFjY3VyYXRlP1xuICAgICAgLy9UaGUgZW50aXJlIGZvcm0gaXMgZGVwZW5kZW50IG9uIHRoaXMgc3RydWN0dXJlLCB0aG91Z2guXG5cbiAgICAgIC8vR2V0IG5hbWUsIHZhbHVlIGFuZCB0eXBlIGZyb20gaW5wdXRzLlxuICAgICAgbGV0IG5hbWUgPSBpbnB1dC52YWx1ZTtcbiAgICAgIGlmIChuYW1lID09PSBcIlwiKSB7XG4gICAgICAgIGlucHV0LnJlcG9ydFZhbGlkaXR5KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2VsZWN0RWwgPSBpbnB1dC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nIGFzIEhUTUxTZWxlY3RFbGVtZW50O1xuICAgICAgY29uc3QgaHRtbFR5cGUgPSBzZWxlY3RFbC52YWx1ZTtcblxuICAgICAgY29uc3QgcmV2ZXJzZU9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIFByb3BlcnR5VHlwZXM+ID0ge1xuICAgICAgICBcInN0cmluZ1wiOiBcInRleHRcIixcbiAgICAgICAgXCJudW1iZXJcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJjaGVja2JveFwiOiBcImNoZWNrYm94XCIsXG4gICAgICAgIFwiZGF0ZVwiOiBcImRhdGVcIixcbiAgICAgICAgXCJkYXRldGltZS1sb2NhbFwiOiBcImRhdGV0aW1lXCJcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9ic2lkaWFuVHlwZSA9IHJldmVyc2VPcHRpb25zW2h0bWxUeXBlXSA/PyAndGV4dCc7XG5cbiAgICAgIGxldCB2YWx1ZTogYW55ID0gcGFyc2VWYWx1ZShcbiAgICAgICAgaW5wdXQubmV4dEVsZW1lbnRTaWJsaW5nLFxuICAgICAgICBpbnB1dC5uZXh0RWxlbWVudFNpYmxpbmcudHlwZVxuICAgICAgKTtcbiAgICAgIC8vQ2hlY2sgZm9yIHRhZ3MuICBDbGVhbiB0aGVtIG9mIGFueSBpbnZhbGlkIGNoYXJhY3RlcnMsIHRoZW4gc3BsaXQgYnkgY29tbWEuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChuYW1lID09PSBcInRhZ3NcIikge1xuICAgICAgICAgIHZhbHVlID0gY2xlYW5UYWdzKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5pbmNsdWRlcyhcIixcIikpIHtcbiAgICAgICAgICBsZXQgc3RyID0gcmVtb3ZlRXh0cmFDb21tYXModmFsdWUpO1xuICAgICAgICAgIHZhbHVlID0gc3RyLnNwbGl0KGRlbGltaXRlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA9PT0gXCJcIikgdmFsdWUgPSBudWxsO1xuXG4gICAgICAvL1N0b3JlIGRhdGEgaW50byBvYmplY3QuXG4gICAgICBsZXQgcHJvcE9iajogTmV3UHJvcERhdGEgPSB7XG4gICAgICAgIHR5cGU6IG9ic2lkaWFuVHlwZSxcbiAgICAgICAgZGF0YTogdmFsdWUsXG4gICAgICAgIG92ZXJ3cml0ZTogZmFsc2UsXG4gICAgICAgIGRlbGltaXRlcjogZGVsaW1pdGVyLFxuICAgICAgfTtcblxuICAgICAgb2JqLnNldChuYW1lLCBwcm9wT2JqKTtcbiAgICB9KTtcblxuICAgIC8vVE9ETzogRXJyb3IgaGFuZGxpbmcgZm9yIHdoZW4gdXNlciBzdWJtaXRzIHdpdGggYW4gZW1wdHkgbmFtZS5cbiAgICAvL0lucHV0IHZhbGlkYXRpb24gZG9lc24ndCB0cmlnZ2VyIHVubGVzcyB0aGlzIGNvZGUgaXMgaW4uICBXaHk/ICBJIGRpZG4ndCBuZWVkIHRoaXMgYmVmb3JlLlxuICAgIGlmIChvYmouc2l6ZSA8IGlucHV0cy5sZW5ndGgpIHJldHVybjtcblxuICAgIGNvbnNvbGUubG9nKG9iaik7XG5cbiAgICBzdWJtaXNzaW9uKG9iaik7XG4gIH1cbjwvc2NyaXB0PlxuXG48ZGl2IGlkPVwibXVsdGktcHJvcGVydGllcy1tb2RhbFwiIGNsYXNzPVwibW9kYWwtY29udGVudFwiPlxuICA8ZGl2IGlkPVwiYWxlcnQtY29udGFpbmVyXCIgY2xhc3M9XCJhbGVydC1jb250YWluZXIgaGlkZGVuXCIgYmluZDp0aGlzPXtlcnJvckVsfT5cbiAgICA8ZGl2PkVSUk9SPC9kaXY+XG4gICAgPGRpdiBpZD1cImFsZXJ0LXRleHRcIj57YWxlcnRUZXh0fTwvZGl2PlxuICA8L2Rpdj5cbiAgPHA+XG4gICAgVHlwZSBpbiBhIHByb3BlcnR5IG5hbWUsIHRoZW4gdmFsdWUuIFVzZSB0aGUgZHJvcGJveCB0byBjaG9vc2Ugd2hhdCB0eXBlIG9mXG4gICAgZGF0YSB5b3Ugd2lzaCB0byBzdG9yZS5cbiAgPC9wPlxuICA8cD5cbiAgICBJZiB5b3Ugd2FudCB0byBtYWtlIGEgTGlzdCBwcm9wZXJ0eSwgdXNlIHRoZSBUZXh0IGRhdGEgdHlwZSBhbmQgc2VwYXJhdGVcbiAgICBlYWNoIHZhbHVlIHdpdGggYSBcIntkZWxpbWl0ZXJ9XCIuXG4gIDwvcD5cbiAgPHA+SWYgeW91IHdhbnQgdG8gYWRkIFRhZ3MsIHVzZSB0aGUgbmFtZSBcInRhZ3NcIi48L3A+XG4gIDxmb3JtIG9uOnN1Ym1pdHxwcmV2ZW50RGVmYXVsdCBiaW5kOnRoaXM9e2Zvcm1FbH0+XG4gICAgPGxhYmVsXG4gICAgICA+PGlucHV0XG4gICAgICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgICAgIGNoZWNrZWQ9e292ZXJ3cml0ZX1cbiAgICAgICAgb246Y2hhbmdlPXtvbkNoZWNrYm94Q2hhbmdlfVxuICAgICAgLz57XCJPdmVyd3JpdGUgZXhpc3RpbmcgcHJvcGVydGllc1wifTwvbGFiZWxcbiAgICA+XG4gICAgPGRpdiBjbGFzcz1cIm1vZGFsLWlucHV0cy1jb250YWluZXJcIj5cbiAgICAgIHsjZWFjaCBpbnB1dEVscyBhcyBpbnB1dCAoaW5wdXQuaWQpfVxuICAgICAgICA8UHJvcElucHV0XG4gICAgICAgICAgaXNGaXJzdD17aW5wdXQuaXNGaXJzdH1cbiAgICAgICAgICBpZD17aW5wdXQuaWR9XG4gICAgICAgICAgYmluZDp0eXBlVmFsPXtpbnB1dC50eXBlRGVmfVxuICAgICAgICAgIGJpbmQ6bmFtZVZhbD17aW5wdXQubmFtZURlZn1cbiAgICAgICAgICBiaW5kOnZhbHVlVmFsPXtpbnB1dC52YWx1ZURlZn1cbiAgICAgICAgICB7cmVtb3ZlSW5wdXR9XG4gICAgICAgIC8+XG4gICAgICB7L2VhY2h9XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cIm1vZGFsLWFkZC1jb250YWluZXJcIj5cbiAgICAgIDxidXR0b25cbiAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgIG9uOmNsaWNrPXsoKSA9PiBhZGRJbnB1dHMoW3sgdHlwZTogXCJ0ZXh0XCIsIG5hbWU6IFwiXCIsIHZhbHVlOiBcIlwiIH1dKX1cbiAgICAgICAgY2xhc3M9XCJhLWJ0blwiXG4gICAgICAgID5BZGQ8L2J1dHRvblxuICAgICAgPlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1idXR0b24tY29udGFpbmVyXCI+XG4gICAgICA8YnV0dG9uIG9uOmNsaWNrPXtvblN1Ym1pdH0gY2xhc3M9XCJidG4tc3VibWl0XCI+U3VibWl0PC9idXR0b24+XG4gICAgPC9kaXY+XG4gIDwvZm9ybT5cbjwvZGl2PlxuXG48c3R5bGU+XG4gIC5tb2RhbC1pbnB1dHMtY29udGFpbmVyIHtcbiAgICBoZWlnaHQ6IDIwMHB4O1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIG92ZXJmbG93LXk6IHNjcm9sbDtcbiAgICBib3JkZXItcmFkaXVzOiA1cHg7XG4gICAgYm9yZGVyLXN0eWxlOiBzb2xpZDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgfVxuXG4gIC5tb2RhbC1hZGQtY29udGFpbmVyIHtcbiAgICBtYXJnaW4tdG9wOiAxMHB4O1xuICB9XG4gIC5hbGVydC1jb250YWluZXIge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIG1hcmdpbi1ib3R0b206IDEwcHg7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmVkO1xuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICB9XG4gIC5oaWRkZW4ge1xuICAgIGRpc3BsYXk6IG5vbmU7XG4gIH1cbjwvc3R5bGU+XG4iLCAiLyoqIE1vZGFsIHRvIGhvbGQgZm9ybSB0aGF0IGxldHMgdXNlciByZW1vdmUgcHJvcHMgZnJvbSBzZWxlY3Rpb24uICovXG5cbmltcG9ydCB7IE1vZGFsLCBBcHAsIE5vdGljZSB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IEFkZENvbmZpcm1Gb3JtIGZyb20gXCIuL0FkZENvbmZpcm1Gb3JtLnN2ZWx0ZVwiO1xuaW1wb3J0IHsgTmV3UHJvcERhdGEgfSBmcm9tIFwiLi9tYWluXCI7XG5cbi8qKiBMb2FkcyBhIG1vZGFsIGFuZCBoYW5kbGVzIGZvcm0gc3VibWlzc2lvbnMuICovXG5leHBvcnQgY2xhc3MgQWRkQ29uZmlybU1vZGFsIGV4dGVuZHMgTW9kYWwge1xuXHRwcm9wczogTWFwPHN0cmluZywgTmV3UHJvcERhdGE+O1xuXHRzdWJtaXNzaW9uOiAoYm9vbDogYm9vbGVhbikgPT4gUHJvbWlzZTx2b2lkPjtcblx0b3ZlcndyaXRlOiBib29sZWFuO1xuXHRjb21wb25lbnQ6IEFkZENvbmZpcm1Gb3JtO1xuXG5cdGNvbnN0cnVjdG9yKFxuXHRcdGFwcDogQXBwLFxuXHRcdHByb3BzOiBNYXA8c3RyaW5nLCBOZXdQcm9wRGF0YT4sXG5cdFx0b3ZlcndyaXRlOiBib29sZWFuLFxuXHRcdHN1Ym1pc3Npb246IChib29sOiBib29sZWFuKSA9PiBQcm9taXNlPHZvaWQ+XG5cdCkge1xuXHRcdHN1cGVyKGFwcCk7XG5cdFx0dGhpcy5wcm9wcyA9IHByb3BzO1xuXHRcdHRoaXMub3ZlcndyaXRlID0gb3ZlcndyaXRlO1xuXHRcdHRoaXMuc3VibWlzc2lvbiA9IHN1Ym1pc3Npb247XG5cdH1cblx0YXN5bmMgb25TdWJtaXQoKSB7XG5cdFx0YXdhaXQgdGhpcy5zdWJtaXNzaW9uKHRydWUpO1xuXHRcdHRoaXMuY2xvc2UoKTtcblx0fVxuXG5cdG9uQ2FuY2VsKCkge1xuXHRcdHRoaXMuc3VibWlzc2lvbihmYWxzZSk7XG5cdFx0dGhpcy5jbG9zZSgpO1xuXHR9XG5cblx0b25PcGVuKCk6IHZvaWQge1xuXHRcdHRoaXMudGl0bGVFbC5jcmVhdGVFbChcImgyXCIsIHsgdGV4dDogXCJBZGQgUHJvcGVydGllc1wiIH0pO1xuXG5cdFx0dGhpcy5jb21wb25lbnQgPSBuZXcgQWRkQ29uZmlybUZvcm0oe1xuXHRcdFx0dGFyZ2V0OiB0aGlzLmNvbnRlbnRFbCxcblx0XHRcdHByb3BzOiB7XG5cdFx0XHRcdHByb3BzOiB0aGlzLnByb3BzLFxuXHRcdFx0XHRvdmVyd3JpdGU6IHRoaXMub3ZlcndyaXRlLFxuXHRcdFx0XHRzdWJtaXNzaW9uOiB0aGlzLm9uU3VibWl0LmJpbmQodGhpcyksXG5cdFx0XHRcdGNhbmNlbDogdGhpcy5vbkNhbmNlbC5iaW5kKHRoaXMpLFxuXHRcdFx0fSxcblx0XHR9KTtcblx0fVxufVxuIiwgIjxzY3JpcHQgbGFuZz1cInRzXCI+XHJcblx0aW1wb3J0IHsgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcclxuXHRpbXBvcnQgeyBOZXdQcm9wRGF0YSB9IGZyb20gXCIuL21haW5cIjtcclxuXHJcblx0ZXhwb3J0IGxldCBwcm9wczogTWFwPHN0cmluZywgTmV3UHJvcERhdGE+O1xyXG5cdGV4cG9ydCBsZXQgb3ZlcndyaXRlOiBib29sZWFuID0gdHJ1ZTtcclxuXHRleHBvcnQgbGV0IHN1Ym1pc3Npb246ICgpID0+IHZvaWQ7XHJcblx0ZXhwb3J0IGxldCBjYW5jZWw6ICgpID0+IHZvaWQ7XHJcblxyXG5cdGxldCBidG5DYW5jZWw6IEhUTUxCdXR0b25FbGVtZW50O1xyXG5cclxuXHRjb25zdCBtc2cgPSBvdmVyd3JpdGVcclxuXHRcdD8gXCJBbnkgcHJlLWV4aXN0aW5nIHRleHQgcHJvcHMgd2lsbCBoYXZlIHRoZWlyIHZhbHVlcyBvdmVyd3JpdHRlbi5cIlxyXG5cdFx0OiBcIkFueSBwcmUtZXhpc3RpbmcgdGV4dCBwcm9wcyB3aWxsIGhhdmUgdGhlaXIgdmFsdWVzIGJlIGFwcGVuZGVkIHRvLlwiO1xyXG5cclxuXHQvL0ZvY3VzIG9uIGNhbmNlbCB0byBtYWtlIHN1cmUgdXNlciBkb2VzIG5vdCBlYXNpbHkgc3VibWl0IGNoYW5nZXMuXHJcblx0b25Nb3VudCgoKSA9PiB7XHJcblx0XHRidG5DYW5jZWwuZm9jdXMoKTtcclxuXHR9KTtcclxuPC9zY3JpcHQ+XHJcblxyXG48ZGl2PlxyXG5cdDxmb3JtIG9uOnN1Ym1pdHxwcmV2ZW50RGVmYXVsdD17c3VibWlzc2lvbn0+XHJcblx0XHQ8cCBjbGFzcz1cIm1zZ1wiPnttc2d9PC9wPlxyXG5cdFx0PHA+VGhlIGZvbGxvd2luZyBwcm9wcyB3aWxsIGJlIGFkZGVkOjwvcD5cclxuXHRcdDx1bD5cclxuXHRcdFx0eyNlYWNoIFsuLi5wcm9wc10gYXMgW3Byb3BOYW1lLCBwcm9wXX1cclxuXHRcdFx0XHQ8bGk+XHJcblx0XHRcdFx0XHR7cHJvcE5hbWV9OiB7cHJvcC5kYXRhfVxyXG5cdFx0XHRcdDwvbGk+XHJcblx0XHRcdHsvZWFjaH1cclxuXHRcdDwvdWw+XHJcblx0XHQ8cD5BcmUgeW91IHN1cmUgeW91IHdpc2ggdG8gcHJvY2VlZD88L3A+XHJcblx0XHQ8YnV0dG9uIGNsYXNzPVwibW9kLXdhcm5pbmdcIiB0eXBlPVwic3VibWl0XCI+Q29uZmlybTwvYnV0dG9uPlxyXG5cdFx0PGJ1dHRvbiBvbjpjbGljaz17Y2FuY2VsfSBiaW5kOnRoaXM9e2J0bkNhbmNlbH0+Q2FuY2VsPC9idXR0b24+XHJcblx0PC9mb3JtPlxyXG48L2Rpdj5cclxuXHJcbjxzdHlsZT5cclxuXHQubXNnIHtcclxuXHRcdGZvbnQtd2VpZ2h0OiBib2xkO1xyXG5cdFx0cGFkZGluZy1ib3R0b206IDEwcHg7XHJcblx0fVxyXG48L3N0eWxlPlxyXG4iLCAiaW1wb3J0IHsgQXBwLCBNb2RhbCB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IEFkZFZhbHVlRm9ybSBmcm9tIFwiLi9BZGRWYWx1ZUZvcm0uc3ZlbHRlXCI7XG5cbmV4cG9ydCBjbGFzcyBBZGRWYWx1ZU1vZGFsIGV4dGVuZHMgTW9kYWwge1xuICBjb21wb25lbnQ6IEFkZFZhbHVlRm9ybTtcbiAgcHJvcGVydGllczogc3RyaW5nW107XG4gIG9uU3VibWl0OiAoc2VsZWN0ZWRQcm9wZXJ0eTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKSA9PiB2b2lkO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIGFwcDogQXBwLFxuICAgIHByb3BlcnRpZXM6IHN0cmluZ1tdLFxuICAgIG9uU3VibWl0OiAoc2VsZWN0ZWRQcm9wZXJ0eTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKSA9PiB2b2lkXG4gICkge1xuICAgIHN1cGVyKGFwcCk7XG4gICAgdGhpcy5wcm9wZXJ0aWVzID0gcHJvcGVydGllcztcbiAgICB0aGlzLm9uU3VibWl0ID0gb25TdWJtaXQ7XG4gIH1cblxuICBvbk9wZW4oKSB7XG4gICAgY29uc3QgeyBjb250ZW50RWwgfSA9IHRoaXM7XG4gICAgdGhpcy5jb21wb25lbnQgPSBuZXcgQWRkVmFsdWVGb3JtKHtcbiAgICAgIHRhcmdldDogY29udGVudEVsLFxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgcHJvcGVydGllczogdGhpcy5wcm9wZXJ0aWVzLFxuICAgICAgICBvblN1Ym1pdDogKHNlbGVjdGVkUHJvcGVydHk6IHN0cmluZywgdmFsdWU6IHN0cmluZykgPT4ge1xuICAgICAgICAgIHRoaXMub25TdWJtaXQoc2VsZWN0ZWRQcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICB0aGlzLmNvbXBvbmVudC4kb24oXCJjYW5jZWxcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgb25DbG9zZSgpIHtcbiAgICBjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcbiAgICBjb250ZW50RWwuZW1wdHkoKTtcbiAgfVxufVxuIiwgIjxzY3JpcHQgbGFuZz1cInRzXCI+XG4gIGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciB9IGZyb20gXCJzdmVsdGVcIjtcblxuICBleHBvcnQgbGV0IHByb3BlcnRpZXM6IHN0cmluZ1tdO1xuICBleHBvcnQgbGV0IG9uU3VibWl0OiAoc2VsZWN0ZWRQcm9wZXJ0eTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKSA9PiB2b2lkO1xuXG4gIGxldCBzZWxlY3RlZFByb3BlcnR5OiBzdHJpbmcgPSBcIlwiO1xuICBsZXQgdmFsdWU6IHN0cmluZyA9IFwiXCI7XG5cbiAgY29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKTtcblxuICBmdW5jdGlvbiBoYW5kbGVTdWJtaXQoKSB7XG4gICAgaWYgKHNlbGVjdGVkUHJvcGVydHkgJiYgdmFsdWUpIHtcbiAgICAgIG9uU3VibWl0KHNlbGVjdGVkUHJvcGVydHksIHZhbHVlKTtcbiAgICAgIGRpc3BhdGNoKFwic3VibWl0XCIpO1xuICAgIH1cbiAgfVxuPC9zY3JpcHQ+XG5cbjxmb3JtIG9uOnN1Ym1pdHxwcmV2ZW50RGVmYXVsdD17aGFuZGxlU3VibWl0fT5cbiAgPGRpdiBjbGFzcz1cIm1vZGFsLWNvbnRlbnRcIj5cbiAgICA8aDI+QWRkIFZhbHVlIHRvIFByb3BlcnR5PC9oMj5cbiAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cFwiPlxuICAgICAgPGxhYmVsIGZvcj1cInByb3BlcnR5LXNlbGVjdFwiPlNlbGVjdCBQcm9wZXJ0eTwvbGFiZWw+XG4gICAgICA8c2VsZWN0IGlkPVwicHJvcGVydHktc2VsZWN0XCIgYmluZDp2YWx1ZT17c2VsZWN0ZWRQcm9wZXJ0eX0gcmVxdWlyZWQ+XG4gICAgICAgIDxvcHRpb24gdmFsdWU9XCJcIiBkaXNhYmxlZD5DaG9vc2UgYSBwcm9wZXJ0eS4uLjwvb3B0aW9uPlxuICAgICAgICB7I2VhY2ggcHJvcGVydGllcyBhcyBwcm9wfVxuICAgICAgICAgIDxvcHRpb24gdmFsdWU9e3Byb3B9Pntwcm9wfTwvb3B0aW9uPlxuICAgICAgICB7L2VhY2h9XG4gICAgICA8L3NlbGVjdD5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cFwiPlxuICAgICAgPGxhYmVsIGZvcj1cInZhbHVlLWlucHV0XCI+VmFsdWUgdG8gQWRkPC9sYWJlbD5cbiAgICAgIDxpbnB1dCBpZD1cInZhbHVlLWlucHV0XCIgdHlwZT1cInRleHRcIiBiaW5kOnZhbHVlPXt2YWx1ZX0gcmVxdWlyZWQgLz5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG4gIDxkaXYgY2xhc3M9XCJtb2RhbC1mb290ZXJcIj5cbiAgICA8YnV0dG9uIHR5cGU9XCJzdWJtaXRcIiBjbGFzcz1cIm1vZC1jdGFcIj5BZGQgVmFsdWU8L2J1dHRvbj5cbiAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBvbjpjbGljaz17KCkgPT4gZGlzcGF0Y2goXCJjYW5jZWxcIil9PkNhbmNlbDwvYnV0dG9uPlxuICA8L2Rpdj5cbjwvZm9ybT5cbiIsICJpbXBvcnQgeyBQbHVnaW5TZXR0aW5nVGFiLCBBcHAsIFNldHRpbmcsIE5vdGljZSB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5cclxuaW1wb3J0IE11bHRpUHJvcFBsdWdpbiBmcm9tIFwiLi9tYWluXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgU2V0dGluZ1RhYiBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xyXG4gIHBsdWdpbjogTXVsdGlQcm9wUGx1Z2luO1xyXG5cclxuICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgcGx1Z2luOiBNdWx0aVByb3BQbHVnaW4pIHtcclxuICAgIHN1cGVyKGFwcCwgcGx1Z2luKTtcclxuICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xyXG4gIH1cclxuXHJcbiAgZGlzcGxheSgpIHtcclxuICAgIGxldCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xyXG4gICAgY29udGFpbmVyRWwuZW1wdHkoKTtcclxuXHJcbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgLnNldE5hbWUoXCJPdmVyd3JpdGUgZXhpc3RpbmcgdGV4dFwiKVxyXG4gICAgICAuc2V0RGVzYyhcclxuICAgICAgICBcIldoZW4gYWRkaW5nIGEgcHJvcGVydHkgd2l0aCBhIG5hbWUgdGhhdCBhbHJlYWR5IGV4aXN0cywgdGhlIHRleHQgd2lsbCBvdmVyd3JpdGUgdGhlIHByb3AncyBleGlzdGluZyB2YWx1ZS4gIElmIGxlZnQgZGlzYWJsZWQsIHRoZSBuZXcgdmFsdWUgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGUgb2xkIGFzIGEgTGlzdC5cIlxyXG4gICAgICApXHJcbiAgICAgIC5hZGRUb2dnbGUoKHRvZ2dsZSkgPT4ge1xyXG4gICAgICAgIHRvZ2dsZS5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5vdmVyd3JpdGUpO1xyXG4gICAgICAgIHRvZ2dsZS5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLm92ZXJ3cml0ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAuc2V0TmFtZShcIlJlY3Vyc2l2ZSBJdGVyYXRpb25cIilcclxuICAgICAgLnNldERlc2MoXHJcbiAgICAgICAgXCJXaGVuIHRvZ2dsZWQgb24sIHdoaWxlIGxvb3BpbmcgdGhyb3VnaCBhbGwgZmlsZXMgaW4gYSBmb2xkZXIsIHlvdSB3aWxsIGFsc28gbG9vcCB0aHJvdWdoIGFueSBzdWItZm9sZGVycy5cIlxyXG4gICAgICApXHJcbiAgICAgIC5hZGRUb2dnbGUoKHRvZ2dsZSkgPT4ge1xyXG4gICAgICAgIHRvZ2dsZS5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5yZWN1cnNpdmUpO1xyXG4gICAgICAgIHRvZ2dsZS5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnJlY3Vyc2l2ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAuc2V0TmFtZShcIkxpc3QgRGVsaW1pdGVyXCIpXHJcbiAgICAgIC5zZXREZXNjKFxyXG4gICAgICAgIFwiU2V0IGRlbGltaXRlciB0byB1c2Ugd2hlbiBjcmVhdGluZyBhIGxpc3QuICBDb21tYXMoLCkgYXJlIHVzZWQgYnkgZGVmYXVsdC5cIlxyXG4gICAgICApXHJcbiAgICAgIC5hZGRUZXh0KCh0ZXh0KSA9PiB7XHJcbiAgICAgICAgdGV4dC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5kZWxpbWl0ZXIpO1xyXG4gICAgICAgIHRleHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICB0ZXh0LnNldFZhbHVlKHZhbHVlWzBdKTtcclxuICAgICAgICAgICAgbmV3IE5vdGljZShcIkRlbGltaXRlciBtdXN0IGJlIGEgc2luZ2xlIGNoYXJhY3Rlci5cIik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmRlbGltaXRlciA9IHZhbHVlO1xyXG4gICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAuc2V0TmFtZShcIkRlZmF1bHQgUHJvcHMgRmlsZVwiKVxyXG4gICAgICAuc2V0RGVzYyhcclxuICAgICAgICBcIlNlbGVjdCBhIGZpbGUgd2l0aCBwcm9wZXJ0aWVzIHRoYXQgeW91IHdhbnQgdG8gbG9hZCBpbnRvIHRoZSBNdWx0aSBQcm9wZXJ0aWVzIGZvcm0gYnkgZGVmYXVsdC4gIFR5cGUgaW4gdGhlIGZ1bGwgcGF0aCBvZiB0aGUgZGVzaXJlZCBmaWxlLihleC4gVGVtcGxhdGVzL1Byb3BGaWxlIDEpXCJcclxuICAgICAgKVxyXG4gICAgICAuYWRkVGV4dCgodGV4dCkgPT4ge1xyXG4gICAgICAgIHRleHQuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuZGVmYXVsdFByb3BQYXRoKTtcclxuICAgICAgICB0ZXh0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuZGVmYXVsdFByb3BQYXRoID0gdmFsdWU7XHJcbiAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE11bHRpUHJvcFNldHRpbmdzIHtcclxuICBvdmVyd3JpdGU6IGJvb2xlYW47XHJcbiAgcmVjdXJzaXZlOiBib29sZWFuO1xyXG4gIGRlbGltaXRlcjogc3RyaW5nO1xyXG4gIGRlZmF1bHRQcm9wUGF0aDogc3RyaW5nO1xyXG59XHJcbiIsICIvKiogTW9kYWwgdG8gaG9sZCBmb3JtIHRoYXQgbGV0cyB1c2VyIHJlbW92ZSBwcm9wcyBmcm9tIHNlbGVjdGlvbi4gKi9cblxuaW1wb3J0IHsgTW9kYWwsIEFwcCwgTm90aWNlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgUmVtb3ZlUHJvcEZvcm0gZnJvbSBcIi4vUmVtb3ZlUHJvcEZvcm0uc3ZlbHRlXCI7XG5pbXBvcnQgeyBSZW1vdmVDb25maXJtTW9kYWwgfSBmcm9tIFwiLi9SZW1vdmVDb25maXJtTW9kYWxcIjtcblxuLyoqIExvYWRzIGEgbW9kYWwgYW5kIGhhbmRsZXMgZm9ybSBzdWJtaXNzaW9ucy4gKi9cbmV4cG9ydCBjbGFzcyBSZW1vdmVNb2RhbCBleHRlbmRzIE1vZGFsIHtcbiAgbmFtZXM6IHN0cmluZ1tdO1xuICBwcm9wczogc3RyaW5nW107XG4gIHN1Ym1pc3Npb246IChjdXN0b21Qcm9wczogc3RyaW5nW10pID0+IFByb21pc2U8dm9pZD47XG4gIGNvbXBvbmVudDogUmVtb3ZlUHJvcEZvcm07XG5cbiAgY29uc3RydWN0b3IoXG4gICAgYXBwOiBBcHAsXG4gICAgbmFtZXM6IHN0cmluZ1tdLFxuICAgIHN1Ym1pc3Npb246IChjdXN0b21Qcm9wczogc3RyaW5nW10pID0+IFByb21pc2U8dm9pZD5cbiAgKSB7XG4gICAgaWYgKCFuYW1lcyB8fCBuYW1lcy5sZW5ndGggPT09IDApIHtcbiAgICAgIG5ldyBOb3RpY2UoXCJObyBwcm9wZXJ0aWVzIHRvIHJlbW92ZVwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIoYXBwKTtcbiAgICB0aGlzLm5hbWVzID0gbmFtZXM7XG4gICAgdGhpcy5zdWJtaXNzaW9uID0gc3VibWlzc2lvbjtcbiAgfVxuXG4gIGFzeW5jIG9uQ29uZmlybShib29sOiBib29sZWFuKSB7XG4gICAgaWYgKGJvb2wpIHtcbiAgICAgIGF3YWl0IHRoaXMuc3VibWlzc2lvbih0aGlzLnByb3BzKTtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9XG4gIH1cblxuICBvblN1Ym1pdChwcm9wczogc3RyaW5nW10pIHtcbiAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgbmV3IFJlbW92ZUNvbmZpcm1Nb2RhbChcbiAgICAgIHRoaXMuYXBwLFxuICAgICAgdGhpcy5wcm9wcyxcbiAgICAgIHRoaXMub25Db25maXJtLmJpbmQodGhpcylcbiAgICApLm9wZW4oKTtcbiAgfVxuXG4gIG9uT3BlbigpOiB2b2lkIHtcbiAgICB0aGlzLnRpdGxlRWwuY3JlYXRlRWwoXCJoMlwiLCB7IHRleHQ6IFwiUmVtb3ZlIFByb3BlcnRpZXNcIiB9KTtcblxuICAgIHRoaXMuY29tcG9uZW50ID0gbmV3IFJlbW92ZVByb3BGb3JtKHtcbiAgICAgIHRhcmdldDogdGhpcy5jb250ZW50RWwsXG4gICAgICBwcm9wczoge1xuICAgICAgICBuYW1lczogdGhpcy5uYW1lcyxcbiAgICAgICAgc3VibWlzc2lvbjogdGhpcy5vblN1Ym1pdC5iaW5kKHRoaXMpLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxufVxuIiwgIjxzY3JpcHQgbGFuZz1cInRzXCI+XHJcbiAgZXhwb3J0IGxldCBuYW1lczogc3RyaW5nW10gPSBbXTtcclxuICBleHBvcnQgbGV0IHN1Ym1pc3Npb246IChwcm9wczogc3RyaW5nW10pID0+IHZvaWQ7XHJcblxyXG4gIGxldCBlcnJvckVsOiBIVE1MRGl2RWxlbWVudDtcclxuICBsZXQgYWxlcnRUZXh0ID0gXCIuXCI7XHJcbiAgLy9sZXQgcHJvcE5hbWVzOiBzdHJpbmdbXSA9IFtdO1xyXG5cclxuICBsZXQgY2hlY2tDb3VudCA9IDA7XHJcbiAgJDogaXNNYXhDaGVja2VkID0gY2hlY2tDb3VudCA+PSBuYW1lcy5sZW5ndGg7XHJcbiAgJDogY29uc29sZS5sb2coaXNNYXhDaGVja2VkKTtcclxuXHJcbiAgbGV0IGlucHV0czogeyBuYW1lOiBzdHJpbmc7IGlzQ2hlY2tlZDogYm9vbGVhbiB9W10gPSBbXTtcclxuICBmb3IgKGxldCBuYW1lIG9mIG5hbWVzKSB7XHJcbiAgICBpbnB1dHMucHVzaCh7IG5hbWUsIGlzQ2hlY2tlZDogZmFsc2UgfSk7XHJcbiAgfVxyXG5cclxuICBuYW1lcy5zb3J0KCk7XHJcblxyXG4gIC8vIGZ1bmN0aW9uIGhhbmRsZUNoZWNrYm94Q2hhbmdlKGV2ZW50OiBhbnksIHN0cmluZzogc3RyaW5nKSB7XHJcbiAgLy8gXHRjb25zdCBpc0NoZWNrZWQgPSBldmVudC50YXJnZXQuY2hlY2tlZDtcclxuICAvLyBcdGlmIChpc0NoZWNrZWQpIHtcclxuICAvLyBcdFx0cHJvcE5hbWVzID0gWy4uLnByb3BOYW1lcywgc3RyaW5nXTtcclxuICAvLyBcdH0gZWxzZSB7XHJcbiAgLy8gXHRcdHByb3BOYW1lcyA9IHByb3BOYW1lcy5maWx0ZXIoKHNlbGVjdGVkKSA9PiBzZWxlY3RlZCAhPT0gc3RyaW5nKTtcclxuICAvLyBcdH1cclxuICAvLyB9XHJcblxyXG4gIGZ1bmN0aW9uIG9uQ2hlY2tib3hDaGFuZ2UoZXZlbnQ6IGFueSkge1xyXG4gICAgbGV0IGNoZWNrZWQgPSBldmVudC50YXJnZXQuY2hlY2tlZDtcclxuICAgIGNoZWNrZWQgPyBjaGVja0NvdW50KysgOiBjaGVja0NvdW50LS07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB0b2dnbGVBbGwoKSB7XHJcbiAgICBpZiAoaXNNYXhDaGVja2VkKSB7XHJcbiAgICAgIGlucHV0cyA9IGlucHV0cy5tYXAoKGlucHV0KSA9PiAoeyAuLi5pbnB1dCwgaXNDaGVja2VkOiBmYWxzZSB9KSk7XHJcbiAgICAgIGNoZWNrQ291bnQgPSAwO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaW5wdXRzID0gaW5wdXRzLm1hcCgoaW5wdXQpID0+ICh7IC4uLmlucHV0LCBpc0NoZWNrZWQ6IHRydWUgfSkpO1xyXG4gICAgICBjaGVja0NvdW50ID0gbmFtZXMubGVuZ3RoO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gb25TdWJtaXQoKSB7XHJcbiAgICBpZiAoY2hlY2tDb3VudCA9PT0gMCkge1xyXG4gICAgICBhbGVydFRleHQgPSBcIlBsZWFzZSBzZWxlY3QgYXQgbGVhc3Qgb25lIHByb3BlcnR5IHRvIHJlbW92ZS5cIjtcclxuICAgICAgZXJyb3JFbC5jbGFzc0xpc3QucmVtb3ZlKFwiaGlkZGVuXCIpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBsZXQgcHJvcE5hbWVzID0gaW5wdXRzXHJcbiAgICAgIC5maWx0ZXIoKGlucHV0KSA9PiBpbnB1dC5pc0NoZWNrZWQpXHJcbiAgICAgIC5tYXAoKGlucHV0KSA9PiBpbnB1dC5uYW1lKTtcclxuICAgIHN1Ym1pc3Npb24ocHJvcE5hbWVzKTtcclxuICB9XHJcbjwvc2NyaXB0PlxyXG5cclxuPGRpdj5cclxuICA8ZGl2IGlkPVwiYWxlcnQtY29udGFpbmVyXCIgY2xhc3M9XCJhbGVydC1jb250YWluZXIgaGlkZGVuXCIgYmluZDp0aGlzPXtlcnJvckVsfT5cclxuICAgIDxkaXY+RVJST1I8L2Rpdj5cclxuICAgIDxkaXYgaWQ9XCJhbGVydC10ZXh0XCI+e2FsZXJ0VGV4dH08L2Rpdj5cclxuICA8L2Rpdj5cclxuICA8cD5TZWxlY3QgdGhlIHByb3BlcnRpZXMgeW91IHdpc2ggdG8gcmVtb3ZlIGZyb20gdGhlIGZpbGUgc2VsZWN0aW9uLjwvcD5cclxuICA8Zm9ybSBvbjpzdWJtaXR8cHJldmVudERlZmF1bHQ+XHJcbiAgICA8ZGl2IGNsYXNzPVwibmFtZS1jb250YWluZXJcIj5cclxuICAgICAgeyNlYWNoIGlucHV0cyBhcyBpbnB1dH1cclxuICAgICAgICA8bGFiZWw+XHJcbiAgICAgICAgICA8aW5wdXRcclxuICAgICAgICAgICAgdHlwZT1cImNoZWNrYm94XCJcclxuICAgICAgICAgICAgYmluZDp2YWx1ZT17aW5wdXQubmFtZX1cclxuICAgICAgICAgICAgYmluZDpjaGVja2VkPXtpbnB1dC5pc0NoZWNrZWR9XHJcbiAgICAgICAgICAgIG9uOmNoYW5nZT17KGV2ZW50KSA9PiBvbkNoZWNrYm94Q2hhbmdlKGV2ZW50KX1cclxuICAgICAgICAgIC8+XHJcbiAgICAgICAgICB7aW5wdXQubmFtZX1cclxuICAgICAgICA8L2xhYmVsPlxyXG4gICAgICB7L2VhY2h9XHJcbiAgICA8L2Rpdj5cclxuICAgIDxkaXYgY2xhc3M9XCJidXR0b24tY29udGFpbmVyXCI+XHJcbiAgICAgIDxidXR0b24gb246Y2xpY2s9e29uU3VibWl0fSB0eXBlPVwic3VibWl0XCI+Q29uZmlybTwvYnV0dG9uPlxyXG4gICAgICA8YnV0dG9uIG9uOmNsaWNrPXt0b2dnbGVBbGx9XHJcbiAgICAgICAgPntpc01heENoZWNrZWQgPyBcIlVuY2hlY2sgQWxsXCIgOiBcIkNoZWNrIEFsbFwifTwvYnV0dG9uXHJcbiAgICAgID5cclxuICAgIDwvZGl2PlxyXG4gIDwvZm9ybT5cclxuPC9kaXY+XHJcblxyXG48c3R5bGU+XHJcbiAgLm5hbWUtY29udGFpbmVyIHtcclxuICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xyXG4gICAgZ2FwOiA1cHg7XHJcbiAgICBtYXJnaW4tdG9wOiAxMHB4O1xyXG4gICAgbWFyZ2luLWJvdHRvbTogMjBweDtcclxuICB9XHJcbiAgLmFsZXJ0LWNvbnRhaW5lciB7XHJcbiAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcclxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XHJcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcclxuICAgIG1hcmdpbi1ib3R0b206IDEwcHg7XHJcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZWQ7XHJcbiAgICBmb250LXdlaWdodDogYm9sZDtcclxuICB9XHJcblxyXG4gIC5idXR0b24tY29udGFpbmVyIHtcclxuICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xyXG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xyXG4gIH1cclxuICAuaGlkZGVuIHtcclxuICAgIGRpc3BsYXk6IG5vbmU7XHJcbiAgfVxyXG48L3N0eWxlPlxyXG4iLCAiLyoqIE1vZGFsIHRvIGhvbGQgZm9ybSB0aGF0IGxldHMgdXNlciByZW1vdmUgcHJvcHMgZnJvbSBzZWxlY3Rpb24uICovXG5cbmltcG9ydCB7IE1vZGFsLCBBcHAsIE5vdGljZSB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IFJlbW92ZUNvbmZpcm1Gb3JtIGZyb20gXCIuL1JlbW92ZUNvbmZpcm1Gb3JtLnN2ZWx0ZVwiO1xuaW1wb3J0IE11bHRpUHJvcFBsdWdpbiBmcm9tIFwiLi9tYWluXCI7XG5cbi8qKiBMb2FkcyBhIG1vZGFsIGFuZCBoYW5kbGVzIGZvcm0gc3VibWlzc2lvbnMuICovXG5leHBvcnQgY2xhc3MgUmVtb3ZlQ29uZmlybU1vZGFsIGV4dGVuZHMgTW9kYWwge1xuICBuYW1lczogc3RyaW5nW107XG4gIHN1Ym1pc3Npb246IChib29sOiBib29sZWFuKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBjb21wb25lbnQ6IFJlbW92ZUNvbmZpcm1Gb3JtO1xuXG4gIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBuYW1lczogc3RyaW5nW10sIHN1Ym1pc3Npb246IChib29sOiBib29sZWFuKSA9PiBQcm9taXNlPHZvaWQ+KSB7XG4gICAgc3VwZXIoYXBwKTtcbiAgICB0aGlzLm5hbWVzID0gbmFtZXM7XG4gICAgdGhpcy5zdWJtaXNzaW9uID0gc3VibWlzc2lvbjtcbiAgfVxuXG4gIGFzeW5jIG9uU3VibWl0KCkge1xuICAgIGF3YWl0IHRoaXMuc3VibWlzc2lvbih0cnVlKTtcbiAgICB0aGlzLmNsb3NlKCk7XG4gIH1cblxuICBvbkNhbmNlbCgpIHtcbiAgICB0aGlzLnN1Ym1pc3Npb24oZmFsc2UpO1xuICAgIHRoaXMuY2xvc2UoKTtcbiAgfVxuXG4gIG9uT3BlbigpOiB2b2lkIHtcbiAgICAvL1ByZXZlbnQgbW9kYWwgZnJvbSBvcGVuaW5nIGlmIG5vIG5hbWVzIGFyZSBwYXNzZWQuXG4gICAgaWYgKCF0aGlzLm5hbWVzIHx8IHRoaXMubmFtZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBuZXcgTm90aWNlKFwiUGxlYXNlIGNoZWNrIGF0IGxlYXN0IG9uZSBwcm9wZXJ0eSB0byByZW1vdmUuXCIpO1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH1cbiAgICB0aGlzLnRpdGxlRWwuY3JlYXRlRWwoXCJoMlwiLCB7IHRleHQ6IFwiUmVtb3ZlIFByb3BlcnRpZXNcIiB9KTtcblxuICAgIHRoaXMuY29tcG9uZW50ID0gbmV3IFJlbW92ZUNvbmZpcm1Gb3JtKHtcbiAgICAgIHRhcmdldDogdGhpcy5jb250ZW50RWwsXG4gICAgICBwcm9wczoge1xuICAgICAgICBuYW1lczogdGhpcy5uYW1lcyxcbiAgICAgICAgc3VibWlzc2lvbjogdGhpcy5vblN1Ym1pdC5iaW5kKHRoaXMpLFxuICAgICAgICBjYW5jZWw6IHRoaXMub25DYW5jZWwuYmluZCh0aGlzKSxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cbn1cbiIsICI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxyXG5cdGltcG9ydCB7IG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XHJcblxyXG5cdGV4cG9ydCBsZXQgbmFtZXM6IHN0cmluZ1tdID0gW1widGVzdFwiLCBcInRlc3QyXCJdO1xyXG5cdGV4cG9ydCBsZXQgc3VibWlzc2lvbjogKCkgPT4gdm9pZDtcclxuXHRleHBvcnQgbGV0IGNhbmNlbDogKCkgPT4gdm9pZDtcclxuXHJcblx0bGV0IGJ0bkNhbmNlbDogSFRNTEJ1dHRvbkVsZW1lbnQ7XHJcblxyXG5cdGNvbnN0IHdvcmQgPSBuYW1lcy5sZW5ndGggPiAxID8gXCJwcm9wZXJ0aWVzXCIgOiBcInByb3BlcnR5XCI7XHJcblxyXG5cdC8vRm9jdXMgb24gY2FuY2VsIHRvIG1ha2Ugc3VyZSB1c2VyIGRvZXMgbm90IGVhc2lseSBzdWJtaXQgY2hhbmdlcy5cclxuXHRvbk1vdW50KCgpID0+IHtcclxuXHRcdGJ0bkNhbmNlbC5mb2N1cygpO1xyXG5cdH0pO1xyXG48L3NjcmlwdD5cclxuXHJcbjxkaXY+XHJcblx0PGZvcm0gb246c3VibWl0fHByZXZlbnREZWZhdWx0PXtzdWJtaXNzaW9ufT5cclxuXHRcdDxwPlRoZSBmb2xsb3dpbmcge3dvcmR9IHdpbGwgYmUgcmVtb3ZlZDo8L3A+XHJcblx0XHQ8dWw+XHJcblx0XHRcdHsjZWFjaCBuYW1lcyBhcyBuYW1lfVxyXG5cdFx0XHRcdDxsaT5cclxuXHRcdFx0XHRcdHtuYW1lfVxyXG5cdFx0XHRcdDwvbGk+XHJcblx0XHRcdHsvZWFjaH1cclxuXHRcdDwvdWw+XHJcblx0XHQ8cD5BcmUgeW91IHN1cmUgeW91IHdpc2ggdG8gcHJvY2VlZD88L3A+XHJcblx0XHQ8YnV0dG9uIGNsYXNzPVwibW9kLXdhcm5pbmdcIiB0eXBlPVwic3VibWl0XCI+RGVsZXRlPC9idXR0b24+XHJcblx0XHQ8YnV0dG9uIG9uOmNsaWNrPXtjYW5jZWx9IGJpbmQ6dGhpcz17YnRuQ2FuY2VsfT5DYW5jZWw8L2J1dHRvbj5cclxuXHQ8L2Zvcm0+XHJcbjwvZGl2PlxyXG4iLCAiaW1wb3J0IHsgQXBwLCBNb2RhbCB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IFJlbW92ZVZhbHVlRm9ybSBmcm9tIFwiLi9SZW1vdmVWYWx1ZUZvcm0uc3ZlbHRlXCI7XG5cbmV4cG9ydCBjbGFzcyBSZW1vdmVWYWx1ZU1vZGFsIGV4dGVuZHMgTW9kYWwge1xuICBjb21wb25lbnQ6IFJlbW92ZVZhbHVlRm9ybTtcbiAgcHJvcGVydGllczogc3RyaW5nW107XG4gIGdldFZhbHVlczogKHByb3BlcnR5OiBzdHJpbmcpID0+IFByb21pc2U8c3RyaW5nW10+O1xuICBvblN1Ym1pdDogKHNlbGVjdGVkUHJvcGVydHk6IHN0cmluZywgdmFsdWVzVG9SZW1vdmU6IHN0cmluZ1tdKSA9PiB2b2lkO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIGFwcDogQXBwLFxuICAgIHByb3BlcnRpZXM6IHN0cmluZ1tdLFxuICAgIGdldFZhbHVlczogKHByb3BlcnR5OiBzdHJpbmcpID0+IFByb21pc2U8c3RyaW5nW10+LFxuICAgIG9uU3VibWl0OiAoc2VsZWN0ZWRQcm9wZXJ0eTogc3RyaW5nLCB2YWx1ZXNUb1JlbW92ZTogc3RyaW5nW10pID0+IHZvaWRcbiAgKSB7XG4gICAgc3VwZXIoYXBwKTtcbiAgICB0aGlzLnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xuICAgIHRoaXMuZ2V0VmFsdWVzID0gZ2V0VmFsdWVzO1xuICAgIHRoaXMub25TdWJtaXQgPSBvblN1Ym1pdDtcbiAgfVxuXG4gIG9uT3BlbigpIHtcbiAgICBjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcbiAgICB0aGlzLmNvbXBvbmVudCA9IG5ldyBSZW1vdmVWYWx1ZUZvcm0oe1xuICAgICAgdGFyZ2V0OiBjb250ZW50RWwsXG4gICAgICBwcm9wczoge1xuICAgICAgICBwcm9wZXJ0aWVzOiB0aGlzLnByb3BlcnRpZXMsXG4gICAgICAgIGdldFZhbHVlczogdGhpcy5nZXRWYWx1ZXMsXG4gICAgICAgIG9uU3VibWl0OiAoc2VsZWN0ZWRQcm9wZXJ0eTogc3RyaW5nLCB2YWx1ZXNUb1JlbW92ZTogc3RyaW5nW10pID0+IHtcbiAgICAgICAgICB0aGlzLm9uU3VibWl0KHNlbGVjdGVkUHJvcGVydHksIHZhbHVlc1RvUmVtb3ZlKTtcbiAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgdGhpcy5jb21wb25lbnQuJG9uKFwiY2FuY2VsXCIsICgpID0+IHtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9KTtcbiAgfVxuXG4gIG9uQ2xvc2UoKSB7XG4gICAgY29uc3QgeyBjb250ZW50RWwgfSA9IHRoaXM7XG4gICAgY29udGVudEVsLmVtcHR5KCk7XG4gIH1cbn1cbiIsICI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuICBpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tIFwic3ZlbHRlXCI7XG5cbiAgZXhwb3J0IGxldCBwcm9wZXJ0aWVzOiBzdHJpbmdbXTtcbiAgZXhwb3J0IGxldCBnZXRWYWx1ZXM6IChwcm9wZXJ0eTogc3RyaW5nKSA9PiBQcm9taXNlPHN0cmluZ1tdPjtcbiAgZXhwb3J0IGxldCBvblN1Ym1pdDogKHNlbGVjdGVkUHJvcGVydHk6IHN0cmluZywgdmFsdWVzVG9SZW1vdmU6IHN0cmluZ1tdKSA9PiB2b2lkO1xuXG4gIGxldCBzZWxlY3RlZFByb3BlcnR5OiBzdHJpbmcgPSBcIlwiO1xuICBsZXQgdmFsdWVzOiBzdHJpbmdbXSA9IFtdO1xuICBsZXQgc2VsZWN0ZWRWYWx1ZXM6IHN0cmluZ1tdID0gW107XG5cbiAgY29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKTtcblxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVQcm9wZXJ0eUNoYW5nZSgpIHtcbiAgICBpZiAoc2VsZWN0ZWRQcm9wZXJ0eSkge1xuICAgICAgdmFsdWVzID0gYXdhaXQgZ2V0VmFsdWVzKHNlbGVjdGVkUHJvcGVydHkpO1xuICAgICAgc2VsZWN0ZWRWYWx1ZXMgPSBbXTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVTdWJtaXQoKSB7XG4gICAgaWYgKHNlbGVjdGVkUHJvcGVydHkgJiYgc2VsZWN0ZWRWYWx1ZXMubGVuZ3RoID4gMCkge1xuICAgICAgb25TdWJtaXQoc2VsZWN0ZWRQcm9wZXJ0eSwgc2VsZWN0ZWRWYWx1ZXMpO1xuICAgICAgZGlzcGF0Y2goXCJzdWJtaXRcIik7XG4gICAgfVxuICB9XG48L3NjcmlwdD5cblxuPGZvcm0gb246c3VibWl0fHByZXZlbnREZWZhdWx0PXtoYW5kbGVTdWJtaXR9PlxuICA8ZGl2IGNsYXNzPVwibW9kYWwtY29udGVudFwiPlxuICAgIDxoMj5SZW1vdmUgVmFsdWUgZnJvbSBQcm9wZXJ0eTwvaDI+XG4gICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXBcIj5cbiAgICAgIDxsYWJlbCBmb3I9XCJwcm9wZXJ0eS1zZWxlY3RcIj5TZWxlY3QgUHJvcGVydHk8L2xhYmVsPlxuICAgICAgPHNlbGVjdCBpZD1cInByb3BlcnR5LXNlbGVjdFwiIGJpbmQ6dmFsdWU9e3NlbGVjdGVkUHJvcGVydHl9IG9uOmNoYW5nZT17aGFuZGxlUHJvcGVydHlDaGFuZ2V9IHJlcXVpcmVkPlxuICAgICAgICA8b3B0aW9uIHZhbHVlPVwiXCIgZGlzYWJsZWQ+Q2hvb3NlIGEgcHJvcGVydHkuLi48L29wdGlvbj5cbiAgICAgICAgeyNlYWNoIHByb3BlcnRpZXMgYXMgcHJvcH1cbiAgICAgICAgICA8b3B0aW9uIHZhbHVlPXtwcm9wfT57cHJvcH08L29wdGlvbj5cbiAgICAgICAgey9lYWNofVxuICAgICAgPC9zZWxlY3Q+XG4gICAgPC9kaXY+XG5cbiAgICB7I2lmIHNlbGVjdGVkUHJvcGVydHl9XG4gICAgICA8ZmllbGRzZXQgY2xhc3M9XCJmb3JtLWdyb3VwXCI+XG4gICAgICAgIDxsZWdlbmQ+U2VsZWN0IFZhbHVlcyB0byBSZW1vdmU8L2xlZ2VuZD5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNoZWNrYm94LWdyb3VwXCI+XG4gICAgICAgICAgeyNlYWNoIHZhbHVlcyBhcyB2YWx1ZX1cbiAgICAgICAgICAgIDxsYWJlbD5cbiAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGJpbmQ6Z3JvdXA9e3NlbGVjdGVkVmFsdWVzfSB2YWx1ZT17dmFsdWV9IC8+XG4gICAgICAgICAgICAgIHt2YWx1ZX1cbiAgICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgICAgey9lYWNofVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZmllbGRzZXQ+XG4gICAgey9pZn1cbiAgPC9kaXY+XG4gIDxkaXYgY2xhc3M9XCJtb2RhbC1mb290ZXJcIj5cbiAgICA8YnV0dG9uIHR5cGU9XCJzdWJtaXRcIiBjbGFzcz1cIm1vZC1jdGFcIiBkaXNhYmxlZD17c2VsZWN0ZWRWYWx1ZXMubGVuZ3RoID09PSAwfT5SZW1vdmUgVmFsdWVzPC9idXR0b24+XG4gICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgb246Y2xpY2s9eygpID0+IGRpc3BhdGNoKFwiY2FuY2VsXCIpfT5DYW5jZWw8L2J1dHRvbj5cbiAgPC9kaXY+XG48L2Zvcm0+XG4iLCAiaW1wb3J0IHsgQXBwLCBURmlsZSB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHsgTmV3UHJvcERhdGEgfSBmcm9tIFwiLi9tYWluXCI7XG5cbnR5cGUgRmlsZVByb2Nlc3NvciA9IChmaWxlOiBURmlsZSwgY2FsbGJhY2s6IChmcm9udG1hdHRlcjogYW55KSA9PiB2b2lkKSA9PiBQcm9taXNlPHZvaWQ+IHwgdm9pZDtcblxuLyoqIEFkZCBwcm9wZXJ0aWVzIGZyb20gYSBNYXAgdG8gYSBub3RlLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYWRkUHJvcGVydGllcyhcbiAgZmlsZVByb2Nlc3NvcjogRmlsZVByb2Nlc3NvcixcbiAgZmlsZTogVEZpbGUsXG4gIHByb3BzOiBNYXA8c3RyaW5nLCBOZXdQcm9wRGF0YT4sXG4gIG92ZXJ3cml0ZTogYm9vbGVhbixcbiAgcHJvcENhY2hlOiBhbnlcbikge1xuICBhd2FpdCBmaWxlUHJvY2Vzc29yKGZpbGUsIChmcm9udG1hdHRlcikgPT4ge1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHByb3BzKSB7XG4gICAgICBpZiAoa2V5ID09PSBcInRhZ3NcIikge1xuICAgICAgICBjb25zdCBleGlzdGluZ1RhZ3MgPSBmcm9udG1hdHRlcltrZXldIHx8IFtdO1xuICAgICAgICBjb25zdCBuZXdUYWdzID0gQXJyYXkuaXNBcnJheSh2YWx1ZS5kYXRhKSA/IHZhbHVlLmRhdGEgOiBbdmFsdWUuZGF0YV07XG4gICAgICAgIGZyb250bWF0dGVyW2tleV0gPSBbLi4ubmV3IFNldChbLi4uZXhpc3RpbmdUYWdzLCAuLi5uZXdUYWdzXSldO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFmcm9udG1hdHRlcltrZXldIHx8IG92ZXJ3cml0ZSkge1xuICAgICAgICBmcm9udG1hdHRlcltrZXldID0gdmFsdWUuZGF0YTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vQ29tcGFyZSB0eXBlcyB0byBzZWUgaWYgdGhleSBjYW4gYmUgYXBwZW5kZWQuXG4gICAgICBsZXQgdHlwZTEgPSB2YWx1ZS50eXBlO1xuICAgICAgbGV0IHR5cGUyID0gcHJvcENhY2hlW2tleS50b0xvd2VyQ2FzZSgpXS50eXBlO1xuXG4gICAgICBpZiAoY2FuQmVBcHBlbmRlZCh0eXBlMSwgdHlwZTIpKSB7XG4gICAgICAgIGlmIChmcm9udG1hdHRlcltrZXldID09PSB2YWx1ZS5kYXRhKSBjb250aW51ZTsgLy9MZWF2ZSBpZGVudGljYWwgdmFsdWVzIGFsb25lLlxuICAgICAgICBpZiAoIXZhbHVlLmRhdGEpIGNvbnRpbnVlOyAvL0RvIG5vdCBtZXJnZSBlbXB0eSB2YWx1ZXMuXG5cbiAgICAgICAgbGV0IGFyciA9IG1lcmdlSW50b0FycmF5cyhmcm9udG1hdHRlcltrZXldLCB2YWx1ZS5kYXRhKTtcbiAgICAgICAgZnJvbnRtYXR0ZXJba2V5XSA9IGFycjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcm9udG1hdHRlcltrZXldID0gdmFsdWUuZGF0YTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuLyoqIEl0ZXJhdGUgdGhyb3VnaCBhbGwgcHJvcHMgaW4gYSBsaXN0IGFuZCBhZGQgdGhlbSB0byBhbiBleGlzdGluZyBzZXQuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYWRkUHJvcFRvU2V0KGZpbGVQcm9jZXNzb3I6IEZpbGVQcm9jZXNzb3IsIHNldDogU2V0PHN0cmluZz4sIGZpbGU6IFRGaWxlKSB7XG4gIGF3YWl0IGZpbGVQcm9jZXNzb3IoZmlsZSwgKGZyb250bWF0dGVyKSA9PiB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZnJvbnRtYXR0ZXIpIHtcbiAgICAgIGNvbnNvbGUubG9nKHsga2V5IH0pO1xuICAgICAgc2V0LmFkZChrZXkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBzZXQ7XG59XG5cbi8qKiBSZW1vdmUgcHJvcGVydGllcyBmcm9tIGEgbm90ZS4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZW1vdmVQcm9wZXJ0aWVzKGZpbGVQcm9jZXNzb3I6IEZpbGVQcm9jZXNzb3IsIGZpbGU6IFRGaWxlLCBwcm9wczogc3RyaW5nW10pIHtcbiAgYXdhaXQgZmlsZVByb2Nlc3NvcihmaWxlLCAoZnJvbnRtYXR0ZXIpID0+IHtcbiAgICBmb3IgKGNvbnN0IHByb3Agb2YgcHJvcHMpIHtcbiAgICAgIC8vZGVsZXRlIGZyb250bWF0dGVyW3Byb3BdO1xuICAgICAgZnJvbnRtYXR0ZXJbcHJvcF0gPSB1bmRlZmluZWQ7IC8vXCJIYWNreVwiIHdvcmthcm91bmQsIGNvbW1lbnRlZCBjb2RlIHdpbGwgd29yayBpbiBsYXRlciB2ZXJzaW9uLlwiXG4gICAgfVxuICB9KTtcbn1cblxuLyoqIENoZWNrIGlmIHR3byB0eXBlcyBjYW4gYmUgYXBwZW5kZWQgdG8gZWFjaCBvdGhlci4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYW5CZUFwcGVuZGVkKHN0cjE6IHN0cmluZywgc3RyMjogc3RyaW5nKSB7XG4gIGxldCBhcnIgPSBbXCJudW1iZXJcIiwgXCJkYXRlXCIsIFwiZGF0ZXRpbWVcIiwgXCJjaGVja2JveFwiXTsgLy9UaGVzZSB2YWx1ZXMgc2hvdWxkIG5vdCBiZSBhcHBlbmRlZC5cbiAgaWYgKGFyci5pbmNsdWRlcyhzdHIxKSB8fCBhcnIuaW5jbHVkZXMoc3RyMikpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKiBDb252ZXJ0IHN0cmluZ3MgYW5kIGFycmF5cyBpbnRvIHNpbmdsZSBhcnJheS4gKi9cbmZ1bmN0aW9uIG1lcmdlSW50b0FycmF5cyguLi5hcmdzOiAoc3RyaW5nIHwgc3RyaW5nW10pW10pOiBzdHJpbmdbXSB7XG4gIGNvbnN0IGFycmF5cyA9IGFyZ3MubWFwKChhcmcpID0+IChBcnJheS5pc0FycmF5KGFyZykgPyBhcmcgOiBbYXJnXSkpO1xuXG4gIC8vIEZsYXR0ZW4gdGhlIGFycmF5XG4gIGNvbnN0IGZsYXR0ZW5lZCA9IGFycmF5cy5mbGF0KCk7XG5cbiAgLy8gUmVtb3ZlIGR1cGxpY2F0ZXMgdXNpbmcgU2V0IGFuZCBzcHJlYWQgaXQgaW50byBhbiBhcnJheVxuICBjb25zdCB1bmlxdWUgPSBbLi4ubmV3IFNldChmbGF0dGVuZWQpXTtcblxuICByZXR1cm4gdW5pcXVlO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYWRkVmFsdWVUb1Byb3BlcnR5KFxuICBmaWxlUHJvY2Vzc29yOiBGaWxlUHJvY2Vzc29yLFxuICBmaWxlOiBURmlsZSxcbiAgcHJvcGVydHk6IHN0cmluZyxcbiAgdmFsdWU6IHN0cmluZ1xuKSB7XG4gIGF3YWl0IGZpbGVQcm9jZXNzb3IoZmlsZSwgKGZyb250bWF0dGVyKSA9PiB7XG4gICAgaWYgKGZyb250bWF0dGVyW3Byb3BlcnR5XSkge1xuICAgICAgY29uc3QgZXhpc3RpbmdWYWx1ZXMgPSBBcnJheS5pc0FycmF5KGZyb250bWF0dGVyW3Byb3BlcnR5XSlcbiAgICAgICAgPyBmcm9udG1hdHRlcltwcm9wZXJ0eV1cbiAgICAgICAgOiBbZnJvbnRtYXR0ZXJbcHJvcGVydHldXTtcbiAgICAgIGNvbnN0IG5ld1ZhbHVlcyA9IFsuLi5uZXcgU2V0KFsuLi5leGlzdGluZ1ZhbHVlcywgdmFsdWVdKV07XG4gICAgICBmcm9udG1hdHRlcltwcm9wZXJ0eV0gPSBuZXdWYWx1ZXM7XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlbW92ZVZhbHVlc0Zyb21Qcm9wZXJ0eShcbiAgZmlsZVByb2Nlc3NvcjogRmlsZVByb2Nlc3NvcixcbiAgZmlsZTogVEZpbGUsXG4gIHByb3BlcnR5OiBzdHJpbmcsXG4gIHZhbHVlc1RvUmVtb3ZlOiBzdHJpbmdbXVxuKSB7XG4gIGF3YWl0IGZpbGVQcm9jZXNzb3IoZmlsZSwgKGZyb250bWF0dGVyKSA9PiB7XG4gICAgaWYgKGZyb250bWF0dGVyW3Byb3BlcnR5XSAmJiBBcnJheS5pc0FycmF5KGZyb250bWF0dGVyW3Byb3BlcnR5XSkpIHtcbiAgICAgIGZyb250bWF0dGVyW3Byb3BlcnR5XSA9IGZyb250bWF0dGVyW3Byb3BlcnR5XS5maWx0ZXIoXG4gICAgICAgICh2YWx1ZTogc3RyaW5nKSA9PiAhdmFsdWVzVG9SZW1vdmUuaW5jbHVkZXModmFsdWUpXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRVbmlxdWVWYWx1ZXMoXG4gIGFwcDogQXBwLFxuICBmaWxlczogVEZpbGVbXSxcbiAgcHJvcGVydHk6IHN0cmluZ1xuKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICBjb25zdCB2YWx1ZXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgZm9yIChjb25zdCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgYXdhaXQgYXBwLmZpbGVNYW5hZ2VyLnByb2Nlc3NGcm9udE1hdHRlcihmaWxlLCAoZnJvbnRtYXR0ZXIpID0+IHtcbiAgICAgIGlmIChmcm9udG1hdHRlcltwcm9wZXJ0eV0gJiYgQXJyYXkuaXNBcnJheShmcm9udG1hdHRlcltwcm9wZXJ0eV0pKSB7XG4gICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgZnJvbnRtYXR0ZXJbcHJvcGVydHldKSB7XG4gICAgICAgICAgdmFsdWVzLmFkZCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gWy4uLnZhbHVlc107XG59Il0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUEsbUJBQTRHOzs7QUNBNUcsSUFBQUMsbUJBQTJCOzs7QUNDcEIsU0FBUyxPQUFPO0FBQUM7QUFzQ2pCLFNBQVMsSUFBSSxJQUFJO0FBQ3ZCLFNBQU8sR0FBRztBQUNYO0FBRU8sU0FBUyxlQUFlO0FBQzlCLFNBQU8sdUJBQU8sT0FBTyxJQUFJO0FBQzFCO0FBTU8sU0FBUyxRQUFRLEtBQUs7QUFDNUIsTUFBSSxRQUFRLEdBQUc7QUFDaEI7QUFNTyxTQUFTLFlBQVksT0FBTztBQUNsQyxTQUFPLE9BQU8sVUFBVTtBQUN6QjtBQUdPLFNBQVMsZUFBZSxHQUFHLEdBQUc7QUFDcEMsU0FBTyxLQUFLLElBQUksS0FBSyxJQUFJLE1BQU0sS0FBTSxLQUFLLE9BQU8sTUFBTSxZQUFhLE9BQU8sTUFBTTtBQUNsRjtBQXNETyxTQUFTLFNBQVMsS0FBSztBQUM3QixTQUFPLE9BQU8sS0FBSyxHQUFHLEVBQUUsV0FBVztBQUNwQzs7O0FDekhPLElBQU0sVUFDWixPQUFPLFdBQVcsY0FDZixTQUNBLE9BQU8sZUFBZSxjQUN0QjtBQUFBO0FBQUEsRUFFQTtBQUFBOzs7QUNBRyxJQUFNLDBCQUFOLE1BQU0seUJBQXdCO0FBQUE7QUFBQSxFQWtCcEMsWUFBWSxTQUFTO0FBWnJCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxzQ0FBYSxhQUFhLFVBQVUsb0JBQUksUUFBUSxJQUFJO0FBTXBEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUFBO0FBSUMsU0FBSyxVQUFVO0FBQUEsRUFDaEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFP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QUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQ0Q7Ozs7Ozs7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O0FBQ3BELFlBQU0sV0FBVyxJQUFJLFlBQVk7QUFDakMsWUFBTSxNQUFNO0FBQUEsUUFDVixNQUFNO0FBQUEsUUFDTjtBQUFBLFFBQ0EsTUFBTSxpQkFBaUIsUUFBUSxFQUFFO0FBQUEsTUFDbkM7QUFFQSxhQUFPLEtBQUssR0FBRztBQUFBLElBQ2pCO0FBQ0EsV0FBTztBQUFBLEVBQ1Q7QUFBQSxFQUVBLGlCQUFpQixPQUFZO0FBQzNCLFdBQU8sT0FBTyxTQUFnQjtBQUM1QixZQUFNLGNBQWMsS0FBSyxJQUFJLFlBQVksbUJBQW1CLEtBQUssS0FBSyxJQUFJLFdBQVcsR0FBRyxNQUFNLE9BQU8sS0FBSyxTQUFTLFdBQVcsS0FBSyxJQUFJLGNBQWMsb0JBQW9CLENBQUM7QUFBQSxJQUM1SztBQUFBLEVBQ0Y7QUFBQSxFQUVBLG9CQUFvQixPQUFZO0FBQzlCLFdBQU8sT0FBTyxTQUFnQjtBQUM1QixZQUFNLGlCQUFpQixLQUFLLElBQUksWUFBWSxtQkFBbUIsS0FBSyxLQUFLLElBQUksV0FBVyxHQUFHLE1BQU0sS0FBSztBQUFBLElBQ3hHO0FBQUEsRUFDRjtBQUNGOyIsCiAgIm5hbWVzIjogWyJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImVsZW1lbnQiLCAiX2EiLCAiZWxlbWVudCIsICJ0ZXh0IiwgImVsZW1lbnQiLCAiZGV0YWNoIiwgImNyZWF0ZV9lYWNoX2Jsb2NrIiwgImluc2VydCIsICJpbnN0YW5jZSIsICJjcmVhdGVfZnJhZ21lbnQiLCAiYXBwZW5kX3N0eWxlcyIsICJhdHRyIiwgImN0eCIsICJjdHgiLCAiY3R4IiwgImltcG9ydF9vYnNpZGlhbiIsICJjdHgiLCAiaW1wb3J0X29ic2lkaWFuIiwgInRleHQiLCAiaW1wb3J0X29ic2lkaWFuIiwgImN0eCIsICJpbXBvcnRfb2JzaWRpYW4iLCAiY3R4IiwgImltcG9ydF9vYnNpZGlhbiIsICJjdHgiXQp9Cg==
