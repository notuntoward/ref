/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MultiPropPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian6 = require("obsidian");

// src/AddPropModal.ts
var import_obsidian2 = require("obsidian");

// node_modules/svelte/src/runtime/internal/utils.js
function noop() {
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a && typeof a === "object" || typeof a === "function";
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}

// node_modules/svelte/src/runtime/internal/globals.js
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : (
  // @ts-ignore Node typings have this
  global
);

// node_modules/svelte/src/runtime/internal/ResizeObserverSingleton.js
var ResizeObserverSingleton = class _ResizeObserverSingleton {
  /** @param {ResizeObserverOptions} options */
  constructor(options) {
    /**
     * @private
     * @readonly
     * @type {WeakMap<Element, import('./private.js').Listener>}
     */
    __publicField(this, "_listeners", "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0);
    /**
     * @private
     * @type {ResizeObserver}
     */
    __publicField(this, "_observer");
    /** @type {ResizeObserverOptions} */
    __publicField(this, "options");
    this.options = options;
  }
  /**
   * @param {Element} element
   * @param {import('./private.js').Listener} listener
   * @returns {() => void}
   */
  observe(element2, listener) {
    this._listeners.set(element2, listener);
    this._getObserver().observe(element2, this.options);
    return () => {
      this._listeners.delete(element2);
      this._observer.unobserve(element2);
    };
  }
  /**
   * @private
   */
  _getObserver() {
    var _a;
    return (_a = this._observer) != null ? _a : this._observer = new ResizeObserver((entries) => {
      var _a2;
      for (const entry of entries) {
        _ResizeObserverSingleton.entries.set(entry.target, entry);
        (_a2 = this._listeners.get(entry.target)) == null ? void 0 : _a2(entry);
      }
    });
  }
};
ResizeObserverSingleton.entries = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;

// node_modules/svelte/src/runtime/internal/dom.js
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node) return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && /** @type {ShadowRoot} */
  root.host) {
    return (
      /** @type {ShadowRoot} */
      root
    );
  }
  return node.ownerDocument;
}
function append_stylesheet(node, style) {
  append(
    /** @type {Document} */
    node.head || node,
    style
  );
  return style.sheet;
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i]) iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function prevent_default(fn) {
  return function(event) {
    event.preventDefault();
    return fn.call(this, event);
  };
}
function attr(node, attribute, value) {
  if (value == null) node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.data === data) return;
  text2.data = /** @type {string} */
  data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function select_option(select, value, mounting) {
  for (let i = 0; i < select.options.length; i += 1) {
    const option = select.options[i];
    if (option.__value === value) {
      option.selected = true;
      return;
    }
  }
  if (!mounting || value !== void 0) {
    select.selectedIndex = -1;
  }
}
function select_value(select) {
  const selected_option = select.querySelector(":checked");
  return selected_option && selected_option.__value;
}
function get_custom_elements_slots(element2) {
  const result = {};
  element2.childNodes.forEach(
    /** @param {Element} node */
    (node) => {
      result[node.slot || "default"] = true;
    }
  );
  return result;
}

// node_modules/svelte/src/runtime/internal/lifecycle.js
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component) throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function bubble(component, event) {
  const callbacks = component.$$.callbacks[event.type];
  if (callbacks) {
    callbacks.slice().forEach((fn) => fn.call(this, event));
  }
}

// node_modules/svelte/src/runtime/internal/scheduler.js
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = /* @__PURE__ */ Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function tick() {
  schedule_update();
  return resolved_promise;
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
function add_flush_callback(fn) {
  flush_callbacks.push(fn);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length) binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
  targets.forEach((c) => c());
  render_callbacks = filtered;
}

// node_modules/svelte/src/runtime/internal/transitions.js
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block)) return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2) block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}

// node_modules/svelte/src/runtime/internal/each.js
function ensure_array_like(array_like_or_iterator) {
  return (array_like_or_iterator == null ? void 0 : array_like_or_iterator.length) !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
}
function outro_and_destroy_block(block, lookup) {
  transition_out(block, 1, 1, () => {
    lookup.delete(block.key);
  });
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block6, next, get_context) {
  let o = old_blocks.length;
  let n = list.length;
  let i = o;
  const old_indexes = {};
  while (i--) old_indexes[old_blocks[i].key] = i;
  const new_blocks = [];
  const new_lookup = /* @__PURE__ */ new Map();
  const deltas = /* @__PURE__ */ new Map();
  const updates = [];
  i = n;
  while (i--) {
    const child_ctx = get_context(ctx, list, i);
    const key = get_key(child_ctx);
    let block = lookup.get(key);
    if (!block) {
      block = create_each_block6(key, child_ctx);
      block.c();
    } else if (dynamic) {
      updates.push(() => block.p(child_ctx, dirty));
    }
    new_lookup.set(key, new_blocks[i] = block);
    if (key in old_indexes) deltas.set(key, Math.abs(i - old_indexes[key]));
  }
  const will_move = /* @__PURE__ */ new Set();
  const did_move = /* @__PURE__ */ new Set();
  function insert2(block) {
    transition_in(block, 1);
    block.m(node, next);
    lookup.set(block.key, block);
    next = block.first;
    n--;
  }
  while (o && n) {
    const new_block = new_blocks[n - 1];
    const old_block = old_blocks[o - 1];
    const new_key = new_block.key;
    const old_key = old_block.key;
    if (new_block === old_block) {
      next = new_block.first;
      o--;
      n--;
    } else if (!new_lookup.has(old_key)) {
      destroy(old_block, lookup);
      o--;
    } else if (!lookup.has(new_key) || will_move.has(new_key)) {
      insert2(new_block);
    } else if (did_move.has(old_key)) {
      o--;
    } else if (deltas.get(new_key) > deltas.get(old_key)) {
      did_move.add(new_key);
      insert2(new_block);
    } else {
      will_move.add(old_key);
      o--;
    }
  }
  while (o--) {
    const old_block = old_blocks[o];
    if (!new_lookup.has(old_block.key)) destroy(old_block, lookup);
  }
  while (n) insert2(new_blocks[n - 1]);
  run_all(updates);
  return new_blocks;
}

// node_modules/svelte/src/shared/boolean_attributes.js
var _boolean_attributes = (
  /** @type {const} */
  [
    "allowfullscreen",
    "allowpaymentrequest",
    "async",
    "autofocus",
    "autoplay",
    "checked",
    "controls",
    "default",
    "defer",
    "disabled",
    "formnovalidate",
    "hidden",
    "inert",
    "ismap",
    "loop",
    "multiple",
    "muted",
    "nomodule",
    "novalidate",
    "open",
    "playsinline",
    "readonly",
    "required",
    "reversed",
    "selected"
  ]
);
var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);

// node_modules/svelte/src/runtime/internal/Component.js
function bind(component, name, callback) {
  const index = component.$$.props[name];
  if (index !== void 0) {
    component.$$.bound[index] = callback;
    callback(component.$$.ctx[index]);
  }
}
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  add_render_callback(() => {
    const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
    if (component.$$.on_destroy) {
      component.$$.on_destroy.push(...new_on_destroy);
    } else {
      run_all(new_on_destroy);
    }
    component.$$.on_mount = [];
  });
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance6, create_fragment6, not_equal, props, append_styles2 = null, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance6 ? instance6(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);
      if (ready) make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment6 ? create_fragment6($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro) transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor($$componentCtor, $$slots, use_shadow_dom) {
      super();
      /** The Svelte component constructor */
      __publicField(this, "$$ctor");
      /** Slots */
      __publicField(this, "$$s");
      /** The Svelte component instance */
      __publicField(this, "$$c");
      /** Whether or not the custom element is connected */
      __publicField(this, "$$cn", false);
      /** Component props data */
      __publicField(this, "$$d", {});
      /** `true` if currently in the process of reflecting component props back to attributes */
      __publicField(this, "$$r", false);
      /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
      __publicField(this, "$$p_d", {});
      /** @type {Record<string, Function[]>} Event listeners */
      __publicField(this, "$$l", {});
      /** @type {Map<Function, Function>} Event listener unsubscribe functions */
      __publicField(this, "$$l_u", /* @__PURE__ */ new Map());
      this.$$ctor = $$componentCtor;
      this.$$s = $$slots;
      if (use_shadow_dom) {
        this.attachShadow({ mode: "open" });
      }
    }
    addEventListener(type, listener, options) {
      this.$$l[type] = this.$$l[type] || [];
      this.$$l[type].push(listener);
      if (this.$$c) {
        const unsub = this.$$c.$on(type, listener);
        this.$$l_u.set(listener, unsub);
      }
      super.addEventListener(type, listener, options);
    }
    removeEventListener(type, listener, options) {
      super.removeEventListener(type, listener, options);
      if (this.$$c) {
        const unsub = this.$$l_u.get(listener);
        if (unsub) {
          unsub();
          this.$$l_u.delete(listener);
        }
      }
      if (this.$$l[type]) {
        const idx = this.$$l[type].indexOf(listener);
        if (idx >= 0) {
          this.$$l[type].splice(idx, 1);
        }
      }
    }
    async connectedCallback() {
      this.$$cn = true;
      if (!this.$$c) {
        let create_slot = function(name) {
          return () => {
            let node;
            const obj = {
              c: function create() {
                node = element("slot");
                if (name !== "default") {
                  attr(node, "name", name);
                }
              },
              /**
               * @param {HTMLElement} target
               * @param {HTMLElement} [anchor]
               */
              m: function mount(target, anchor) {
                insert(target, node, anchor);
              },
              d: function destroy(detaching) {
                if (detaching) {
                  detach(node);
                }
              }
            };
            return obj;
          };
        };
        await Promise.resolve();
        if (!this.$$cn || this.$$c) {
          return;
        }
        const $$slots = {};
        const existing_slots = get_custom_elements_slots(this);
        for (const name of this.$$s) {
          if (name in existing_slots) {
            $$slots[name] = [create_slot(name)];
          }
        }
        for (const attribute of this.attributes) {
          const name = this.$$g_p(attribute.name);
          if (!(name in this.$$d)) {
            this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, "toProp");
          }
        }
        for (const key in this.$$p_d) {
          if (!(key in this.$$d) && this[key] !== void 0) {
            this.$$d[key] = this[key];
            delete this[key];
          }
        }
        this.$$c = new this.$$ctor({
          target: this.shadowRoot || this,
          props: {
            ...this.$$d,
            $$slots,
            $$scope: {
              ctx: []
            }
          }
        });
        const reflect_attributes = () => {
          this.$$r = true;
          for (const key in this.$$p_d) {
            this.$$d[key] = this.$$c.$$.ctx[this.$$c.$$.props[key]];
            if (this.$$p_d[key].reflect) {
              const attribute_value = get_custom_element_value(
                key,
                this.$$d[key],
                this.$$p_d,
                "toAttribute"
              );
              if (attribute_value == null) {
                this.removeAttribute(this.$$p_d[key].attribute || key);
              } else {
                this.setAttribute(this.$$p_d[key].attribute || key, attribute_value);
              }
            }
          }
          this.$$r = false;
        };
        this.$$c.$$.after_update.push(reflect_attributes);
        reflect_attributes();
        for (const type in this.$$l) {
          for (const listener of this.$$l[type]) {
            const unsub = this.$$c.$on(type, listener);
            this.$$l_u.set(listener, unsub);
          }
        }
        this.$$l = {};
      }
    }
    // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
    // and setting attributes through setAttribute etc, this is helpful
    attributeChangedCallback(attr2, _oldValue, newValue) {
      var _a;
      if (this.$$r) return;
      attr2 = this.$$g_p(attr2);
      this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, "toProp");
      (_a = this.$$c) == null ? void 0 : _a.$set({ [attr2]: this.$$d[attr2] });
    }
    disconnectedCallback() {
      this.$$cn = false;
      Promise.resolve().then(() => {
        if (!this.$$cn && this.$$c) {
          this.$$c.$destroy();
          this.$$c = void 0;
        }
      });
    }
    $$g_p(attribute_name) {
      return Object.keys(this.$$p_d).find(
        (key) => this.$$p_d[key].attribute === attribute_name || !this.$$p_d[key].attribute && key.toLowerCase() === attribute_name
      ) || attribute_name;
    }
  };
}
function get_custom_element_value(prop, value, props_definition, transform) {
  var _a;
  const type = (_a = props_definition[prop]) == null ? void 0 : _a.type;
  value = type === "Boolean" && typeof value !== "boolean" ? value != null : value;
  if (!transform || !props_definition[prop]) {
    return value;
  } else if (transform === "toAttribute") {
    switch (type) {
      case "Object":
      case "Array":
        return value == null ? null : JSON.stringify(value);
      case "Boolean":
        return value ? "" : null;
      case "Number":
        return value == null ? null : value;
      default:
        return value;
    }
  } else {
    switch (type) {
      case "Object":
      case "Array":
        return value && JSON.parse(value);
      case "Boolean":
        return value;
      // conversion already handled above
      case "Number":
        return value != null ? +value : value;
      default:
        return value;
    }
  }
}
var SvelteComponent = class {
  constructor() {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$");
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1) callbacks.splice(index, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(props) {
    if (this.$$set && !is_empty(props)) {
      this.$$.skip_bound = true;
      this.$$set(props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/svelte/src/shared/version.js
var PUBLIC_VERSION = "4";

// node_modules/svelte/src/runtime/internal/disclose-version/index.js
if (typeof window !== "undefined")
  (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);

// node_modules/tslib/tslib.es6.js
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// src/AddPropInput.svelte
function add_css(target) {
  append_styles(target, "svelte-33qhuc", "input.svelte-33qhuc{max-height:25px;overflow-x:auto}select.svelte-33qhuc{height:21px}#name-input.svelte-33qhuc{flex-grow:0;width:auto}.modal-input-container.svelte-33qhuc{width:95%;display:flex;flex-direction:row;align-items:center;gap:10px;margin-top:10px}.btn-inactive.svelte-33qhuc{cursor:not-allowed;pointer-events:none;opacity:0.7}");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[19] = list[i];
  return child_ctx;
}
function create_each_block(ctx) {
  let option;
  let t_value = (
    /*key*/
    ctx[19] + ""
  );
  let t;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = option_value_value = /*options*/
      ctx[8][
        /*key*/
        ctx[19]
      ];
      set_input_value(option, option.__value);
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(option);
      }
    }
  };
}
function create_fragment(ctx) {
  let div;
  let button;
  let t0;
  let button_class_value;
  let button_tabindex_value;
  let t1;
  let select;
  let t2;
  let input0;
  let t3;
  let input1;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(Object.keys(
    /*options*/
    ctx[8]
  ));
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  return {
    c() {
      div = element("div");
      button = element("button");
      t0 = text("X");
      t1 = space();
      select = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t2 = space();
      input0 = element("input");
      t3 = space();
      input1 = element("input");
      attr(button, "type", "button");
      attr(button, "id", "del-btn");
      attr(button, "class", button_class_value = "btn-del " + /*isFirst*/
      (ctx[2] ? "btn-inactive" : "") + " svelte-33qhuc");
      attr(button, "tabindex", button_tabindex_value = /*isFirst*/
      ctx[2] ? -1 : 0);
      attr(select, "id", "type-input");
      attr(select, "class", "flex-obj svelte-33qhuc");
      if (
        /*optionVal*/
        ctx[7] === void 0
      ) add_render_callback(() => (
        /*select_change_handler*/
        ctx[12].call(select)
      ));
      attr(input0, "id", "name-input");
      attr(input0, "class", "name-input flex-obj svelte-33qhuc");
      attr(input0, "type", "text");
      attr(input0, "name", "name[]");
      attr(input0, "placeholder", "name");
      input0.required = true;
      attr(input1, "id", "value-input");
      attr(input1, "type", "text");
      attr(input1, "name", "value[]");
      attr(input1, "placeholder", "value");
      attr(input1, "class", "value-input flex-obj svelte-33qhuc");
      attr(div, "class", "modal-input-container svelte-33qhuc");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      append(button, t0);
      append(div, t1);
      append(div, select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select, null);
        }
      }
      select_option(
        select,
        /*optionVal*/
        ctx[7],
        true
      );
      append(div, t2);
      append(div, input0);
      ctx[14](input0);
      set_input_value(
        input0,
        /*nameVal*/
        ctx[0]
      );
      append(div, t3);
      append(div, input1);
      ctx[16](input1);
      set_input_value(
        input1,
        /*valueVal*/
        ctx[1]
      );
      if (!mounted) {
        dispose = [
          listen(
            button,
            "click",
            /*click_handler*/
            ctx[11]
          ),
          listen(
            select,
            "change",
            /*select_change_handler*/
            ctx[12]
          ),
          listen(
            select,
            "change",
            /*change_handler*/
            ctx[13]
          ),
          listen(
            input0,
            "input",
            /*input0_input_handler*/
            ctx[15]
          ),
          listen(
            input1,
            "input",
            /*input1_input_handler*/
            ctx[17]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*isFirst*/
      4 && button_class_value !== (button_class_value = "btn-del " + /*isFirst*/
      (ctx2[2] ? "btn-inactive" : "") + " svelte-33qhuc")) {
        attr(button, "class", button_class_value);
      }
      if (dirty & /*isFirst*/
      4 && button_tabindex_value !== (button_tabindex_value = /*isFirst*/
      ctx2[2] ? -1 : 0)) {
        attr(button, "tabindex", button_tabindex_value);
      }
      if (dirty & /*options, Object*/
      256) {
        each_value = ensure_array_like(Object.keys(
          /*options*/
          ctx2[8]
        ));
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*optionVal, options, Object*/
      384) {
        select_option(
          select,
          /*optionVal*/
          ctx2[7]
        );
      }
      if (dirty & /*nameVal*/
      1 && input0.value !== /*nameVal*/
      ctx2[0]) {
        set_input_value(
          input0,
          /*nameVal*/
          ctx2[0]
        );
      }
      if (dirty & /*valueVal*/
      2 && input1.value !== /*valueVal*/
      ctx2[1]) {
        set_input_value(
          input1,
          /*valueVal*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
      ctx[14](null);
      ctx[16](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let { isFirst } = $$props;
  let { removeInput } = $$props;
  let { id } = $$props;
  let { typeVal = "text" } = $$props;
  let { nameVal = "" } = $$props;
  let { valueVal = "" } = $$props;
  let inputEl;
  let valueEl;
  let optionVal;
  const options = {
    Text: "string",
    Number: "number",
    Checkbox: "checkbox",
    Date: "date",
    Datetime: "datetime-local"
  };
  const convertProps = {
    text: "Text",
    multitext: "Text",
    number: "Number",
    checkbox: "Checkbox",
    date: "Date",
    datetime: "Datetime"
  };
  onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    yield tick();
    inputEl.focus();
    inputEl.select();
    $$invalidate(7, optionVal = options[convertProps[typeVal]]);
  }));
  function changeType(type) {
    $$invalidate(6, valueEl.type = type, valueEl);
  }
  const click_handler = () => {
    if (!isFirst) {
      removeInput(id);
    }
  };
  function select_change_handler() {
    optionVal = select_value(this);
    $$invalidate(7, optionVal);
    $$invalidate(8, options);
  }
  const change_handler = () => changeType(optionVal);
  function input0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputEl = $$value;
      $$invalidate(5, inputEl);
    });
  }
  function input0_input_handler() {
    nameVal = this.value;
    $$invalidate(0, nameVal);
  }
  function input1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      valueEl = $$value;
      $$invalidate(6, valueEl);
    });
  }
  function input1_input_handler() {
    valueVal = this.value;
    $$invalidate(1, valueVal);
  }
  $$self.$$set = ($$props2) => {
    if ("isFirst" in $$props2) $$invalidate(2, isFirst = $$props2.isFirst);
    if ("removeInput" in $$props2) $$invalidate(3, removeInput = $$props2.removeInput);
    if ("id" in $$props2) $$invalidate(4, id = $$props2.id);
    if ("typeVal" in $$props2) $$invalidate(10, typeVal = $$props2.typeVal);
    if ("nameVal" in $$props2) $$invalidate(0, nameVal = $$props2.nameVal);
    if ("valueVal" in $$props2) $$invalidate(1, valueVal = $$props2.valueVal);
  };
  return [
    nameVal,
    valueVal,
    isFirst,
    removeInput,
    id,
    inputEl,
    valueEl,
    optionVal,
    options,
    changeType,
    typeVal,
    click_handler,
    select_change_handler,
    change_handler,
    input0_binding,
    input0_input_handler,
    input1_binding,
    input1_input_handler
  ];
}
var AddPropInput = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        isFirst: 2,
        removeInput: 3,
        id: 4,
        typeVal: 10,
        nameVal: 0,
        valueVal: 1
      },
      add_css
    );
  }
};
var AddPropInput_default = AddPropInput;

// src/helpers.ts
function parseValue(input, type) {
  switch (type) {
    case "number":
      return Number(input.value);
    case "checkbox":
      return Boolean(input.checked);
    default:
      return input.value;
  }
}
function removeExtraCommas(str) {
  return str.replace(/^,*(.*?),*$/g, "$1").replace(/,{2,}/g, ",");
}
function cleanTags(str) {
  let cleanStr = str;
  for (let index in KNOWN_BAD_CHARACTERS) {
    cleanStr = cleanStr.replaceAll(KNOWN_BAD_CHARACTERS[index], "");
  }
  return cleanStr;
}
var KNOWN_BAD_CHARACTERS = [
  "\u2012",
  "\u2013",
  "\u2014",
  "\u2015",
  "\u204F",
  "\u203D",
  "\u2018",
  "\u201A",
  "\u201B",
  "\u2039",
  "\u203A",
  "\u201C",
  "\u201D",
  "\u201E",
  "\u201F",
  "\u2045",
  "\u2046",
  "\u204B",
  "\u204E",
  "\u2051",
  "\u2044",
  "\u204A",
  "\u2030",
  "\u2031",
  "\u2052",
  "\u2020",
  "\u2021",
  "\u2022",
  "\u2023",
  "\u2043",
  "\u204C",
  "\u204D",
  "\u2032",
  "\u2035",
  "\u2038",
  "\u203B",
  "\u2050",
  "\u2041",
  "\u2042",
  "\u2016",
  "\u2011",
  "\u2033",
  "\u2034",
  "\u2057",
  "\u2036",
  "\u2037",
  "`",
  "^",
  "\u203E",
  "\u2017",
  "\u2053",
  ";",
  ":",
  "!",
  "\u203C",
  "\u2049",
  "?",
  "\u2048",
  "\u2047",
  ".",
  "\u2024",
  "\u2025",
  "\u2026",
  "'",
  '"',
  "(",
  ")",
  "[",
  "]",
  "{",
  "}",
  "@",
  "*",
  "&",
  "%",
  "\u2054",
  "+",
  "<",
  "=",
  ">",
  "|",
  "~",
  "$",
  "\u2055",
  "\u2056",
  "\u2058",
  "\u2059",
  "\u205A",
  "\u205B",
  "\u205C",
  "\u205D",
  "\u205E",
  "\u2E00",
  "\u2E01",
  "\u2E02",
  "\u2E03",
  "\u2E04",
  "\u2E05",
  "\u2E06",
  "\u2E07",
  "\u2E08",
  "\u2E09",
  "\u2E0A",
  "\u2E0B",
  "\u2E0C",
  "\u2E0D",
  "\u2E0E",
  "\u2E0F",
  "\u2E10",
  "\u2E11",
  "\u2E12",
  "\u2E13",
  "\u2E14",
  "\u2E15",
  "\u2E16",
  "\u2E17",
  "\u2E1C",
  "\u2E1D",
  " ",
  "#"
];

// src/AddPropForm.svelte
var { Map: Map_1 } = globals;
function add_css2(target) {
  append_styles(target, "svelte-1lpixw8", ".modal-inputs-container.svelte-1lpixw8{height:200px;width:100%;overflow-y:scroll;border-radius:5px;border-style:solid;display:flex;flex-direction:column;align-items:center}.modal-add-container.svelte-1lpixw8{margin-top:10px}.alert-container.svelte-1lpixw8{display:flex;flex-direction:column;align-items:center;justify-content:center;margin-bottom:10px;background-color:red;font-weight:bold}.hidden.svelte-1lpixw8{display:none}");
}
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i];
  child_ctx[24] = list;
  child_ctx[25] = i;
  return child_ctx;
}
function create_each_block2(key_1, ctx) {
  let first;
  let propinput;
  let updating_typeVal;
  let updating_nameVal;
  let updating_valueVal;
  let current;
  function propinput_typeVal_binding(value) {
    ctx[15](
      value,
      /*input*/
      ctx[23]
    );
  }
  function propinput_nameVal_binding(value) {
    ctx[16](
      value,
      /*input*/
      ctx[23]
    );
  }
  function propinput_valueVal_binding(value) {
    ctx[17](
      value,
      /*input*/
      ctx[23]
    );
  }
  let propinput_props = {
    isFirst: (
      /*input*/
      ctx[23].isFirst
    ),
    id: (
      /*input*/
      ctx[23].id
    ),
    removeInput: (
      /*removeInput*/
      ctx[8]
    )
  };
  if (
    /*input*/
    ctx[23].typeDef !== void 0
  ) {
    propinput_props.typeVal = /*input*/
    ctx[23].typeDef;
  }
  if (
    /*input*/
    ctx[23].nameDef !== void 0
  ) {
    propinput_props.nameVal = /*input*/
    ctx[23].nameDef;
  }
  if (
    /*input*/
    ctx[23].valueDef !== void 0
  ) {
    propinput_props.valueVal = /*input*/
    ctx[23].valueDef;
  }
  propinput = new AddPropInput_default({ props: propinput_props });
  binding_callbacks.push(() => bind(propinput, "typeVal", propinput_typeVal_binding));
  binding_callbacks.push(() => bind(propinput, "nameVal", propinput_nameVal_binding));
  binding_callbacks.push(() => bind(propinput, "valueVal", propinput_valueVal_binding));
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(propinput.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(propinput, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const propinput_changes = {};
      if (dirty & /*inputEls*/
      32) propinput_changes.isFirst = /*input*/
      ctx[23].isFirst;
      if (dirty & /*inputEls*/
      32) propinput_changes.id = /*input*/
      ctx[23].id;
      if (!updating_typeVal && dirty & /*inputEls*/
      32) {
        updating_typeVal = true;
        propinput_changes.typeVal = /*input*/
        ctx[23].typeDef;
        add_flush_callback(() => updating_typeVal = false);
      }
      if (!updating_nameVal && dirty & /*inputEls*/
      32) {
        updating_nameVal = true;
        propinput_changes.nameVal = /*input*/
        ctx[23].nameDef;
        add_flush_callback(() => updating_nameVal = false);
      }
      if (!updating_valueVal && dirty & /*inputEls*/
      32) {
        updating_valueVal = true;
        propinput_changes.valueVal = /*input*/
        ctx[23].valueDef;
        add_flush_callback(() => updating_valueVal = false);
      }
      propinput.$set(propinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(propinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(propinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(propinput, detaching);
    }
  };
}
function create_fragment2(ctx) {
  let div6;
  let div2;
  let div0;
  let t1;
  let div1;
  let t2;
  let t3;
  let p0;
  let t5;
  let p1;
  let t6;
  let t7;
  let t8;
  let t9;
  let p2;
  let t11;
  let form;
  let label;
  let input_1;
  let t12_value = "Overwrite existing properties";
  let t12;
  let t13;
  let div3;
  let each_blocks = [];
  let each_1_lookup = new Map_1();
  let t14;
  let div4;
  let button0;
  let t16;
  let div5;
  let button1;
  let current;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*inputEls*/
    ctx[5]
  );
  const get_key = (ctx2) => (
    /*input*/
    ctx2[23].id
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context2(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block2(key, child_ctx));
  }
  return {
    c() {
      div6 = element("div");
      div2 = element("div");
      div0 = element("div");
      div0.textContent = "ERROR";
      t1 = space();
      div1 = element("div");
      t2 = text(
        /*alertText*/
        ctx[4]
      );
      t3 = space();
      p0 = element("p");
      p0.textContent = "Type in a property name, then value. Use the dropbox to choose what type of\n    data you wish to store.";
      t5 = space();
      p1 = element("p");
      t6 = text('If you want to make a List property, use the Text data type and separate\n    each value with a "');
      t7 = text(
        /*delimiter*/
        ctx[1]
      );
      t8 = text('".');
      t9 = space();
      p2 = element("p");
      p2.textContent = 'If you want to add Tags, use the name "tags".';
      t11 = space();
      form = element("form");
      label = element("label");
      input_1 = element("input");
      t12 = text(t12_value);
      t13 = space();
      div3 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t14 = space();
      div4 = element("div");
      button0 = element("button");
      button0.textContent = "Add";
      t16 = space();
      div5 = element("div");
      button1 = element("button");
      button1.textContent = "Submit";
      attr(div1, "id", "alert-text");
      attr(div2, "id", "alert-container");
      attr(div2, "class", "alert-container hidden svelte-1lpixw8");
      attr(input_1, "type", "checkbox");
      input_1.checked = /*overwrite*/
      ctx[0];
      attr(div3, "class", "modal-inputs-container svelte-1lpixw8");
      attr(button0, "type", "button");
      attr(button0, "class", "a-btn");
      attr(div4, "class", "modal-add-container svelte-1lpixw8");
      attr(button1, "class", "btn-submit");
      attr(div5, "class", "modal-button-container");
      attr(div6, "id", "multi-properties-modal");
      attr(div6, "class", "modal-content");
    },
    m(target, anchor) {
      insert(target, div6, anchor);
      append(div6, div2);
      append(div2, div0);
      append(div2, t1);
      append(div2, div1);
      append(div1, t2);
      ctx[14](div2);
      append(div6, t3);
      append(div6, p0);
      append(div6, t5);
      append(div6, p1);
      append(p1, t6);
      append(p1, t7);
      append(p1, t8);
      append(div6, t9);
      append(div6, p2);
      append(div6, t11);
      append(div6, form);
      append(form, label);
      append(label, input_1);
      append(label, t12);
      append(form, t13);
      append(form, div3);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div3, null);
        }
      }
      append(form, t14);
      append(form, div4);
      append(div4, button0);
      append(form, t16);
      append(form, div5);
      append(div5, button1);
      ctx[19](form);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input_1,
            "change",
            /*onCheckboxChange*/
            ctx[6]
          ),
          listen(
            button0,
            "click",
            /*click_handler*/
            ctx[18]
          ),
          listen(
            button1,
            "click",
            /*onSubmit*/
            ctx[9]
          ),
          listen(form, "submit", prevent_default(
            /*submit_handler*/
            ctx[13]
          ))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*alertText*/
      16) set_data(
        t2,
        /*alertText*/
        ctx2[4]
      );
      if (!current || dirty & /*delimiter*/
      2) set_data(
        t7,
        /*delimiter*/
        ctx2[1]
      );
      if (!current || dirty & /*overwrite*/
      1) {
        input_1.checked = /*overwrite*/
        ctx2[0];
      }
      if (dirty & /*inputEls, removeInput*/
      288) {
        each_value = ensure_array_like(
          /*inputEls*/
          ctx2[5]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div3, outro_and_destroy_block, create_each_block2, null, get_each_context2);
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div6);
      }
      ctx[14](null);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      ctx[19](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let { submission } = $$props;
  let { overwrite } = $$props;
  let { delimiter } = $$props;
  let { defaultProps } = $$props;
  let { changeBool } = $$props;
  let countInputs = 0;
  let formEl;
  let errorEl;
  let alertText = ".";
  let inputEls = [];
  function onCheckboxChange() {
    $$invalidate(0, overwrite = !overwrite);
    changeBool(overwrite);
  }
  onMount(() => {
    defaultProps.length > 0 ? addInputs(defaultProps) : addInputs([{ type: "text", name: "", value: "" }]);
  });
  function addInputs(inputs = [{ type: "text", name: "", value: "" }]) {
    let arr = [];
    for (let input of inputs) {
      countInputs++;
      arr.push({
        id: countInputs,
        isFirst: countInputs === 1 ? true : false,
        typeDef: input.type,
        nameDef: input.name,
        valueDef: input.value
      });
    }
    $$invalidate(5, inputEls = [...inputEls, ...arr]);
  }
  function removeInput(id) {
    return __awaiter(this, void 0, void 0, function* () {
      $$invalidate(5, inputEls = inputEls.filter((input) => input.id !== id));
      yield tick();
      let inputs = formEl.querySelectorAll("input");
      if (!inputs) return;
      inputs[inputs.length - 2].focus();
    });
  }
  function checkDuplicateNames() {
    let set = /* @__PURE__ */ new Set();
    for (let input of inputEls) set.add(input.nameDef);
    if (set.size < inputEls.length) return true;
    else return false;
  }
  function runError(errorText) {
    $$invalidate(4, alertText = errorText);
    errorEl.classList.remove("hidden");
  }
  function onSubmit() {
    if (checkDuplicateNames()) {
      runError("Duplicate property names are not allowed.");
      return;
    }
    let obj = /* @__PURE__ */ new Map();
    let inputs = formEl.querySelectorAll('input[name^="name[]"]');
    inputs.forEach((input) => {
      var _a;
      if (!(input.nextElementSibling instanceof HTMLInputElement)) return;
      if (!(input.previousElementSibling instanceof HTMLSelectElement)) return;
      if (!(input.previousElementSibling.children[0] instanceof HTMLOptionElement)) return;
      let name = input.value;
      if (name === "") {
        input.reportValidity();
        return;
      }
      const selectEl = input.previousElementSibling;
      const htmlType = selectEl.value;
      const reverseOptions = {
        "string": "text",
        "number": "number",
        "checkbox": "checkbox",
        "date": "date",
        "datetime-local": "datetime"
      };
      const obsidianType = (_a = reverseOptions[htmlType]) !== null && _a !== void 0 ? _a : "text";
      let value = parseValue(input.nextElementSibling, input.nextElementSibling.type);
      if (typeof value === "string") {
        if (name === "tags") {
          value = cleanTags(value);
        }
        if (typeof value === "string" && value.includes(",")) {
          let str = removeExtraCommas(value);
          value = str.split(delimiter);
        }
      }
      if (value === "") value = null;
      let propObj = {
        type: obsidianType,
        data: value,
        overwrite: false,
        delimiter
      };
      obj.set(name, propObj);
    });
    if (obj.size < inputs.length) return;
    console.log(obj);
    submission(obj);
  }
  function submit_handler(event) {
    bubble.call(this, $$self, event);
  }
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      errorEl = $$value;
      $$invalidate(3, errorEl);
    });
  }
  function propinput_typeVal_binding(value, input) {
    if ($$self.$$.not_equal(input.typeDef, value)) {
      input.typeDef = value;
      $$invalidate(5, inputEls);
    }
  }
  function propinput_nameVal_binding(value, input) {
    if ($$self.$$.not_equal(input.nameDef, value)) {
      input.nameDef = value;
      $$invalidate(5, inputEls);
    }
  }
  function propinput_valueVal_binding(value, input) {
    if ($$self.$$.not_equal(input.valueDef, value)) {
      input.valueDef = value;
      $$invalidate(5, inputEls);
    }
  }
  const click_handler = () => addInputs([{ type: "text", name: "", value: "" }]);
  function form_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      formEl = $$value;
      $$invalidate(2, formEl);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("submission" in $$props2) $$invalidate(10, submission = $$props2.submission);
    if ("overwrite" in $$props2) $$invalidate(0, overwrite = $$props2.overwrite);
    if ("delimiter" in $$props2) $$invalidate(1, delimiter = $$props2.delimiter);
    if ("defaultProps" in $$props2) $$invalidate(11, defaultProps = $$props2.defaultProps);
    if ("changeBool" in $$props2) $$invalidate(12, changeBool = $$props2.changeBool);
  };
  return [
    overwrite,
    delimiter,
    formEl,
    errorEl,
    alertText,
    inputEls,
    onCheckboxChange,
    addInputs,
    removeInput,
    onSubmit,
    submission,
    defaultProps,
    changeBool,
    submit_handler,
    div2_binding,
    propinput_typeVal_binding,
    propinput_nameVal_binding,
    propinput_valueVal_binding,
    click_handler,
    form_binding
  ];
}
var AddPropForm = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance2,
      create_fragment2,
      safe_not_equal,
      {
        submission: 10,
        overwrite: 0,
        delimiter: 1,
        defaultProps: 11,
        changeBool: 12
      },
      add_css2
    );
  }
};
var AddPropForm_default = AddPropForm;

// src/AddConfirmModal.ts
var import_obsidian = require("obsidian");

// src/AddConfirmForm.svelte
function add_css3(target) {
  append_styles(target, "svelte-vt02cj", ".msg.svelte-vt02cj{font-weight:bold;padding-bottom:10px}");
}
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i][0];
  child_ctx[8] = list[i][1];
  return child_ctx;
}
function create_each_block3(ctx) {
  let li;
  let t0_value = (
    /*propName*/
    ctx[7] + ""
  );
  let t0;
  let t1;
  let t2_value = (
    /*prop*/
    ctx[8].data + ""
  );
  let t2;
  let t3;
  return {
    c() {
      li = element("li");
      t0 = text(t0_value);
      t1 = text(": ");
      t2 = text(t2_value);
      t3 = space();
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, t0);
      append(li, t1);
      append(li, t2);
      append(li, t3);
    },
    p(ctx2, dirty) {
      if (dirty & /*props*/
      1 && t0_value !== (t0_value = /*propName*/
      ctx2[7] + "")) set_data(t0, t0_value);
      if (dirty & /*props*/
      1 && t2_value !== (t2_value = /*prop*/
      ctx2[8].data + "")) set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
    }
  };
}
function create_fragment3(ctx) {
  let div;
  let form;
  let p0;
  let t1;
  let p1;
  let t3;
  let ul;
  let t4;
  let p2;
  let t6;
  let button0;
  let t8;
  let button1;
  let mounted;
  let dispose;
  let each_value = ensure_array_like([.../*props*/
  ctx[0]]);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  return {
    c() {
      div = element("div");
      form = element("form");
      p0 = element("p");
      p0.textContent = `${/*msg*/
      ctx[4]}`;
      t1 = space();
      p1 = element("p");
      p1.textContent = "The following props will be added:";
      t3 = space();
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t4 = space();
      p2 = element("p");
      p2.textContent = "Are you sure you wish to proceed?";
      t6 = space();
      button0 = element("button");
      button0.textContent = "Confirm";
      t8 = space();
      button1 = element("button");
      button1.textContent = "Cancel";
      attr(p0, "class", "msg svelte-vt02cj");
      attr(button0, "class", "mod-warning");
      attr(button0, "type", "submit");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, form);
      append(form, p0);
      append(form, t1);
      append(form, p1);
      append(form, t3);
      append(form, ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ul, null);
        }
      }
      append(form, t4);
      append(form, p2);
      append(form, t6);
      append(form, button0);
      append(form, t8);
      append(form, button1);
      ctx[6](button1);
      if (!mounted) {
        dispose = [
          listen(button1, "click", function() {
            if (is_function(
              /*cancel*/
              ctx[2]
            )) ctx[2].apply(this, arguments);
          }),
          listen(form, "submit", prevent_default(function() {
            if (is_function(
              /*submission*/
              ctx[1]
            )) ctx[1].apply(this, arguments);
          }))
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (dirty & /*props*/
      1) {
        each_value = ensure_array_like([.../*props*/
        ctx[0]]);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ul, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
      ctx[6](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance3($$self, $$props, $$invalidate) {
  let { props } = $$props;
  let { overwrite = true } = $$props;
  let { submission } = $$props;
  let { cancel } = $$props;
  let btnCancel;
  const msg = overwrite ? "Any pre-existing text props will have their values overwritten." : "Any pre-existing text props will have their values be appended to.";
  onMount(() => {
    btnCancel.focus();
  });
  function button1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      btnCancel = $$value;
      $$invalidate(3, btnCancel);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("props" in $$props2) $$invalidate(0, props = $$props2.props);
    if ("overwrite" in $$props2) $$invalidate(5, overwrite = $$props2.overwrite);
    if ("submission" in $$props2) $$invalidate(1, submission = $$props2.submission);
    if ("cancel" in $$props2) $$invalidate(2, cancel = $$props2.cancel);
  };
  return [props, submission, cancel, btnCancel, msg, overwrite, button1_binding];
}
var AddConfirmForm = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance3,
      create_fragment3,
      safe_not_equal,
      {
        props: 0,
        overwrite: 5,
        submission: 1,
        cancel: 2
      },
      add_css3
    );
  }
};
var AddConfirmForm_default = AddConfirmForm;

// src/AddConfirmModal.ts
var AddConfirmModal = class extends import_obsidian.Modal {
  constructor(app, props, overwrite, submission) {
    super(app);
    this.props = props;
    this.overwrite = overwrite;
    this.submission = submission;
  }
  async onSubmit() {
    await this.submission(true);
    this.close();
  }
  onCancel() {
    this.submission(false);
    this.close();
  }
  onOpen() {
    this.titleEl.createEl("h2", { text: "Add Properties" });
    this.component = new AddConfirmForm_default({
      target: this.contentEl,
      props: {
        props: this.props,
        overwrite: this.overwrite,
        submission: this.onSubmit.bind(this),
        cancel: this.onCancel.bind(this)
      }
    });
  }
};

// src/AddPropModal.ts
var PropModal = class extends import_obsidian2.Modal {
  constructor(app, submission, overwrite, delimiter, defaultProps, changeBool) {
    super(app);
    this.submission = submission;
    this.overwrite = overwrite;
    this.delimiter = delimiter;
    this.defaultProps = defaultProps;
    this.changeBool = changeBool;
  }
  //Run form submission if user clicks confirm.
  async onConfirm(bool) {
    if (bool) {
      await this.submission(this.props);
      this.close();
    }
  }
  updateBool(bool) {
    this.overwrite = bool;
    this.changeBool(bool);
  }
  //Pull up confirmation form when user submits base form.
  onSubmit(props) {
    this.props = props;
    new AddConfirmModal(
      this.app,
      this.props,
      this.overwrite,
      this.onConfirm.bind(this)
    ).open();
  }
  onOpen() {
    this.titleEl.createEl("h2", { text: "Add Properties" });
    this.component = new AddPropForm_default({
      target: this.contentEl,
      props: {
        submission: this.onSubmit.bind(this),
        overwrite: this.overwrite,
        delimiter: this.delimiter,
        defaultProps: this.defaultProps,
        changeBool: this.updateBool.bind(this)
      }
    });
  }
};

// src/SettingTab.ts
var import_obsidian3 = require("obsidian");
var SettingTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    let { containerEl } = this;
    containerEl.empty();
    new import_obsidian3.Setting(containerEl).setName("Overwrite existing text").setDesc(
      "When adding a property with a name that already exists, the text will overwrite the prop's existing value.  If left disabled, the new value will be appended to the old as a List."
    ).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.overwrite);
      toggle.onChange(async (value) => {
        this.plugin.settings.overwrite = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian3.Setting(containerEl).setName("Recursive Iteration").setDesc(
      "When toggled on, while looping through all files in a folder, you will also loop through any sub-folders."
    ).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.recursive);
      toggle.onChange(async (value) => {
        this.plugin.settings.recursive = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian3.Setting(containerEl).setName("List Delimiter").setDesc(
      "Set delimiter to use when creating a list.  Commas(,) are used by default."
    ).addText((text2) => {
      text2.setValue(this.plugin.settings.delimiter);
      text2.onChange(async (value) => {
        if (value.length > 1) {
          text2.setValue(value[0]);
          new import_obsidian3.Notice("Delimiter must be a single character.");
          return;
        }
        this.plugin.settings.delimiter = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian3.Setting(containerEl).setName("Default Props File").setDesc(
      "Select a file with properties that you want to load into the Multi Properties form by default.  Type in the full path of the desired file.(ex. Templates/PropFile 1)"
    ).addText((text2) => {
      text2.setValue(this.plugin.settings.defaultPropPath);
      text2.onChange(async (value) => {
        this.plugin.settings.defaultPropPath = value;
        await this.plugin.saveSettings();
      });
    });
  }
};

// src/RemoveModal.ts
var import_obsidian5 = require("obsidian");

// src/RemovePropForm.svelte
function add_css4(target) {
  append_styles(target, "svelte-zna8bm", ".name-container.svelte-zna8bm{display:flex;flex-direction:column;gap:5px;margin-top:10px;margin-bottom:20px}.alert-container.svelte-zna8bm{display:flex;flex-direction:column;align-items:center;justify-content:center;margin-bottom:10px;background-color:red;font-weight:bold}.button-container.svelte-zna8bm{display:flex;flex-direction:row;justify-content:space-between}.hidden.svelte-zna8bm{display:none}");
}
function get_each_context4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i];
  child_ctx[15] = list;
  child_ctx[16] = i;
  return child_ctx;
}
function create_each_block4(ctx) {
  let label;
  let input_1;
  let t0;
  let t1_value = (
    /*input*/
    ctx[14].name + ""
  );
  let t1;
  let t2;
  let mounted;
  let dispose;
  function input_1_change_handler() {
    ctx[12].call(
      input_1,
      /*each_value*/
      ctx[15],
      /*input_index*/
      ctx[16]
    );
  }
  return {
    c() {
      label = element("label");
      input_1 = element("input");
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      attr(input_1, "type", "checkbox");
    },
    m(target, anchor) {
      insert(target, label, anchor);
      append(label, input_1);
      set_input_value(
        input_1,
        /*input*/
        ctx[14].name
      );
      input_1.checked = /*input*/
      ctx[14].isChecked;
      append(label, t0);
      append(label, t1);
      append(label, t2);
      if (!mounted) {
        dispose = [
          listen(input_1, "change", input_1_change_handler),
          listen(
            input_1,
            "change",
            /*change_handler*/
            ctx[13]
          )
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*inputs*/
      8) {
        set_input_value(
          input_1,
          /*input*/
          ctx[14].name
        );
      }
      if (dirty & /*inputs*/
      8) {
        input_1.checked = /*input*/
        ctx[14].isChecked;
      }
      if (dirty & /*inputs*/
      8 && t1_value !== (t1_value = /*input*/
      ctx[14].name + "")) set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(label);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment4(ctx) {
  let div5;
  let div2;
  let div0;
  let t1;
  let div1;
  let t2;
  let t3;
  let p;
  let t5;
  let form;
  let div3;
  let t6;
  let div4;
  let button0;
  let t8;
  let button1;
  let t9_value = (
    /*isMaxChecked*/
    ctx[0] ? "Uncheck All" : "Check All"
  );
  let t9;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*inputs*/
    ctx[3]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block4(get_each_context4(ctx, each_value, i));
  }
  return {
    c() {
      div5 = element("div");
      div2 = element("div");
      div0 = element("div");
      div0.textContent = "ERROR";
      t1 = space();
      div1 = element("div");
      t2 = text(
        /*alertText*/
        ctx[2]
      );
      t3 = space();
      p = element("p");
      p.textContent = "Select the properties you wish to remove from the file selection.";
      t5 = space();
      form = element("form");
      div3 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t6 = space();
      div4 = element("div");
      button0 = element("button");
      button0.textContent = "Confirm";
      t8 = space();
      button1 = element("button");
      t9 = text(t9_value);
      attr(div1, "id", "alert-text");
      attr(div2, "id", "alert-container");
      attr(div2, "class", "alert-container hidden svelte-zna8bm");
      attr(div3, "class", "name-container svelte-zna8bm");
      attr(button0, "type", "submit");
      attr(div4, "class", "button-container svelte-zna8bm");
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div2);
      append(div2, div0);
      append(div2, t1);
      append(div2, div1);
      append(div1, t2);
      ctx[11](div2);
      append(div5, t3);
      append(div5, p);
      append(div5, t5);
      append(div5, form);
      append(form, div3);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div3, null);
        }
      }
      append(form, t6);
      append(form, div4);
      append(div4, button0);
      append(div4, t8);
      append(div4, button1);
      append(button1, t9);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*onSubmit*/
            ctx[6]
          ),
          listen(
            button1,
            "click",
            /*toggleAll*/
            ctx[5]
          ),
          listen(form, "submit", prevent_default(
            /*submit_handler*/
            ctx[10]
          ))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*alertText*/
      4) set_data(
        t2,
        /*alertText*/
        ctx2[2]
      );
      if (dirty & /*inputs, onCheckboxChange*/
      24) {
        each_value = ensure_array_like(
          /*inputs*/
          ctx2[3]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context4(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block4(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div3, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*isMaxChecked*/
      1 && t9_value !== (t9_value = /*isMaxChecked*/
      ctx2[0] ? "Uncheck All" : "Check All")) set_data(t9, t9_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div5);
      }
      ctx[11](null);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance4($$self, $$props, $$invalidate) {
  let isMaxChecked;
  let { names = [] } = $$props;
  let { submission } = $$props;
  let errorEl;
  let alertText = ".";
  let checkCount = 0;
  let inputs = [];
  for (let name of names) {
    inputs.push({ name, isChecked: false });
  }
  names.sort();
  function onCheckboxChange(event) {
    let checked = event.target.checked;
    checked ? $$invalidate(9, checkCount++, checkCount) : $$invalidate(9, checkCount--, checkCount);
  }
  function toggleAll() {
    if (isMaxChecked) {
      $$invalidate(3, inputs = inputs.map((input) => Object.assign(Object.assign({}, input), { isChecked: false })));
      $$invalidate(9, checkCount = 0);
    } else {
      $$invalidate(3, inputs = inputs.map((input) => Object.assign(Object.assign({}, input), { isChecked: true })));
      $$invalidate(9, checkCount = names.length);
    }
  }
  function onSubmit() {
    if (checkCount === 0) {
      $$invalidate(2, alertText = "Please select at least one property to remove.");
      errorEl.classList.remove("hidden");
      return;
    }
    let propNames = inputs.filter((input) => input.isChecked).map((input) => input.name);
    submission(propNames);
  }
  function submit_handler(event) {
    bubble.call(this, $$self, event);
  }
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      errorEl = $$value;
      $$invalidate(1, errorEl);
    });
  }
  function input_1_change_handler(each_value, input_index) {
    each_value[input_index].name = this.value;
    each_value[input_index].isChecked = this.checked;
    $$invalidate(3, inputs);
  }
  const change_handler = (event) => onCheckboxChange(event);
  $$self.$$set = ($$props2) => {
    if ("names" in $$props2) $$invalidate(7, names = $$props2.names);
    if ("submission" in $$props2) $$invalidate(8, submission = $$props2.submission);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*checkCount, names*/
    640) {
      $: $$invalidate(0, isMaxChecked = checkCount >= names.length);
    }
    if ($$self.$$.dirty & /*isMaxChecked*/
    1) {
      $: console.log(isMaxChecked);
    }
  };
  return [
    isMaxChecked,
    errorEl,
    alertText,
    inputs,
    onCheckboxChange,
    toggleAll,
    onSubmit,
    names,
    submission,
    checkCount,
    submit_handler,
    div2_binding,
    input_1_change_handler,
    change_handler
  ];
}
var RemovePropForm = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance4, create_fragment4, safe_not_equal, { names: 7, submission: 8 }, add_css4);
  }
};
var RemovePropForm_default = RemovePropForm;

// src/RemoveConfirmModal.ts
var import_obsidian4 = require("obsidian");

// src/RemoveConfirmForm.svelte
function get_each_context5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  return child_ctx;
}
function create_each_block5(ctx) {
  let li;
  let t0_value = (
    /*name*/
    ctx[6] + ""
  );
  let t0;
  let t1;
  return {
    c() {
      li = element("li");
      t0 = text(t0_value);
      t1 = space();
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, t0);
      append(li, t1);
    },
    p(ctx2, dirty) {
      if (dirty & /*names*/
      1 && t0_value !== (t0_value = /*name*/
      ctx2[6] + "")) set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
    }
  };
}
function create_fragment5(ctx) {
  let div;
  let form;
  let p0;
  let t3;
  let ul;
  let t4;
  let p1;
  let t6;
  let button0;
  let t8;
  let button1;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*names*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block5(get_each_context5(ctx, each_value, i));
  }
  return {
    c() {
      div = element("div");
      form = element("form");
      p0 = element("p");
      p0.textContent = `The following ${/*word*/
      ctx[4]} will be removed:`;
      t3 = space();
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t4 = space();
      p1 = element("p");
      p1.textContent = "Are you sure you wish to proceed?";
      t6 = space();
      button0 = element("button");
      button0.textContent = "Delete";
      t8 = space();
      button1 = element("button");
      button1.textContent = "Cancel";
      attr(button0, "class", "mod-warning");
      attr(button0, "type", "submit");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, form);
      append(form, p0);
      append(form, t3);
      append(form, ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ul, null);
        }
      }
      append(form, t4);
      append(form, p1);
      append(form, t6);
      append(form, button0);
      append(form, t8);
      append(form, button1);
      ctx[5](button1);
      if (!mounted) {
        dispose = [
          listen(button1, "click", function() {
            if (is_function(
              /*cancel*/
              ctx[2]
            )) ctx[2].apply(this, arguments);
          }),
          listen(form, "submit", prevent_default(function() {
            if (is_function(
              /*submission*/
              ctx[1]
            )) ctx[1].apply(this, arguments);
          }))
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (dirty & /*names*/
      1) {
        each_value = ensure_array_like(
          /*names*/
          ctx[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context5(ctx, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block5(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ul, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
      ctx[5](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance5($$self, $$props, $$invalidate) {
  let { names = ["test", "test2"] } = $$props;
  let { submission } = $$props;
  let { cancel } = $$props;
  let btnCancel;
  const word = names.length > 1 ? "properties" : "property";
  onMount(() => {
    btnCancel.focus();
  });
  function button1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      btnCancel = $$value;
      $$invalidate(3, btnCancel);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("names" in $$props2) $$invalidate(0, names = $$props2.names);
    if ("submission" in $$props2) $$invalidate(1, submission = $$props2.submission);
    if ("cancel" in $$props2) $$invalidate(2, cancel = $$props2.cancel);
  };
  return [names, submission, cancel, btnCancel, word, button1_binding];
}
var RemoveConfirmForm = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance5, create_fragment5, safe_not_equal, { names: 0, submission: 1, cancel: 2 });
  }
};
var RemoveConfirmForm_default = RemoveConfirmForm;

// src/RemoveConfirmModal.ts
var RemoveConfirmModal = class extends import_obsidian4.Modal {
  constructor(app, names, submission) {
    super(app);
    this.names = names;
    this.submission = submission;
  }
  async onSubmit() {
    await this.submission(true);
    this.close();
  }
  onCancel() {
    this.submission(false);
    this.close();
  }
  onOpen() {
    if (!this.names || this.names.length === 0) {
      new import_obsidian4.Notice("Please check at least one property to remove.");
      this.close();
    }
    this.titleEl.createEl("h2", { text: "Remove Properties" });
    this.component = new RemoveConfirmForm_default({
      target: this.contentEl,
      props: {
        names: this.names,
        submission: this.onSubmit.bind(this),
        cancel: this.onCancel.bind(this)
      }
    });
  }
};

// src/RemoveModal.ts
var RemoveModal = class extends import_obsidian5.Modal {
  constructor(app, names, submission) {
    if (!names || names.length === 0) {
      new import_obsidian5.Notice("No properties to remove");
      return;
    }
    super(app);
    this.names = names;
    this.submission = submission;
  }
  async onConfirm(bool) {
    if (bool) {
      await this.submission(this.props);
      this.close();
    }
  }
  onSubmit(props) {
    this.props = props;
    new RemoveConfirmModal(
      this.app,
      this.props,
      this.onConfirm.bind(this)
    ).open();
  }
  onOpen() {
    this.titleEl.createEl("h2", { text: "Remove Properties" });
    this.component = new RemovePropForm_default({
      target: this.contentEl,
      props: {
        names: this.names,
        submission: this.onSubmit.bind(this)
      }
    });
  }
};

// src/frontmatter.ts
async function addProperties(fileProcessor, file, props, overwrite, propCache) {
  await fileProcessor(file, (frontmatter) => {
    for (const [key, value] of props) {
      if (key === "tags") {
        const existingTags = frontmatter[key] || [];
        const newTags = Array.isArray(value.data) ? value.data : [value.data];
        frontmatter[key] = [.../* @__PURE__ */ new Set([...existingTags, ...newTags])];
        continue;
      }
      if (!frontmatter[key] || overwrite) {
        frontmatter[key] = value.data;
        continue;
      }
      let type1 = value.type;
      let type2 = propCache[key.toLowerCase()].type;
      if (canBeAppended(type1, type2)) {
        if (frontmatter[key] === value.data) continue;
        if (!value.data) continue;
        let arr = mergeIntoArrays(frontmatter[key], value.data);
        frontmatter[key] = arr;
        continue;
      } else {
        frontmatter[key] = value.data;
        continue;
      }
    }
  });
}
async function addPropToSet(fileProcessor, set, file) {
  await fileProcessor(file, (frontmatter) => {
    for (const key in frontmatter) {
      console.log({ key });
      set.add(key);
    }
  });
  return set;
}
async function removeProperties(fileProcessor, file, props) {
  await fileProcessor(file, (frontmatter) => {
    for (const prop of props) {
      frontmatter[prop] = void 0;
    }
  });
}
function canBeAppended(str1, str2) {
  let arr = ["number", "date", "datetime", "checkbox"];
  if (arr.includes(str1) || arr.includes(str2)) return false;
  return true;
}
function mergeIntoArrays(...args) {
  const arrays = args.map((arg) => Array.isArray(arg) ? arg : [arg]);
  const flattened = arrays.flat();
  const unique = [...new Set(flattened)];
  return unique;
}

// src/main.ts
var defaultSettings = {
  overwrite: false,
  recursive: true,
  delimiter: ",",
  defaultPropPath: ""
};
var MultiPropPlugin = class extends import_obsidian6.Plugin {
  async loadSettings() {
    this.settings = Object.assign({}, defaultSettings, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async changeOverwrite(bool) {
    this.settings.overwrite = bool;
    await this.saveSettings();
  }
  _getFilesFromTabGroup(leaf) {
    if (!leaf) {
      return [];
    }
    const files = [];
    const fileSet = /* @__PURE__ */ new Set();
    const activeParent = leaf.parent;
    if (activeParent instanceof import_obsidian6.WorkspaceTabs) {
      this.app.workspace.iterateAllLeaves((l) => {
        if (l.parent === activeParent && l.view instanceof import_obsidian6.FileView) {
          const file = l.view.file;
          if (file && !fileSet.has(file.path)) {
            files.push(file);
            fileSet.add(file.path);
          }
        }
      });
    } else {
      const activeWindowRoot = leaf.getRoot();
      this.app.workspace.iterateAllLeaves((l) => {
        if (l.getRoot() === activeWindowRoot && l.view instanceof import_obsidian6.FileView) {
          const file = l.view.file;
          if (file && !fileSet.has(file.path)) {
            files.push(file);
            fileSet.add(file.path);
          }
        }
      });
    }
    return files;
  }
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new SettingTab(this.app, this));
    this.addCommand({
      id: "add-props-to-current-note",
      name: "Add props to current note",
      callback: async () => {
        const file = this.app.workspace.getActiveFile();
        if (!file) {
          new import_obsidian6.Notice("No active file to add properties to.", 4e3);
          return;
        }
        await this.createPropModal([file]);
      }
    });
    this.addCommand({
      id: "remove-props-from-current-note",
      name: "Remove props from current note",
      callback: async () => {
        const file = this.app.workspace.getActiveFile();
        if (!file) {
          new import_obsidian6.Notice("No active file to remove properties from.", 4e3);
          return;
        }
        await this.createRemoveModal([file]);
      }
    });
    this.addCommand({
      id: "add-props-to-tab-group",
      name: "Add props to tabs in active tab group",
      callback: async () => {
        const files = this._getFilesFromTabGroup(this.app.workspace.activeLeaf);
        if (!files || !files.length) {
          new import_obsidian6.Notice("No open tabs in the active tab group to add properties to.", 4e3);
          return;
        }
        await this.createPropModal(files);
      }
    });
    this.addCommand({
      id: "remove-props-from-tab-group",
      name: "Remove props from tabs in active tab group",
      callback: async () => {
        const files = this._getFilesFromTabGroup(this.app.workspace.activeLeaf);
        if (!files || !files.length) {
          new import_obsidian6.Notice("No open tabs in the active tab group to remove properties from.", 4e3);
          return;
        }
        await this.createRemoveModal(files);
      }
    });
  }
  async getPropsFromFolder(folder, names) {
    for (let obj of folder.children) {
      if (obj instanceof import_obsidian6.TFile && obj.extension === "md") {
        names = await addPropToSet(this.app.fileManager.processFrontMatter.bind(this.app.fileManager), names, obj);
      }
      if (obj instanceof import_obsidian6.TFolder) {
        if (this.settings.recursive) {
          await this.getPropsFromFolder(obj, names);
        }
      }
    }
    return [...names].sort();
  }
  async getPropsFromFiles(files, names) {
    for (let file of files) {
      if (file instanceof import_obsidian6.TFile && file.extension === "md") {
        names = await addPropToSet(this.app.fileManager.processFrontMatter.bind(this.app.fileManager), names, file);
      }
    }
    return [...names];
  }
  async searchFolders(folder, callback) {
    for (let obj of folder.children) {
      if (obj instanceof import_obsidian6.TFolder) {
        if (this.settings.recursive) {
          await this.searchFolders(obj, callback);
        }
      }
      if (obj instanceof import_obsidian6.TFile && obj.extension === "md") {
        await callback(obj);
      }
    }
  }
  async searchFiles(files, callback) {
    for (let file of files) {
      if (file instanceof import_obsidian6.TFile && file.extension === "md") {
        await callback(file);
      }
    }
  }
  getFilesFromSearch(leaf) {
    let files = [];
    leaf.dom.vChildren.children.forEach((e) => {
      files.push(e.file);
    });
    return files;
  }
  async createPropModal(iterable) {
    let iterateFunc;
    let files = [];
    if (iterable instanceof import_obsidian6.TFolder) {
      iterateFunc = async (props) => await this.searchFolders(iterable, this.addPropsCallback(props));
    } else {
      files = iterable;
      iterateFunc = async (props) => await this.searchFiles(files, this.addPropsCallback(props));
    }
    let defaultProps;
    if (!this.settings.defaultPropPath) {
      defaultProps = [{ name: "", value: "", type: "text" }];
    } else {
      try {
        const file = this.app.vault.getAbstractFileByPath(
          `${this.settings.defaultPropPath}.md`
        );
        let tmp = this.readYamlProperties(file);
        if (tmp === void 0) throw Error("Undefined path.");
        defaultProps = tmp;
      } catch (e) {
        new import_obsidian6.Notice(
          `${e}.  Check if you entered a valid path in the Default Props File setting.`,
          1e4
        );
        defaultProps = [];
      }
    }
    new PropModal(
      this.app,
      iterateFunc,
      this.settings.overwrite,
      this.settings.delimiter,
      defaultProps,
      this.changeOverwrite.bind(this)
    ).open();
  }
  async createRemoveModal(iterable) {
    let names;
    let iterateFunc;
    if (iterable instanceof import_obsidian6.TFolder) {
      names = await this.getPropsFromFolder(iterable, /* @__PURE__ */ new Set());
      iterateFunc = async (props) => await this.searchFolders(iterable, this.removePropsCallback(props));
    } else {
      names = await this.getPropsFromFiles(iterable, /* @__PURE__ */ new Set());
      iterateFunc = async (props) => await this.searchFiles(iterable, this.removePropsCallback(props));
    }
    if (names.length === 0) {
      new import_obsidian6.Notice("No properties to remove", 4e3);
      return;
    }
    const sortedNames = [...names].sort(
      (a, b) => a.toLowerCase() > b.toLowerCase() ? 1 : -1
    );
    new RemoveModal(this.app, sortedNames, iterateFunc).open();
  }
  readYamlProperties(file) {
    const metadata = this.app.metadataCache.getFileCache(file);
    const frontmatter = metadata == null ? void 0 : metadata.frontmatter;
    if (!frontmatter) {
      new import_obsidian6.Notice("Not a valid Props template.", 4e3);
      return;
    }
    const allPropsWithType = this.app.metadataCache.getAllPropertyInfos();
    let result = [];
    for (let [key, value] of Object.entries(frontmatter)) {
      const keyLower = key.toLowerCase();
      const obj = {
        name: key,
        value,
        type: allPropsWithType[keyLower].type
      };
      result.push(obj);
    }
    return result;
  }
  addPropsCallback(props) {
    return async (file) => {
      await addProperties(this.app.fileManager.processFrontMatter.bind(this.app.fileManager), file, props, this.settings.overwrite, this.app.metadataCache.getAllPropertyInfos());
    };
  }
  removePropsCallback(props) {
    return async (file) => {
      await removeProperties(this.app.fileManager.processFrontMatter.bind(this.app.fileManager), file, props);
    };
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsic3JjL21haW4udHMiLCAic3JjL0FkZFByb3BNb2RhbC50cyIsICJub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL2ludGVybmFsL3V0aWxzLmpzIiwgIm5vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvaW50ZXJuYWwvZ2xvYmFscy5qcyIsICJub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL2ludGVybmFsL1Jlc2l6ZU9ic2VydmVyU2luZ2xldG9uLmpzIiwgIm5vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvaW50ZXJuYWwvZG9tLmpzIiwgIm5vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvaW50ZXJuYWwvbGlmZWN5Y2xlLmpzIiwgIm5vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvaW50ZXJuYWwvc2NoZWR1bGVyLmpzIiwgIm5vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvaW50ZXJuYWwvdHJhbnNpdGlvbnMuanMiLCAibm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvcnVudGltZS9pbnRlcm5hbC9lYWNoLmpzIiwgIm5vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3NoYXJlZC9ib29sZWFuX2F0dHJpYnV0ZXMuanMiLCAibm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvcnVudGltZS9pbnRlcm5hbC9Db21wb25lbnQuanMiLCAibm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvc2hhcmVkL3ZlcnNpb24uanMiLCAibm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvcnVudGltZS9pbnRlcm5hbC9kaXNjbG9zZS12ZXJzaW9uL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanMiLCAic3JjL0FkZFByb3BJbnB1dC5zdmVsdGUiLCAic3JjL2hlbHBlcnMudHMiLCAic3JjL0FkZFByb3BGb3JtLnN2ZWx0ZSIsICJzcmMvQWRkQ29uZmlybU1vZGFsLnRzIiwgInNyYy9BZGRDb25maXJtRm9ybS5zdmVsdGUiLCAic3JjL1NldHRpbmdUYWIudHMiLCAic3JjL1JlbW92ZU1vZGFsLnRzIiwgInNyYy9SZW1vdmVQcm9wRm9ybS5zdmVsdGUiLCAic3JjL1JlbW92ZUNvbmZpcm1Nb2RhbC50cyIsICJzcmMvUmVtb3ZlQ29uZmlybUZvcm0uc3ZlbHRlIiwgInNyYy9mcm9udG1hdHRlci50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgTWVudSwgTm90aWNlLCBQbHVnaW4sIFRBYnN0cmFjdEZpbGUsIFRGaWxlLCBURm9sZGVyLCBGaWxlVmlldywgV29ya3NwYWNlTGVhZiwgV29ya3NwYWNlVGFicyB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHsgUHJvcE1vZGFsIH0gZnJvbSBcIi4vQWRkUHJvcE1vZGFsXCI7XG5pbXBvcnQgeyBNdWx0aVByb3BTZXR0aW5ncywgU2V0dGluZ1RhYiB9IGZyb20gXCIuL1NldHRpbmdUYWJcIjtcbmltcG9ydCB7IFJlbW92ZU1vZGFsIH0gZnJvbSBcIi4vUmVtb3ZlTW9kYWxcIjtcbmltcG9ydCB7IGFkZFByb3BlcnRpZXMsIGFkZFByb3BUb1NldCwgcmVtb3ZlUHJvcGVydGllcyB9IGZyb20gXCIuL2Zyb250bWF0dGVyXCI7XG5pbXBvcnQgeyBQcm9wZXJ0eVR5cGVzIH0gZnJvbSBcIi4vdHlwZXMvY3VzdG9tXCI7XG5cbmRlY2xhcmUgY29uc3QgcHJvY2VzczogYW55O1xuXG5jb25zdCBkZWZhdWx0U2V0dGluZ3M6IE11bHRpUHJvcFNldHRpbmdzID0ge1xuICBvdmVyd3JpdGU6IGZhbHNlLFxuICByZWN1cnNpdmU6IHRydWUsXG4gIGRlbGltaXRlcjogXCIsXCIsXG4gIGRlZmF1bHRQcm9wUGF0aDogXCJcIixcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgTmV3UHJvcERhdGEge1xuICB0eXBlOiBzdHJpbmc7XG4gIGRhdGE6IHN0cmluZyB8IHN0cmluZ1tdIHwgbnVsbDtcbiAgb3ZlcndyaXRlOiBib29sZWFuO1xuICBkZWxpbWl0ZXI6IHN0cmluZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTXVsdGlQcm9wUGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcbiAgc2V0dGluZ3M6IE11bHRpUHJvcFNldHRpbmdzO1xuICBhc3luYyBsb2FkU2V0dGluZ3MoKSB7XG4gICAgdGhpcy5zZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRTZXR0aW5ncywgYXdhaXQgdGhpcy5sb2FkRGF0YSgpKTtcbiAgfVxuXG4gIGFzeW5jIHNhdmVTZXR0aW5ncygpIHtcbiAgICBhd2FpdCB0aGlzLnNhdmVEYXRhKHRoaXMuc2V0dGluZ3MpO1xuICB9XG5cbiAgYXN5bmMgY2hhbmdlT3ZlcndyaXRlKGJvb2w6IGJvb2xlYW4pIHtcbiAgICB0aGlzLnNldHRpbmdzLm92ZXJ3cml0ZSA9IGJvb2w7XG4gICAgYXdhaXQgdGhpcy5zYXZlU2V0dGluZ3MoKTtcbiAgfVxuXG4gIHByaXZhdGUgX2dldEZpbGVzRnJvbVRhYkdyb3VwKGxlYWY6IFdvcmtzcGFjZUxlYWYgfCBudWxsKTogVEZpbGVbXSB7XG4gICAgaWYgKCFsZWFmKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgZmlsZXM6IFRGaWxlW10gPSBbXTtcbiAgICBjb25zdCBmaWxlU2V0ID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gICAgY29uc3QgYWN0aXZlUGFyZW50ID0gbGVhZi5wYXJlbnQ7XG5cbiAgICBpZiAoYWN0aXZlUGFyZW50IGluc3RhbmNlb2YgV29ya3NwYWNlVGFicykge1xuICAgICAgdGhpcy5hcHAud29ya3NwYWNlLml0ZXJhdGVBbGxMZWF2ZXMoKGwpID0+IHtcbiAgICAgICAgaWYgKGwucGFyZW50ID09PSBhY3RpdmVQYXJlbnQgJiYgbC52aWV3IGluc3RhbmNlb2YgRmlsZVZpZXcpIHtcbiAgICAgICAgICBjb25zdCBmaWxlID0gbC52aWV3LmZpbGU7XG4gICAgICAgICAgaWYgKGZpbGUgJiYgIWZpbGVTZXQuaGFzKGZpbGUucGF0aCkpIHtcbiAgICAgICAgICAgIGZpbGVzLnB1c2goZmlsZSk7XG4gICAgICAgICAgICBmaWxlU2V0LmFkZChmaWxlLnBhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZhbGxiYWNrIGZvciBwb3Atb3V0IHdpbmRvd3Mgb3Igb3RoZXIgY2FzZXNcbiAgICAgIGNvbnN0IGFjdGl2ZVdpbmRvd1Jvb3QgPSBsZWFmLmdldFJvb3QoKTtcbiAgICAgIHRoaXMuYXBwLndvcmtzcGFjZS5pdGVyYXRlQWxsTGVhdmVzKChsKSA9PiB7XG4gICAgICAgIGlmIChsLmdldFJvb3QoKSA9PT0gYWN0aXZlV2luZG93Um9vdCAmJiBsLnZpZXcgaW5zdGFuY2VvZiBGaWxlVmlldykge1xuICAgICAgICAgIGNvbnN0IGZpbGUgPSBsLnZpZXcuZmlsZTtcbiAgICAgICAgICBpZiAoZmlsZSAmJiAhZmlsZVNldC5oYXMoZmlsZS5wYXRoKSkge1xuICAgICAgICAgICAgZmlsZXMucHVzaChmaWxlKTtcbiAgICAgICAgICAgIGZpbGVTZXQuYWRkKGZpbGUucGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmlsZXM7XG4gIH1cblxuICBhc3luYyBvbmxvYWQoKSB7XG4gICAgYXdhaXQgdGhpcy5sb2FkU2V0dGluZ3MoKTtcbiAgICB0aGlzLmFkZFNldHRpbmdUYWIobmV3IFNldHRpbmdUYWIodGhpcy5hcHAsIHRoaXMpKTtcblxuICAgIC8vIEFsbCBjb21tYW5kcyBhcmUgcmVzdG9yZWQgaGVyZS5cbiAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgaWQ6IFwiYWRkLXByb3BzLXRvLWN1cnJlbnQtbm90ZVwiLFxuICAgICAgbmFtZTogXCJBZGQgcHJvcHMgdG8gY3VycmVudCBub3RlXCIsXG4gICAgICBjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBmaWxlID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZUZpbGUoKTtcbiAgICAgICAgaWYgKCFmaWxlKSB7XG4gICAgICAgICAgbmV3IE5vdGljZShcIk5vIGFjdGl2ZSBmaWxlIHRvIGFkZCBwcm9wZXJ0aWVzIHRvLlwiLCA0MDAwKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5jcmVhdGVQcm9wTW9kYWwoW2ZpbGVdKTtcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgaWQ6IFwicmVtb3ZlLXByb3BzLWZyb20tY3VycmVudC1ub3RlXCIsXG4gICAgICBuYW1lOiBcIlJlbW92ZSBwcm9wcyBmcm9tIGN1cnJlbnQgbm90ZVwiLFxuICAgICAgY2FsbGJhY2s6IGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgZmlsZSA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVGaWxlKCk7XG4gICAgICAgIGlmICghZmlsZSkge1xuICAgICAgICAgIG5ldyBOb3RpY2UoXCJObyBhY3RpdmUgZmlsZSB0byByZW1vdmUgcHJvcGVydGllcyBmcm9tLlwiLCA0MDAwKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5jcmVhdGVSZW1vdmVNb2RhbChbZmlsZV0pO1xuICAgICAgfSxcbiAgICB9KTtcblxuICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICBpZDogXCJhZGQtcHJvcHMtdG8tdGFiLWdyb3VwXCIsXG4gICAgICBuYW1lOiBcIkFkZCBwcm9wcyB0byB0YWJzIGluIGFjdGl2ZSB0YWIgZ3JvdXBcIixcbiAgICAgIGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGZpbGVzID0gdGhpcy5fZ2V0RmlsZXNGcm9tVGFiR3JvdXAodGhpcy5hcHAud29ya3NwYWNlLmFjdGl2ZUxlYWYpO1xuICAgICAgICBpZiAoIWZpbGVzIHx8ICFmaWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICBuZXcgTm90aWNlKFwiTm8gb3BlbiB0YWJzIGluIHRoZSBhY3RpdmUgdGFiIGdyb3VwIHRvIGFkZCBwcm9wZXJ0aWVzIHRvLlwiLCA0MDAwKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5jcmVhdGVQcm9wTW9kYWwoZmlsZXMpO1xuICAgICAgfSxcbiAgICB9KTtcblxuICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICBpZDogXCJyZW1vdmUtcHJvcHMtZnJvbS10YWItZ3JvdXBcIixcbiAgICAgIG5hbWU6IFwiUmVtb3ZlIHByb3BzIGZyb20gdGFicyBpbiBhY3RpdmUgdGFiIGdyb3VwXCIsXG4gICAgICBjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBmaWxlcyA9IHRoaXMuX2dldEZpbGVzRnJvbVRhYkdyb3VwKHRoaXMuYXBwLndvcmtzcGFjZS5hY3RpdmVMZWFmKTtcbiAgICAgICAgaWYgKCFmaWxlcyB8fCAhZmlsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgbmV3IE5vdGljZShcIk5vIG9wZW4gdGFicyBpbiB0aGUgYWN0aXZlIHRhYiBncm91cCB0byByZW1vdmUgcHJvcGVydGllcyBmcm9tLlwiLCA0MDAwKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5jcmVhdGVSZW1vdmVNb2RhbChmaWxlcyk7XG4gICAgICB9LFxuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgZ2V0UHJvcHNGcm9tRm9sZGVyKGZvbGRlcjogVEZvbGRlciwgbmFtZXM6IFNldDxzdHJpbmc+KSB7XG4gICAgZm9yIChsZXQgb2JqIG9mIGZvbGRlci5jaGlsZHJlbikge1xuICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIFRGaWxlICYmIG9iai5leHRlbnNpb24gPT09IFwibWRcIikge1xuICAgICAgICBuYW1lcyA9IGF3YWl0IGFkZFByb3BUb1NldCh0aGlzLmFwcC5maWxlTWFuYWdlci5wcm9jZXNzRnJvbnRNYXR0ZXIuYmluZCh0aGlzLmFwcC5maWxlTWFuYWdlciksIG5hbWVzLCBvYmopO1xuICAgICAgfVxuICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIFRGb2xkZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MucmVjdXJzaXZlKSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5nZXRQcm9wc0Zyb21Gb2xkZXIob2JqLCBuYW1lcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFsuLi5uYW1lc10uc29ydCgpO1xuICB9XG5cbiAgYXN5bmMgZ2V0UHJvcHNGcm9tRmlsZXMoZmlsZXM6IFRBYnN0cmFjdEZpbGVbXSwgbmFtZXM6IFNldDxzdHJpbmc+KSB7XG4gICAgZm9yIChsZXQgZmlsZSBvZiBmaWxlcykge1xuICAgICAgaWYgKGZpbGUgaW5zdGFuY2VvZiBURmlsZSAmJiBmaWxlLmV4dGVuc2lvbiA9PT0gXCJtZFwiKSB7XG4gICAgICAgIG5hbWVzID0gYXdhaXQgYWRkUHJvcFRvU2V0KHRoaXMuYXBwLmZpbGVNYW5hZ2VyLnByb2Nlc3NGcm9udE1hdHRlci5iaW5kKHRoaXMuYXBwLmZpbGVNYW5hZ2VyKSwgbmFtZXMsIGZpbGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gWy4uLm5hbWVzXTtcbiAgfVxuXG4gIGFzeW5jIHNlYXJjaEZvbGRlcnMoZm9sZGVyOiBURm9sZGVyLCBjYWxsYmFjazogKGZpbGU6IFRGaWxlKSA9PiBhbnkpIHtcbiAgICBmb3IgKGxldCBvYmogb2YgZm9sZGVyLmNoaWxkcmVuKSB7XG4gICAgICBpZiAob2JqIGluc3RhbmNlb2YgVEZvbGRlcikge1xuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5yZWN1cnNpdmUpIHtcbiAgICAgICAgICBhd2FpdCB0aGlzLnNlYXJjaEZvbGRlcnMob2JqLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBURmlsZSAmJiBvYmouZXh0ZW5zaW9uID09PSBcIm1kXCIpIHtcbiAgICAgICAgYXdhaXQgY2FsbGJhY2sob2JqKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhc3luYyBzZWFyY2hGaWxlcyhmaWxlczogVEFic3RyYWN0RmlsZVtdLCBjYWxsYmFjazogKGZpbGU6IFRGaWxlKSA9PiBhbnkpIHtcbiAgICBmb3IgKGxldCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgICBpZiAoZmlsZSBpbnN0YW5jZW9mIFRGaWxlICYmIGZpbGUuZXh0ZW5zaW9uID09PSBcIm1kXCIpIHtcbiAgICAgICAgYXdhaXQgY2FsbGJhY2soZmlsZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZ2V0RmlsZXNGcm9tU2VhcmNoKGxlYWY6IGFueSkge1xuICAgIGxldCBmaWxlczogVEZpbGVbXSA9IFtdO1xuICAgIGxlYWYuZG9tLnZDaGlsZHJlbi5jaGlsZHJlbi5mb3JFYWNoKChlOiBhbnkpID0+IHtcbiAgICAgIGZpbGVzLnB1c2goZS5maWxlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZmlsZXM7XG4gIH1cblxuICBhc3luYyBjcmVhdGVQcm9wTW9kYWwoaXRlcmFibGU6IFRGaWxlW10gfCBURm9sZGVyKSB7XG4gICAgbGV0IGl0ZXJhdGVGdW5jO1xuICAgIGxldCBmaWxlczogVEZpbGVbXSA9IFtdO1xuICAgIGlmIChpdGVyYWJsZSBpbnN0YW5jZW9mIFRGb2xkZXIpIHtcbiAgICAgIGl0ZXJhdGVGdW5jID0gYXN5bmMgKHByb3BzOiBNYXA8c3RyaW5nLCBhbnk+KSA9PlxuICAgICAgICBhd2FpdCB0aGlzLnNlYXJjaEZvbGRlcnMoaXRlcmFibGUsIHRoaXMuYWRkUHJvcHNDYWxsYmFjayhwcm9wcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmaWxlcyA9IGl0ZXJhYmxlO1xuICAgICAgaXRlcmF0ZUZ1bmMgPSBhc3luYyAocHJvcHM6IE1hcDxzdHJpbmcsIGFueT4pID0+XG4gICAgICAgIGF3YWl0IHRoaXMuc2VhcmNoRmlsZXMoZmlsZXMsIHRoaXMuYWRkUHJvcHNDYWxsYmFjayhwcm9wcykpO1xuICAgIH1cblxuICAgIGxldCBkZWZhdWx0UHJvcHM6IHsgbmFtZTogc3RyaW5nOyB2YWx1ZTogYW55OyB0eXBlOiBQcm9wZXJ0eVR5cGVzIH1bXTtcbiAgICBpZiAoIXRoaXMuc2V0dGluZ3MuZGVmYXVsdFByb3BQYXRoKSB7XG4gICAgICBkZWZhdWx0UHJvcHMgPSBbeyBuYW1lOiBcIlwiLCB2YWx1ZTogXCJcIiwgdHlwZTogXCJ0ZXh0XCIgfV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoXG4gICAgICAgICAgYCR7dGhpcy5zZXR0aW5ncy5kZWZhdWx0UHJvcFBhdGh9Lm1kYFxuICAgICAgICApO1xuICAgICAgICBsZXQgdG1wID0gdGhpcy5yZWFkWWFtbFByb3BlcnRpZXMoZmlsZSBhcyBURmlsZSk7XG4gICAgICAgIGlmICh0bXAgPT09IHVuZGVmaW5lZCkgdGhyb3cgRXJyb3IoXCJVbmRlZmluZWQgcGF0aC5cIik7XG4gICAgICAgIGRlZmF1bHRQcm9wcyA9IHRtcDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbmV3IE5vdGljZShcbiAgICAgICAgICBgJHtlfS4gIENoZWNrIGlmIHlvdSBlbnRlcmVkIGEgdmFsaWQgcGF0aCBpbiB0aGUgRGVmYXVsdCBQcm9wcyBGaWxlIHNldHRpbmcuYCxcbiAgICAgICAgICAxMDAwMFxuICAgICAgICApO1xuICAgICAgICBkZWZhdWx0UHJvcHMgPSBbXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBuZXcgUHJvcE1vZGFsKFxuICAgICAgdGhpcy5hcHAsXG4gICAgICBpdGVyYXRlRnVuYyxcbiAgICAgIHRoaXMuc2V0dGluZ3Mub3ZlcndyaXRlLFxuICAgICAgdGhpcy5zZXR0aW5ncy5kZWxpbWl0ZXIsXG4gICAgICBkZWZhdWx0UHJvcHMsXG4gICAgICB0aGlzLmNoYW5nZU92ZXJ3cml0ZS5iaW5kKHRoaXMpXG4gICAgKS5vcGVuKCk7XG4gIH1cblxuICBhc3luYyBjcmVhdGVSZW1vdmVNb2RhbChpdGVyYWJsZTogVEFic3RyYWN0RmlsZVtdIHwgVEZvbGRlcikge1xuICAgIGxldCBuYW1lcztcbiAgICBsZXQgaXRlcmF0ZUZ1bmM7XG5cbiAgICBpZiAoaXRlcmFibGUgaW5zdGFuY2VvZiBURm9sZGVyKSB7XG4gICAgICBuYW1lcyA9IGF3YWl0IHRoaXMuZ2V0UHJvcHNGcm9tRm9sZGVyKGl0ZXJhYmxlLCBuZXcgU2V0KCkpO1xuICAgICAgaXRlcmF0ZUZ1bmMgPSBhc3luYyAocHJvcHM6IHN0cmluZ1tdKSA9PlxuICAgICAgICBhd2FpdCB0aGlzLnNlYXJjaEZvbGRlcnMoaXRlcmFibGUsIHRoaXMucmVtb3ZlUHJvcHNDYWxsYmFjayhwcm9wcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lcyA9IGF3YWl0IHRoaXMuZ2V0UHJvcHNGcm9tRmlsZXMoaXRlcmFibGUsIG5ldyBTZXQoKSk7XG4gICAgICBpdGVyYXRlRnVuYyA9IGFzeW5jIChwcm9wczogc3RyaW5nW10pID0+XG4gICAgICAgIGF3YWl0IHRoaXMuc2VhcmNoRmlsZXMoaXRlcmFibGUsIHRoaXMucmVtb3ZlUHJvcHNDYWxsYmFjayhwcm9wcykpO1xuICAgIH1cbiAgICBpZiAobmFtZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBuZXcgTm90aWNlKFwiTm8gcHJvcGVydGllcyB0byByZW1vdmVcIiwgNDAwMCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc29ydGVkTmFtZXMgPSBbLi4ubmFtZXNdLnNvcnQoKGEsIGIpID0+XG4gICAgICBhLnRvTG93ZXJDYXNlKCkgPiBiLnRvTG93ZXJDYXNlKCkgPyAxIDogLTFcbiAgICApO1xuXG4gICAgbmV3IFJlbW92ZU1vZGFsKHRoaXMuYXBwLCBzb3J0ZWROYW1lcywgaXRlcmF0ZUZ1bmMpLm9wZW4oKTtcbiAgfVxuXG4gIHJlYWRZYW1sUHJvcGVydGllcyhmaWxlOiBURmlsZSkge1xuICAgIGNvbnN0IG1ldGFkYXRhID0gdGhpcy5hcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZmlsZSk7XG4gICAgY29uc3QgZnJvbnRtYXR0ZXIgPSBtZXRhZGF0YT8uZnJvbnRtYXR0ZXI7XG5cbiAgICBpZiAoIWZyb250bWF0dGVyKSB7XG4gICAgICBuZXcgTm90aWNlKFwiTm90IGEgdmFsaWQgUHJvcHMgdGVtcGxhdGUuXCIsIDQwMDApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGFsbFByb3BzV2l0aFR5cGUgPSB0aGlzLmFwcC5tZXRhZGF0YUNhY2hlLmdldEFsbFByb3BlcnR5SW5mb3MoKTtcblxuICAgIGxldCByZXN1bHQ6IHsgbmFtZTogc3RyaW5nOyB2YWx1ZTogYW55OyB0eXBlOiBQcm9wZXJ0eVR5cGVzIH1bXSA9IFtdO1xuXG4gICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGZyb250bWF0dGVyKSkge1xuICAgICAgY29uc3Qga2V5TG93ZXIgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgIGNvbnN0IG9iaiA9IHtcbiAgICAgICAgbmFtZToga2V5LFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIHR5cGU6IGFsbFByb3BzV2l0aFR5cGVba2V5TG93ZXJdLnR5cGUsXG4gICAgICB9O1xuXG4gICAgICByZXN1bHQucHVzaChvYmopO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgYWRkUHJvcHNDYWxsYmFjayhwcm9wczogYW55KSB7XG4gICAgcmV0dXJuIGFzeW5jIChmaWxlOiBURmlsZSkgPT4ge1xuICAgICAgYXdhaXQgYWRkUHJvcGVydGllcyh0aGlzLmFwcC5maWxlTWFuYWdlci5wcm9jZXNzRnJvbnRNYXR0ZXIuYmluZCh0aGlzLmFwcC5maWxlTWFuYWdlciksIGZpbGUsIHByb3BzLCB0aGlzLnNldHRpbmdzLm92ZXJ3cml0ZSwgdGhpcy5hcHAubWV0YWRhdGFDYWNoZS5nZXRBbGxQcm9wZXJ0eUluZm9zKCkpO1xuICAgIH07XG4gIH1cblxuICByZW1vdmVQcm9wc0NhbGxiYWNrKHByb3BzOiBhbnkpIHtcbiAgICByZXR1cm4gYXN5bmMgKGZpbGU6IFRGaWxlKSA9PiB7XG4gICAgICBhd2FpdCByZW1vdmVQcm9wZXJ0aWVzKHRoaXMuYXBwLmZpbGVNYW5hZ2VyLnByb2Nlc3NGcm9udE1hdHRlci5iaW5kKHRoaXMuYXBwLmZpbGVNYW5hZ2VyKSwgZmlsZSwgcHJvcHMpO1xuICAgIH07XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBNb2RhbCwgQXBwIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgUHJvcEZvcm0gZnJvbSBcIi4vQWRkUHJvcEZvcm0uc3ZlbHRlXCI7XG5pbXBvcnQgeyBOZXdQcm9wRGF0YSB9IGZyb20gXCIuL21haW5cIjtcbmltcG9ydCB7IEFkZENvbmZpcm1Nb2RhbCB9IGZyb20gXCIuL0FkZENvbmZpcm1Nb2RhbFwiO1xuaW1wb3J0IHsgUHJvcGVydHlUeXBlcyB9IGZyb20gXCIuL3R5cGVzL2N1c3RvbVwiO1xuXG4vKiogTG9hZHMgYSBtb2RhbCBhbmQgaGFuZGxlcyBmb3JtIHN1Ym1pc3Npb25zLiAqL1xuZXhwb3J0IGNsYXNzIFByb3BNb2RhbCBleHRlbmRzIE1vZGFsIHtcbiAgc3VibWlzc2lvbjogKGN1c3RvbVByb3BzOiBNYXA8c3RyaW5nLCBhbnk+KSA9PiBQcm9taXNlPHZvaWQ+O1xuICBwcm9wczogTWFwPHN0cmluZywgTmV3UHJvcERhdGE+O1xuICBvdmVyd3JpdGU6IGJvb2xlYW47XG4gIGRlbGltaXRlcjogc3RyaW5nO1xuICBkZWZhdWx0UHJvcHM6IHsgbmFtZTogc3RyaW5nOyB2YWx1ZTogYW55OyB0eXBlOiBQcm9wZXJ0eVR5cGVzOyB9W107XG4gIGNoYW5nZUJvb2w6IChib29sOiBib29sZWFuKSA9PiB2b2lkO1xuICBjb21wb25lbnQ6IFByb3BGb3JtO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIGFwcDogQXBwLFxuICAgIHN1Ym1pc3Npb246IChjdXN0b21Qcm9wczogTWFwPHN0cmluZywgYW55PikgPT4gUHJvbWlzZTx2b2lkPixcbiAgICBvdmVyd3JpdGU6IGJvb2xlYW4sXG4gICAgZGVsaW1pdGVyOiBzdHJpbmcsXG4gICAgZGVmYXVsdFByb3BzOiBhbnksXG4gICAgY2hhbmdlQm9vbDogKGJvb2w6IGJvb2xlYW4pID0+IHZvaWRcbiAgKSB7XG4gICAgc3VwZXIoYXBwKTtcbiAgICB0aGlzLnN1Ym1pc3Npb24gPSBzdWJtaXNzaW9uO1xuICAgIHRoaXMub3ZlcndyaXRlID0gb3ZlcndyaXRlO1xuICAgIHRoaXMuZGVsaW1pdGVyID0gZGVsaW1pdGVyO1xuICAgIHRoaXMuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuICAgIHRoaXMuY2hhbmdlQm9vbCA9IGNoYW5nZUJvb2w7XG4gIH1cblxuICAvL1J1biBmb3JtIHN1Ym1pc3Npb24gaWYgdXNlciBjbGlja3MgY29uZmlybS5cbiAgYXN5bmMgb25Db25maXJtKGJvb2w6IGJvb2xlYW4pIHtcbiAgICBpZiAoYm9vbCkge1xuICAgICAgYXdhaXQgdGhpcy5zdWJtaXNzaW9uKHRoaXMucHJvcHMpO1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZUJvb2woYm9vbDogYm9vbGVhbikge1xuICAgIHRoaXMub3ZlcndyaXRlID0gYm9vbDtcbiAgICB0aGlzLmNoYW5nZUJvb2woYm9vbCk7XG4gIH1cblxuICAvL1B1bGwgdXAgY29uZmlybWF0aW9uIGZvcm0gd2hlbiB1c2VyIHN1Ym1pdHMgYmFzZSBmb3JtLlxuICBvblN1Ym1pdChwcm9wczogTWFwPHN0cmluZywgTmV3UHJvcERhdGE+KSB7XG4gICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgIG5ldyBBZGRDb25maXJtTW9kYWwoXG4gICAgICB0aGlzLmFwcCxcbiAgICAgIHRoaXMucHJvcHMsXG4gICAgICB0aGlzLm92ZXJ3cml0ZSxcbiAgICAgIHRoaXMub25Db25maXJtLmJpbmQodGhpcylcbiAgICApLm9wZW4oKTtcbiAgfVxuXG4gIG9uT3BlbigpOiB2b2lkIHtcbiAgICB0aGlzLnRpdGxlRWwuY3JlYXRlRWwoXCJoMlwiLCB7IHRleHQ6IFwiQWRkIFByb3BlcnRpZXNcIiB9KTtcblxuICAgIHRoaXMuY29tcG9uZW50ID0gbmV3IFByb3BGb3JtKHtcbiAgICAgIHRhcmdldDogdGhpcy5jb250ZW50RWwsXG4gICAgICBwcm9wczoge1xuICAgICAgICBzdWJtaXNzaW9uOiB0aGlzLm9uU3VibWl0LmJpbmQodGhpcyksXG4gICAgICAgIG92ZXJ3cml0ZTogdGhpcy5vdmVyd3JpdGUsXG4gICAgICAgIGRlbGltaXRlcjogdGhpcy5kZWxpbWl0ZXIsXG4gICAgICAgIGRlZmF1bHRQcm9wczogdGhpcy5kZWZhdWx0UHJvcHMsXG4gICAgICAgIGNoYW5nZUJvb2w6IHRoaXMudXBkYXRlQm9vbC5iaW5kKHRoaXMpLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxufVxuIiwgIi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBub29wKCkge31cblxuZXhwb3J0IGNvbnN0IGlkZW50aXR5ID0gKHgpID0+IHg7XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEB0ZW1wbGF0ZSBTXG4gKiBAcGFyYW0ge1R9IHRhclxuICogQHBhcmFtIHtTfSBzcmNcbiAqIEByZXR1cm5zIHtUICYgU31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbih0YXIsIHNyYykge1xuXHQvLyBAdHMtaWdub3JlXG5cdGZvciAoY29uc3QgayBpbiBzcmMpIHRhcltrXSA9IHNyY1trXTtcblx0cmV0dXJuIC8qKiBAdHlwZSB7VCAmIFN9ICovICh0YXIpO1xufVxuXG4vLyBBZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3RoZW4vaXMtcHJvbWlzZS9ibG9iL21hc3Rlci9pbmRleC5qc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgTUlUIExpY2Vuc2UgaHR0cHM6Ly9naXRodWIuY29tL3RoZW4vaXMtcHJvbWlzZS9ibG9iL21hc3Rlci9MSUNFTlNFXG4vKipcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHJldHVybnMge3ZhbHVlIGlzIFByb21pc2VMaWtlPGFueT59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19wcm9taXNlKHZhbHVlKSB7XG5cdHJldHVybiAoXG5cdFx0ISF2YWx1ZSAmJlxuXHRcdCh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykgJiZcblx0XHR0eXBlb2YgKC8qKiBAdHlwZSB7YW55fSAqLyAodmFsdWUpLnRoZW4pID09PSAnZnVuY3Rpb24nXG5cdCk7XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRfbG9jYXRpb24oZWxlbWVudCwgZmlsZSwgbGluZSwgY29sdW1uLCBjaGFyKSB7XG5cdGVsZW1lbnQuX19zdmVsdGVfbWV0YSA9IHtcblx0XHRsb2M6IHsgZmlsZSwgbGluZSwgY29sdW1uLCBjaGFyIH1cblx0fTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJ1bihmbikge1xuXHRyZXR1cm4gZm4oKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJsYW5rX29iamVjdCgpIHtcblx0cmV0dXJuIE9iamVjdC5jcmVhdGUobnVsbCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtGdW5jdGlvbltdfSBmbnNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcnVuX2FsbChmbnMpIHtcblx0Zm5zLmZvckVhY2gocnVuKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gdGhpbmdcbiAqIEByZXR1cm5zIHt0aGluZyBpcyBGdW5jdGlvbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX2Z1bmN0aW9uKHRoaW5nKSB7XG5cdHJldHVybiB0eXBlb2YgdGhpbmcgPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKiBAcmV0dXJucyB7Ym9vbGVhbn0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYWZlX25vdF9lcXVhbChhLCBiKSB7XG5cdHJldHVybiBhICE9IGEgPyBiID09IGIgOiBhICE9PSBiIHx8IChhICYmIHR5cGVvZiBhID09PSAnb2JqZWN0JykgfHwgdHlwZW9mIGEgPT09ICdmdW5jdGlvbic7XG59XG5cbmxldCBzcmNfdXJsX2VxdWFsX2FuY2hvcjtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZWxlbWVudF9zcmNcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3JjX3VybF9lcXVhbChlbGVtZW50X3NyYywgdXJsKSB7XG5cdGlmIChlbGVtZW50X3NyYyA9PT0gdXJsKSByZXR1cm4gdHJ1ZTtcblx0aWYgKCFzcmNfdXJsX2VxdWFsX2FuY2hvcikge1xuXHRcdHNyY191cmxfZXF1YWxfYW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuXHR9XG5cdC8vIFRoaXMgaXMgYWN0dWFsbHkgZmFzdGVyIHRoYW4gZG9pbmcgVVJMKC4uKS5ocmVmXG5cdHNyY191cmxfZXF1YWxfYW5jaG9yLmhyZWYgPSB1cmw7XG5cdHJldHVybiBlbGVtZW50X3NyYyA9PT0gc3JjX3VybF9lcXVhbF9hbmNob3IuaHJlZjtcbn1cblxuLyoqIEBwYXJhbSB7c3RyaW5nfSBzcmNzZXQgKi9cbmZ1bmN0aW9uIHNwbGl0X3NyY3NldChzcmNzZXQpIHtcblx0cmV0dXJuIHNyY3NldC5zcGxpdCgnLCcpLm1hcCgoc3JjKSA9PiBzcmMudHJpbSgpLnNwbGl0KCcgJykuZmlsdGVyKEJvb2xlYW4pKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxTb3VyY2VFbGVtZW50IHwgSFRNTEltYWdlRWxlbWVudH0gZWxlbWVudF9zcmNzZXRcbiAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkIHwgbnVsbH0gc3Jjc2V0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNyY3NldF91cmxfZXF1YWwoZWxlbWVudF9zcmNzZXQsIHNyY3NldCkge1xuXHRjb25zdCBlbGVtZW50X3VybHMgPSBzcGxpdF9zcmNzZXQoZWxlbWVudF9zcmNzZXQuc3Jjc2V0KTtcblx0Y29uc3QgdXJscyA9IHNwbGl0X3NyY3NldChzcmNzZXQgfHwgJycpO1xuXG5cdHJldHVybiAoXG5cdFx0dXJscy5sZW5ndGggPT09IGVsZW1lbnRfdXJscy5sZW5ndGggJiZcblx0XHR1cmxzLmV2ZXJ5KFxuXHRcdFx0KFt1cmwsIHdpZHRoXSwgaSkgPT5cblx0XHRcdFx0d2lkdGggPT09IGVsZW1lbnRfdXJsc1tpXVsxXSAmJlxuXHRcdFx0XHQvLyBXZSBuZWVkIHRvIHRlc3QgYm90aCB3YXlzIGJlY2F1c2UgVml0ZSB3aWxsIGNyZWF0ZSBhbiBhIGZ1bGwgVVJMIHdpdGhcblx0XHRcdFx0Ly8gYG5ldyBVUkwoYXNzZXQsIGltcG9ydC5tZXRhLnVybCkuaHJlZmAgZm9yIHRoZSBjbGllbnQgd2hlbiBgYmFzZTogJy4vJ2AsIGFuZCB0aGVcblx0XHRcdFx0Ly8gcmVsYXRpdmUgVVJMcyBpbnNpZGUgc3Jjc2V0IGFyZSBub3QgYXV0b21hdGljYWxseSByZXNvbHZlZCB0byBhYnNvbHV0ZSBVUkxzIGJ5XG5cdFx0XHRcdC8vIGJyb3dzZXJzIChpbiBjb250cmFzdCB0byBpbWcuc3JjKS4gVGhpcyBtZWFucyBib3RoIFNTUiBhbmQgRE9NIGNvZGUgY291bGRcblx0XHRcdFx0Ly8gY29udGFpbiByZWxhdGl2ZSBvciBhYnNvbHV0ZSBVUkxzLlxuXHRcdFx0XHQoc3JjX3VybF9lcXVhbChlbGVtZW50X3VybHNbaV1bMF0sIHVybCkgfHwgc3JjX3VybF9lcXVhbCh1cmwsIGVsZW1lbnRfdXJsc1tpXVswXSkpXG5cdFx0KVxuXHQpO1xufVxuXG4vKiogQHJldHVybnMge2Jvb2xlYW59ICovXG5leHBvcnQgZnVuY3Rpb24gbm90X2VxdWFsKGEsIGIpIHtcblx0cmV0dXJuIGEgIT0gYSA/IGIgPT0gYiA6IGEgIT09IGI7XG59XG5cbi8qKiBAcmV0dXJucyB7Ym9vbGVhbn0gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19lbXB0eShvYmopIHtcblx0cmV0dXJuIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID09PSAwO1xufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVfc3RvcmUoc3RvcmUsIG5hbWUpIHtcblx0aWYgKHN0b3JlICE9IG51bGwgJiYgdHlwZW9mIHN0b3JlLnN1YnNjcmliZSAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdHRocm93IG5ldyBFcnJvcihgJyR7bmFtZX0nIGlzIG5vdCBhIHN0b3JlIHdpdGggYSAnc3Vic2NyaWJlJyBtZXRob2RgKTtcblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc3Vic2NyaWJlKHN0b3JlLCAuLi5jYWxsYmFja3MpIHtcblx0aWYgKHN0b3JlID09IG51bGwpIHtcblx0XHRmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIGNhbGxiYWNrcykge1xuXHRcdFx0Y2FsbGJhY2sodW5kZWZpbmVkKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5vb3A7XG5cdH1cblx0Y29uc3QgdW5zdWIgPSBzdG9yZS5zdWJzY3JpYmUoLi4uY2FsbGJhY2tzKTtcblx0cmV0dXJuIHVuc3ViLnVuc3Vic2NyaWJlID8gKCkgPT4gdW5zdWIudW5zdWJzY3JpYmUoKSA6IHVuc3ViO1xufVxuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCB2YWx1ZSBmcm9tIGEgc3RvcmUgYnkgc3Vic2NyaWJpbmcgYW5kIGltbWVkaWF0ZWx5IHVuc3Vic2NyaWJpbmcuXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLXN0b3JlI2dldFxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9zdG9yZS9wdWJsaWMuanMnKS5SZWFkYWJsZTxUPn0gc3RvcmVcbiAqIEByZXR1cm5zIHtUfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0X3N0b3JlX3ZhbHVlKHN0b3JlKSB7XG5cdGxldCB2YWx1ZTtcblx0c3Vic2NyaWJlKHN0b3JlLCAoXykgPT4gKHZhbHVlID0gXykpKCk7XG5cdHJldHVybiB2YWx1ZTtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBvbmVudF9zdWJzY3JpYmUoY29tcG9uZW50LCBzdG9yZSwgY2FsbGJhY2spIHtcblx0Y29tcG9uZW50LiQkLm9uX2Rlc3Ryb3kucHVzaChzdWJzY3JpYmUoc3RvcmUsIGNhbGxiYWNrKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVfc2xvdChkZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGZuKSB7XG5cdGlmIChkZWZpbml0aW9uKSB7XG5cdFx0Y29uc3Qgc2xvdF9jdHggPSBnZXRfc2xvdF9jb250ZXh0KGRlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZm4pO1xuXHRcdHJldHVybiBkZWZpbml0aW9uWzBdKHNsb3RfY3R4KTtcblx0fVxufVxuXG5mdW5jdGlvbiBnZXRfc2xvdF9jb250ZXh0KGRlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZm4pIHtcblx0cmV0dXJuIGRlZmluaXRpb25bMV0gJiYgZm4gPyBhc3NpZ24oJCRzY29wZS5jdHguc2xpY2UoKSwgZGVmaW5pdGlvblsxXShmbihjdHgpKSkgOiAkJHNjb3BlLmN0eDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldF9zbG90X2NoYW5nZXMoZGVmaW5pdGlvbiwgJCRzY29wZSwgZGlydHksIGZuKSB7XG5cdGlmIChkZWZpbml0aW9uWzJdICYmIGZuKSB7XG5cdFx0Y29uc3QgbGV0cyA9IGRlZmluaXRpb25bMl0oZm4oZGlydHkpKTtcblx0XHRpZiAoJCRzY29wZS5kaXJ0eSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gbGV0cztcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiBsZXRzID09PSAnb2JqZWN0Jykge1xuXHRcdFx0Y29uc3QgbWVyZ2VkID0gW107XG5cdFx0XHRjb25zdCBsZW4gPSBNYXRoLm1heCgkJHNjb3BlLmRpcnR5Lmxlbmd0aCwgbGV0cy5sZW5ndGgpO1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuXHRcdFx0XHRtZXJnZWRbaV0gPSAkJHNjb3BlLmRpcnR5W2ldIHwgbGV0c1tpXTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtZXJnZWQ7XG5cdFx0fVxuXHRcdHJldHVybiAkJHNjb3BlLmRpcnR5IHwgbGV0cztcblx0fVxuXHRyZXR1cm4gJCRzY29wZS5kaXJ0eTtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZV9zbG90X2Jhc2UoXG5cdHNsb3QsXG5cdHNsb3RfZGVmaW5pdGlvbixcblx0Y3R4LFxuXHQkJHNjb3BlLFxuXHRzbG90X2NoYW5nZXMsXG5cdGdldF9zbG90X2NvbnRleHRfZm5cbikge1xuXHRpZiAoc2xvdF9jaGFuZ2VzKSB7XG5cdFx0Y29uc3Qgc2xvdF9jb250ZXh0ID0gZ2V0X3Nsb3RfY29udGV4dChzbG90X2RlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZ2V0X3Nsb3RfY29udGV4dF9mbik7XG5cdFx0c2xvdC5wKHNsb3RfY29udGV4dCwgc2xvdF9jaGFuZ2VzKTtcblx0fVxufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlX3Nsb3QoXG5cdHNsb3QsXG5cdHNsb3RfZGVmaW5pdGlvbixcblx0Y3R4LFxuXHQkJHNjb3BlLFxuXHRkaXJ0eSxcblx0Z2V0X3Nsb3RfY2hhbmdlc19mbixcblx0Z2V0X3Nsb3RfY29udGV4dF9mblxuKSB7XG5cdGNvbnN0IHNsb3RfY2hhbmdlcyA9IGdldF9zbG90X2NoYW5nZXMoc2xvdF9kZWZpbml0aW9uLCAkJHNjb3BlLCBkaXJ0eSwgZ2V0X3Nsb3RfY2hhbmdlc19mbik7XG5cdHVwZGF0ZV9zbG90X2Jhc2Uoc2xvdCwgc2xvdF9kZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIHNsb3RfY2hhbmdlcywgZ2V0X3Nsb3RfY29udGV4dF9mbik7XG59XG5cbi8qKiBAcmV0dXJucyB7YW55W10gfCAtMX0gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRfYWxsX2RpcnR5X2Zyb21fc2NvcGUoJCRzY29wZSkge1xuXHRpZiAoJCRzY29wZS5jdHgubGVuZ3RoID4gMzIpIHtcblx0XHRjb25zdCBkaXJ0eSA9IFtdO1xuXHRcdGNvbnN0IGxlbmd0aCA9ICQkc2NvcGUuY3R4Lmxlbmd0aCAvIDMyO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdGRpcnR5W2ldID0gLTE7XG5cdFx0fVxuXHRcdHJldHVybiBkaXJ0eTtcblx0fVxuXHRyZXR1cm4gLTE7XG59XG5cbi8qKiBAcmV0dXJucyB7e319ICovXG5leHBvcnQgZnVuY3Rpb24gZXhjbHVkZV9pbnRlcm5hbF9wcm9wcyhwcm9wcykge1xuXHRjb25zdCByZXN1bHQgPSB7fTtcblx0Zm9yIChjb25zdCBrIGluIHByb3BzKSBpZiAoa1swXSAhPT0gJyQnKSByZXN1bHRba10gPSBwcm9wc1trXTtcblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqIEByZXR1cm5zIHt7fX0gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlX3Jlc3RfcHJvcHMocHJvcHMsIGtleXMpIHtcblx0Y29uc3QgcmVzdCA9IHt9O1xuXHRrZXlzID0gbmV3IFNldChrZXlzKTtcblx0Zm9yIChjb25zdCBrIGluIHByb3BzKSBpZiAoIWtleXMuaGFzKGspICYmIGtbMF0gIT09ICckJykgcmVzdFtrXSA9IHByb3BzW2tdO1xuXHRyZXR1cm4gcmVzdDtcbn1cblxuLyoqIEByZXR1cm5zIHt7fX0gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlX3Nsb3RzKHNsb3RzKSB7XG5cdGNvbnN0IHJlc3VsdCA9IHt9O1xuXHRmb3IgKGNvbnN0IGtleSBpbiBzbG90cykge1xuXHRcdHJlc3VsdFtrZXldID0gdHJ1ZTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG4vKiogQHJldHVybnMgeyh0aGlzOiBhbnksIC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9uY2UoZm4pIHtcblx0bGV0IHJhbiA9IGZhbHNlO1xuXHRyZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblx0XHRpZiAocmFuKSByZXR1cm47XG5cdFx0cmFuID0gdHJ1ZTtcblx0XHRmbi5jYWxsKHRoaXMsIC4uLmFyZ3MpO1xuXHR9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbnVsbF90b19lbXB0eSh2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRfc3RvcmVfdmFsdWUoc3RvcmUsIHJldCwgdmFsdWUpIHtcblx0c3RvcmUuc2V0KHZhbHVlKTtcblx0cmV0dXJuIHJldDtcbn1cblxuZXhwb3J0IGNvbnN0IGhhc19wcm9wID0gKG9iaiwgcHJvcCkgPT4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBhY3Rpb25fZGVzdHJveWVyKGFjdGlvbl9yZXN1bHQpIHtcblx0cmV0dXJuIGFjdGlvbl9yZXN1bHQgJiYgaXNfZnVuY3Rpb24oYWN0aW9uX3Jlc3VsdC5kZXN0cm95KSA/IGFjdGlvbl9yZXN1bHQuZGVzdHJveSA6IG5vb3A7XG59XG5cbi8qKiBAcGFyYW0ge251bWJlciB8IHN0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtbbnVtYmVyLCBzdHJpbmddfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3BsaXRfY3NzX3VuaXQodmFsdWUpIHtcblx0Y29uc3Qgc3BsaXQgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLm1hdGNoKC9eXFxzKigtP1tcXGQuXSspKFteXFxzXSopXFxzKiQvKTtcblx0cmV0dXJuIHNwbGl0ID8gW3BhcnNlRmxvYXQoc3BsaXRbMV0pLCBzcGxpdFsyXSB8fCAncHgnXSA6IFsvKiogQHR5cGUge251bWJlcn0gKi8gKHZhbHVlKSwgJ3B4J107XG59XG5cbmV4cG9ydCBjb25zdCBjb250ZW50ZWRpdGFibGVfdHJ1dGh5X3ZhbHVlcyA9IFsnJywgdHJ1ZSwgMSwgJ3RydWUnLCAnY29udGVudGVkaXRhYmxlJ107XG4iLCAiLyoqIEB0eXBlIHt0eXBlb2YgZ2xvYmFsVGhpc30gKi9cbmV4cG9ydCBjb25zdCBnbG9iYWxzID1cblx0dHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcblx0XHQ/IHdpbmRvd1xuXHRcdDogdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnXG5cdFx0PyBnbG9iYWxUaGlzXG5cdFx0OiAvLyBAdHMtaWdub3JlIE5vZGUgdHlwaW5ncyBoYXZlIHRoaXNcblx0XHQgIGdsb2JhbDtcbiIsICJpbXBvcnQgeyBnbG9iYWxzIH0gZnJvbSAnLi9nbG9iYWxzLmpzJztcblxuLyoqXG4gKiBSZXNpemUgb2JzZXJ2ZXIgc2luZ2xldG9uLlxuICogT25lIGxpc3RlbmVyIHBlciBlbGVtZW50IG9ubHkhXG4gKiBodHRwczovL2dyb3Vwcy5nb29nbGUuY29tL2EvY2hyb21pdW0ub3JnL2cvYmxpbmstZGV2L2MvejZpZW5PTlViNUEvbS9GNS1WY1VadEJBQUpcbiAqL1xuZXhwb3J0IGNsYXNzIFJlc2l6ZU9ic2VydmVyU2luZ2xldG9uIHtcblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEByZWFkb25seVxuXHQgKiBAdHlwZSB7V2Vha01hcDxFbGVtZW50LCBpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLkxpc3RlbmVyPn1cblx0ICovXG5cdF9saXN0ZW5lcnMgPSAnV2Vha01hcCcgaW4gZ2xvYmFscyA/IG5ldyBXZWFrTWFwKCkgOiB1bmRlZmluZWQ7XG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEB0eXBlIHtSZXNpemVPYnNlcnZlcn1cblx0ICovXG5cdF9vYnNlcnZlciA9IHVuZGVmaW5lZDtcblxuXHQvKiogQHR5cGUge1Jlc2l6ZU9ic2VydmVyT3B0aW9uc30gKi9cblx0b3B0aW9ucztcblxuXHQvKiogQHBhcmFtIHtSZXNpemVPYnNlcnZlck9wdGlvbnN9IG9wdGlvbnMgKi9cblx0Y29uc3RydWN0b3Iob3B0aW9ucykge1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG5cdCAqIEBwYXJhbSB7aW1wb3J0KCcuL3ByaXZhdGUuanMnKS5MaXN0ZW5lcn0gbGlzdGVuZXJcblx0ICogQHJldHVybnMgeygpID0+IHZvaWR9XG5cdCAqL1xuXHRvYnNlcnZlKGVsZW1lbnQsIGxpc3RlbmVyKSB7XG5cdFx0dGhpcy5fbGlzdGVuZXJzLnNldChlbGVtZW50LCBsaXN0ZW5lcik7XG5cdFx0dGhpcy5fZ2V0T2JzZXJ2ZXIoKS5vYnNlcnZlKGVsZW1lbnQsIHRoaXMub3B0aW9ucyk7XG5cdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdHRoaXMuX2xpc3RlbmVycy5kZWxldGUoZWxlbWVudCk7XG5cdFx0XHR0aGlzLl9vYnNlcnZlci51bm9ic2VydmUoZWxlbWVudCk7IC8vIHRoaXMgbGluZSBjYW4gcHJvYmFibHkgYmUgcmVtb3ZlZFxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9nZXRPYnNlcnZlcigpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0dGhpcy5fb2JzZXJ2ZXIgPz9cblx0XHRcdCh0aGlzLl9vYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoZW50cmllcykgPT4ge1xuXHRcdFx0XHRmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcblx0XHRcdFx0XHRSZXNpemVPYnNlcnZlclNpbmdsZXRvbi5lbnRyaWVzLnNldChlbnRyeS50YXJnZXQsIGVudHJ5KTtcblx0XHRcdFx0XHR0aGlzLl9saXN0ZW5lcnMuZ2V0KGVudHJ5LnRhcmdldCk/LihlbnRyeSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pKVxuXHRcdCk7XG5cdH1cbn1cblxuLy8gTmVlZHMgdG8gYmUgd3JpdHRlbiBsaWtlIHRoaXMgdG8gcGFzcyB0aGUgdHJlZS1zaGFrZS10ZXN0XG5SZXNpemVPYnNlcnZlclNpbmdsZXRvbi5lbnRyaWVzID0gJ1dlYWtNYXAnIGluIGdsb2JhbHMgPyBuZXcgV2Vha01hcCgpIDogdW5kZWZpbmVkO1xuIiwgImltcG9ydCB7IGNvbnRlbnRlZGl0YWJsZV90cnV0aHlfdmFsdWVzLCBoYXNfcHJvcCB9IGZyb20gJy4vdXRpbHMuanMnO1xuXG5pbXBvcnQgeyBSZXNpemVPYnNlcnZlclNpbmdsZXRvbiB9IGZyb20gJy4vUmVzaXplT2JzZXJ2ZXJTaW5nbGV0b24uanMnO1xuXG4vLyBUcmFjayB3aGljaCBub2RlcyBhcmUgY2xhaW1lZCBkdXJpbmcgaHlkcmF0aW9uLiBVbmNsYWltZWQgbm9kZXMgY2FuIHRoZW4gYmUgcmVtb3ZlZCBmcm9tIHRoZSBET01cbi8vIGF0IHRoZSBlbmQgb2YgaHlkcmF0aW9uIHdpdGhvdXQgdG91Y2hpbmcgdGhlIHJlbWFpbmluZyBub2Rlcy5cbmxldCBpc19oeWRyYXRpbmcgPSBmYWxzZTtcblxuLyoqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0X2h5ZHJhdGluZygpIHtcblx0aXNfaHlkcmF0aW5nID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuZF9oeWRyYXRpbmcoKSB7XG5cdGlzX2h5ZHJhdGluZyA9IGZhbHNlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3dcbiAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoXG4gKiBAcGFyYW0geyhpbmRleDogbnVtYmVyKSA9PiBudW1iZXJ9IGtleVxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiB1cHBlcl9ib3VuZChsb3csIGhpZ2gsIGtleSwgdmFsdWUpIHtcblx0Ly8gUmV0dXJuIGZpcnN0IGluZGV4IG9mIHZhbHVlIGxhcmdlciB0aGFuIGlucHV0IHZhbHVlIGluIHRoZSByYW5nZSBbbG93LCBoaWdoKVxuXHR3aGlsZSAobG93IDwgaGlnaCkge1xuXHRcdGNvbnN0IG1pZCA9IGxvdyArICgoaGlnaCAtIGxvdykgPj4gMSk7XG5cdFx0aWYgKGtleShtaWQpIDw9IHZhbHVlKSB7XG5cdFx0XHRsb3cgPSBtaWQgKyAxO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRoaWdoID0gbWlkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbG93O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZUV4fSB0YXJnZXRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBpbml0X2h5ZHJhdGUodGFyZ2V0KSB7XG5cdGlmICh0YXJnZXQuaHlkcmF0ZV9pbml0KSByZXR1cm47XG5cdHRhcmdldC5oeWRyYXRlX2luaXQgPSB0cnVlO1xuXHQvLyBXZSBrbm93IHRoYXQgYWxsIGNoaWxkcmVuIGhhdmUgY2xhaW1fb3JkZXIgdmFsdWVzIHNpbmNlIHRoZSB1bmNsYWltZWQgaGF2ZSBiZWVuIGRldGFjaGVkIGlmIHRhcmdldCBpcyBub3QgPGhlYWQ+XG5cblx0bGV0IGNoaWxkcmVuID0gLyoqIEB0eXBlIHtBcnJheUxpa2U8Tm9kZUV4Mj59ICovICh0YXJnZXQuY2hpbGROb2Rlcyk7XG5cdC8vIElmIHRhcmdldCBpcyA8aGVhZD4sIHRoZXJlIG1heSBiZSBjaGlsZHJlbiB3aXRob3V0IGNsYWltX29yZGVyXG5cdGlmICh0YXJnZXQubm9kZU5hbWUgPT09ICdIRUFEJykge1xuXHRcdGNvbnN0IG15X2NoaWxkcmVuID0gW107XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3Qgbm9kZSA9IGNoaWxkcmVuW2ldO1xuXHRcdFx0aWYgKG5vZGUuY2xhaW1fb3JkZXIgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRteV9jaGlsZHJlbi5wdXNoKG5vZGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRjaGlsZHJlbiA9IG15X2NoaWxkcmVuO1xuXHR9XG5cdC8qXG5cdCAqIFJlb3JkZXIgY2xhaW1lZCBjaGlsZHJlbiBvcHRpbWFsbHkuXG5cdCAqIFdlIGNhbiByZW9yZGVyIGNsYWltZWQgY2hpbGRyZW4gb3B0aW1hbGx5IGJ5IGZpbmRpbmcgdGhlIGxvbmdlc3Qgc3Vic2VxdWVuY2Ugb2Zcblx0ICogbm9kZXMgdGhhdCBhcmUgYWxyZWFkeSBjbGFpbWVkIGluIG9yZGVyIGFuZCBvbmx5IG1vdmluZyB0aGUgcmVzdC4gVGhlIGxvbmdlc3Rcblx0ICogc3Vic2VxdWVuY2Ugb2Ygbm9kZXMgdGhhdCBhcmUgY2xhaW1lZCBpbiBvcmRlciBjYW4gYmUgZm91bmQgYnlcblx0ICogY29tcHV0aW5nIHRoZSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2Ugb2YgLmNsYWltX29yZGVyIHZhbHVlcy5cblx0ICpcblx0ICogVGhpcyBhbGdvcml0aG0gaXMgb3B0aW1hbCBpbiBnZW5lcmF0aW5nIHRoZSBsZWFzdCBhbW91bnQgb2YgcmVvcmRlciBvcGVyYXRpb25zXG5cdCAqIHBvc3NpYmxlLlxuXHQgKlxuXHQgKiBQcm9vZjpcblx0ICogV2Uga25vdyB0aGF0LCBnaXZlbiBhIHNldCBvZiByZW9yZGVyaW5nIG9wZXJhdGlvbnMsIHRoZSBub2RlcyB0aGF0IGRvIG5vdCBtb3ZlXG5cdCAqIGFsd2F5cyBmb3JtIGFuIGluY3JlYXNpbmcgc3Vic2VxdWVuY2UsIHNpbmNlIHRoZXkgZG8gbm90IG1vdmUgYW1vbmcgZWFjaCBvdGhlclxuXHQgKiBtZWFuaW5nIHRoYXQgdGhleSBtdXN0IGJlIGFscmVhZHkgb3JkZXJlZCBhbW9uZyBlYWNoIG90aGVyLiBUaHVzLCB0aGUgbWF4aW1hbFxuXHQgKiBzZXQgb2Ygbm9kZXMgdGhhdCBkbyBub3QgbW92ZSBmb3JtIGEgbG9uZ2VzdCBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlLlxuXHQgKi9cblx0Ly8gQ29tcHV0ZSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2Vcblx0Ly8gbTogc3Vic2VxdWVuY2UgbGVuZ3RoIGogPT4gaW5kZXggayBvZiBzbWFsbGVzdCB2YWx1ZSB0aGF0IGVuZHMgYW4gaW5jcmVhc2luZyBzdWJzZXF1ZW5jZSBvZiBsZW5ndGggalxuXHRjb25zdCBtID0gbmV3IEludDMyQXJyYXkoY2hpbGRyZW4ubGVuZ3RoICsgMSk7XG5cdC8vIFByZWRlY2Vzc29yIGluZGljZXMgKyAxXG5cdGNvbnN0IHAgPSBuZXcgSW50MzJBcnJheShjaGlsZHJlbi5sZW5ndGgpO1xuXHRtWzBdID0gLTE7XG5cdGxldCBsb25nZXN0ID0gMDtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdGNvbnN0IGN1cnJlbnQgPSBjaGlsZHJlbltpXS5jbGFpbV9vcmRlcjtcblx0XHQvLyBGaW5kIHRoZSBsYXJnZXN0IHN1YnNlcXVlbmNlIGxlbmd0aCBzdWNoIHRoYXQgaXQgZW5kcyBpbiBhIHZhbHVlIGxlc3MgdGhhbiBvdXIgY3VycmVudCB2YWx1ZVxuXHRcdC8vIHVwcGVyX2JvdW5kIHJldHVybnMgZmlyc3QgZ3JlYXRlciB2YWx1ZSwgc28gd2Ugc3VidHJhY3Qgb25lXG5cdFx0Ly8gd2l0aCBmYXN0IHBhdGggZm9yIHdoZW4gd2UgYXJlIG9uIHRoZSBjdXJyZW50IGxvbmdlc3Qgc3Vic2VxdWVuY2Vcblx0XHRjb25zdCBzZXFfbGVuID1cblx0XHRcdChsb25nZXN0ID4gMCAmJiBjaGlsZHJlblttW2xvbmdlc3RdXS5jbGFpbV9vcmRlciA8PSBjdXJyZW50XG5cdFx0XHRcdD8gbG9uZ2VzdCArIDFcblx0XHRcdFx0OiB1cHBlcl9ib3VuZCgxLCBsb25nZXN0LCAoaWR4KSA9PiBjaGlsZHJlblttW2lkeF1dLmNsYWltX29yZGVyLCBjdXJyZW50KSkgLSAxO1xuXHRcdHBbaV0gPSBtW3NlcV9sZW5dICsgMTtcblx0XHRjb25zdCBuZXdfbGVuID0gc2VxX2xlbiArIDE7XG5cdFx0Ly8gV2UgY2FuIGd1YXJhbnRlZSB0aGF0IGN1cnJlbnQgaXMgdGhlIHNtYWxsZXN0IHZhbHVlLiBPdGhlcndpc2UsIHdlIHdvdWxkIGhhdmUgZ2VuZXJhdGVkIGEgbG9uZ2VyIHNlcXVlbmNlLlxuXHRcdG1bbmV3X2xlbl0gPSBpO1xuXHRcdGxvbmdlc3QgPSBNYXRoLm1heChuZXdfbGVuLCBsb25nZXN0KTtcblx0fVxuXHQvLyBUaGUgbG9uZ2VzdCBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlIG9mIG5vZGVzIChpbml0aWFsbHkgcmV2ZXJzZWQpXG5cblx0LyoqXG5cdCAqIEB0eXBlIHtOb2RlRXgyW119XG5cdCAqL1xuXHRjb25zdCBsaXMgPSBbXTtcblx0Ly8gVGhlIHJlc3Qgb2YgdGhlIG5vZGVzLCBub2RlcyB0aGF0IHdpbGwgYmUgbW92ZWRcblxuXHQvKipcblx0ICogQHR5cGUge05vZGVFeDJbXX1cblx0ICovXG5cdGNvbnN0IHRvX21vdmUgPSBbXTtcblx0bGV0IGxhc3QgPSBjaGlsZHJlbi5sZW5ndGggLSAxO1xuXHRmb3IgKGxldCBjdXIgPSBtW2xvbmdlc3RdICsgMTsgY3VyICE9IDA7IGN1ciA9IHBbY3VyIC0gMV0pIHtcblx0XHRsaXMucHVzaChjaGlsZHJlbltjdXIgLSAxXSk7XG5cdFx0Zm9yICg7IGxhc3QgPj0gY3VyOyBsYXN0LS0pIHtcblx0XHRcdHRvX21vdmUucHVzaChjaGlsZHJlbltsYXN0XSk7XG5cdFx0fVxuXHRcdGxhc3QtLTtcblx0fVxuXHRmb3IgKDsgbGFzdCA+PSAwOyBsYXN0LS0pIHtcblx0XHR0b19tb3ZlLnB1c2goY2hpbGRyZW5bbGFzdF0pO1xuXHR9XG5cdGxpcy5yZXZlcnNlKCk7XG5cdC8vIFdlIHNvcnQgdGhlIG5vZGVzIGJlaW5nIG1vdmVkIHRvIGd1YXJhbnRlZSB0aGF0IHRoZWlyIGluc2VydGlvbiBvcmRlciBtYXRjaGVzIHRoZSBjbGFpbSBvcmRlclxuXHR0b19tb3ZlLnNvcnQoKGEsIGIpID0+IGEuY2xhaW1fb3JkZXIgLSBiLmNsYWltX29yZGVyKTtcblx0Ly8gRmluYWxseSwgd2UgbW92ZSB0aGUgbm9kZXNcblx0Zm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgdG9fbW92ZS5sZW5ndGg7IGkrKykge1xuXHRcdHdoaWxlIChqIDwgbGlzLmxlbmd0aCAmJiB0b19tb3ZlW2ldLmNsYWltX29yZGVyID49IGxpc1tqXS5jbGFpbV9vcmRlcikge1xuXHRcdFx0aisrO1xuXHRcdH1cblx0XHRjb25zdCBhbmNob3IgPSBqIDwgbGlzLmxlbmd0aCA/IGxpc1tqXSA6IG51bGw7XG5cdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSh0b19tb3ZlW2ldLCBhbmNob3IpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmQodGFyZ2V0LCBub2RlKSB7XG5cdHRhcmdldC5hcHBlbmRDaGlsZChub2RlKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICogQHBhcmFtIHtzdHJpbmd9IHN0eWxlX3NoZWV0X2lkXG4gKiBAcGFyYW0ge3N0cmluZ30gc3R5bGVzXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGVuZF9zdHlsZXModGFyZ2V0LCBzdHlsZV9zaGVldF9pZCwgc3R5bGVzKSB7XG5cdGNvbnN0IGFwcGVuZF9zdHlsZXNfdG8gPSBnZXRfcm9vdF9mb3Jfc3R5bGUodGFyZ2V0KTtcblx0aWYgKCFhcHBlbmRfc3R5bGVzX3RvLmdldEVsZW1lbnRCeUlkKHN0eWxlX3NoZWV0X2lkKSkge1xuXHRcdGNvbnN0IHN0eWxlID0gZWxlbWVudCgnc3R5bGUnKTtcblx0XHRzdHlsZS5pZCA9IHN0eWxlX3NoZWV0X2lkO1xuXHRcdHN0eWxlLnRleHRDb250ZW50ID0gc3R5bGVzO1xuXHRcdGFwcGVuZF9zdHlsZXNoZWV0KGFwcGVuZF9zdHlsZXNfdG8sIHN0eWxlKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHJldHVybnMge1NoYWRvd1Jvb3QgfCBEb2N1bWVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldF9yb290X2Zvcl9zdHlsZShub2RlKSB7XG5cdGlmICghbm9kZSkgcmV0dXJuIGRvY3VtZW50O1xuXHRjb25zdCByb290ID0gbm9kZS5nZXRSb290Tm9kZSA/IG5vZGUuZ2V0Um9vdE5vZGUoKSA6IG5vZGUub3duZXJEb2N1bWVudDtcblx0aWYgKHJvb3QgJiYgLyoqIEB0eXBlIHtTaGFkb3dSb290fSAqLyAocm9vdCkuaG9zdCkge1xuXHRcdHJldHVybiAvKiogQHR5cGUge1NoYWRvd1Jvb3R9ICovIChyb290KTtcblx0fVxuXHRyZXR1cm4gbm9kZS5vd25lckRvY3VtZW50O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHJldHVybnMge0NTU1N0eWxlU2hlZXR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRfZW1wdHlfc3R5bGVzaGVldChub2RlKSB7XG5cdGNvbnN0IHN0eWxlX2VsZW1lbnQgPSBlbGVtZW50KCdzdHlsZScpO1xuXHQvLyBGb3IgdHJhbnNpdGlvbnMgdG8gd29yayB3aXRob3V0ICdzdHlsZS1zcmM6IHVuc2FmZS1pbmxpbmUnIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5LFxuXHQvLyB0aGVzZSBlbXB0eSB0YWdzIG5lZWQgdG8gYmUgYWxsb3dlZCB3aXRoIGEgaGFzaCBhcyBhIHdvcmthcm91bmQgdW50aWwgd2UgbW92ZSB0byB0aGUgV2ViIEFuaW1hdGlvbnMgQVBJLlxuXHQvLyBVc2luZyB0aGUgaGFzaCBmb3IgdGhlIGVtcHR5IHN0cmluZyAoZm9yIGFuIGVtcHR5IHRhZykgd29ya3MgaW4gYWxsIGJyb3dzZXJzIGV4Y2VwdCBTYWZhcmkuXG5cdC8vIFNvIGFzIGEgd29ya2Fyb3VuZCBmb3IgdGhlIHdvcmthcm91bmQsIHdoZW4gd2UgYXBwZW5kIGVtcHR5IHN0eWxlIHRhZ3Mgd2Ugc2V0IHRoZWlyIGNvbnRlbnQgdG8gLyogZW1wdHkgKi8uXG5cdC8vIFRoZSBoYXNoICdzaGEyNTYtOU9sTk8wRE5FZWFWekhMNFJad0NMc0JIQThXQlE4dG9CcC80RjVYVjJuYz0nIHdpbGwgdGhlbiB3b3JrIGV2ZW4gaW4gU2FmYXJpLlxuXHRzdHlsZV9lbGVtZW50LnRleHRDb250ZW50ID0gJy8qIGVtcHR5ICovJztcblx0YXBwZW5kX3N0eWxlc2hlZXQoZ2V0X3Jvb3RfZm9yX3N0eWxlKG5vZGUpLCBzdHlsZV9lbGVtZW50KTtcblx0cmV0dXJuIHN0eWxlX2VsZW1lbnQuc2hlZXQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTaGFkb3dSb290IHwgRG9jdW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7SFRNTFN0eWxlRWxlbWVudH0gc3R5bGVcbiAqIEByZXR1cm5zIHtDU1NTdHlsZVNoZWV0fVxuICovXG5mdW5jdGlvbiBhcHBlbmRfc3R5bGVzaGVldChub2RlLCBzdHlsZSkge1xuXHRhcHBlbmQoLyoqIEB0eXBlIHtEb2N1bWVudH0gKi8gKG5vZGUpLmhlYWQgfHwgbm9kZSwgc3R5bGUpO1xuXHRyZXR1cm4gc3R5bGUuc2hlZXQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlRXh9IHRhcmdldFxuICogQHBhcmFtIHtOb2RlRXh9IG5vZGVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kX2h5ZHJhdGlvbih0YXJnZXQsIG5vZGUpIHtcblx0aWYgKGlzX2h5ZHJhdGluZykge1xuXHRcdGluaXRfaHlkcmF0ZSh0YXJnZXQpO1xuXHRcdGlmIChcblx0XHRcdHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkID09PSB1bmRlZmluZWQgfHxcblx0XHRcdCh0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCAhPT0gbnVsbCAmJiB0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZC5wYXJlbnROb2RlICE9PSB0YXJnZXQpXG5cdFx0KSB7XG5cdFx0XHR0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCA9IHRhcmdldC5maXJzdENoaWxkO1xuXHRcdH1cblx0XHQvLyBTa2lwIG5vZGVzIG9mIHVuZGVmaW5lZCBvcmRlcmluZ1xuXHRcdHdoaWxlICh0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCAhPT0gbnVsbCAmJiB0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZC5jbGFpbV9vcmRlciA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCA9IHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkLm5leHRTaWJsaW5nO1xuXHRcdH1cblx0XHRpZiAobm9kZSAhPT0gdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQpIHtcblx0XHRcdC8vIFdlIG9ubHkgaW5zZXJ0IGlmIHRoZSBvcmRlcmluZyBvZiB0aGlzIG5vZGUgc2hvdWxkIGJlIG1vZGlmaWVkIG9yIHRoZSBwYXJlbnQgbm9kZSBpcyBub3QgdGFyZ2V0XG5cdFx0XHRpZiAobm9kZS5jbGFpbV9vcmRlciAhPT0gdW5kZWZpbmVkIHx8IG5vZGUucGFyZW50Tm9kZSAhPT0gdGFyZ2V0KSB7XG5cdFx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUobm9kZSwgdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCA9IG5vZGUubmV4dFNpYmxpbmc7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKG5vZGUucGFyZW50Tm9kZSAhPT0gdGFyZ2V0IHx8IG5vZGUubmV4dFNpYmxpbmcgIT09IG51bGwpIHtcblx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQobm9kZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge05vZGV9IFthbmNob3JdXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluc2VydCh0YXJnZXQsIG5vZGUsIGFuY2hvcikge1xuXHR0YXJnZXQuaW5zZXJ0QmVmb3JlKG5vZGUsIGFuY2hvciB8fCBudWxsKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGVFeH0gdGFyZ2V0XG4gKiBAcGFyYW0ge05vZGVFeH0gbm9kZVxuICogQHBhcmFtIHtOb2RlRXh9IFthbmNob3JdXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluc2VydF9oeWRyYXRpb24odGFyZ2V0LCBub2RlLCBhbmNob3IpIHtcblx0aWYgKGlzX2h5ZHJhdGluZyAmJiAhYW5jaG9yKSB7XG5cdFx0YXBwZW5kX2h5ZHJhdGlvbih0YXJnZXQsIG5vZGUpO1xuXHR9IGVsc2UgaWYgKG5vZGUucGFyZW50Tm9kZSAhPT0gdGFyZ2V0IHx8IG5vZGUubmV4dFNpYmxpbmcgIT0gYW5jaG9yKSB7XG5cdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShub2RlLCBhbmNob3IgfHwgbnVsbCk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGV0YWNoKG5vZGUpIHtcblx0aWYgKG5vZGUucGFyZW50Tm9kZSkge1xuXHRcdG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcblx0fVxufVxuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlc3Ryb3lfZWFjaChpdGVyYXRpb25zLCBkZXRhY2hpbmcpIHtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyYXRpb25zLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0aWYgKGl0ZXJhdGlvbnNbaV0pIGl0ZXJhdGlvbnNbaV0uZChkZXRhY2hpbmcpO1xuXHR9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIHtrZXlvZiBIVE1MRWxlbWVudFRhZ05hbWVNYXB9IEtcbiAqIEBwYXJhbSB7S30gbmFtZVxuICogQHJldHVybnMge0hUTUxFbGVtZW50VGFnTmFtZU1hcFtLXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVsZW1lbnQobmFtZSkge1xuXHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lKTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge2tleW9mIEhUTUxFbGVtZW50VGFnTmFtZU1hcH0gS1xuICogQHBhcmFtIHtLfSBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gaXNcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudFRhZ05hbWVNYXBbS119XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbGVtZW50X2lzKG5hbWUsIGlzKSB7XG5cdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUsIHsgaXMgfSk7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEB0ZW1wbGF0ZSB7a2V5b2YgVH0gS1xuICogQHBhcmFtIHtUfSBvYmpcbiAqIEBwYXJhbSB7S1tdfSBleGNsdWRlXG4gKiBAcmV0dXJucyB7UGljazxULCBFeGNsdWRlPGtleW9mIFQsIEs+Pn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9iamVjdF93aXRob3V0X3Byb3BlcnRpZXMob2JqLCBleGNsdWRlKSB7XG5cdGNvbnN0IHRhcmdldCA9IC8qKiBAdHlwZSB7UGljazxULCBFeGNsdWRlPGtleW9mIFQsIEs+Pn0gKi8gKHt9KTtcblx0Zm9yIChjb25zdCBrIGluIG9iaikge1xuXHRcdGlmIChcblx0XHRcdGhhc19wcm9wKG9iaiwgaykgJiZcblx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdGV4Y2x1ZGUuaW5kZXhPZihrKSA9PT0gLTFcblx0XHQpIHtcblx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdHRhcmdldFtrXSA9IG9ialtrXTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHRhcmdldDtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge2tleW9mIFNWR0VsZW1lbnRUYWdOYW1lTWFwfSBLXG4gKiBAcGFyYW0ge0t9IG5hbWVcbiAqIEByZXR1cm5zIHtTVkdFbGVtZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3ZnX2VsZW1lbnQobmFtZSkge1xuXHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsIG5hbWUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhXG4gKiBAcmV0dXJucyB7VGV4dH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRleHQoZGF0YSkge1xuXHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZGF0YSk7XG59XG5cbi8qKlxuICogQHJldHVybnMge1RleHR9ICovXG5leHBvcnQgZnVuY3Rpb24gc3BhY2UoKSB7XG5cdHJldHVybiB0ZXh0KCcgJyk7XG59XG5cbi8qKlxuICogQHJldHVybnMge1RleHR9ICovXG5leHBvcnQgZnVuY3Rpb24gZW1wdHkoKSB7XG5cdHJldHVybiB0ZXh0KCcnKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGVudFxuICogQHJldHVybnMge0NvbW1lbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21tZW50KGNvbnRlbnQpIHtcblx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoY29udGVudCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0V2ZW50TGlzdGVuZXJPckV2ZW50TGlzdGVuZXJPYmplY3R9IGhhbmRsZXJcbiAqIEBwYXJhbSB7Ym9vbGVhbiB8IEFkZEV2ZW50TGlzdGVuZXJPcHRpb25zIHwgRXZlbnRMaXN0ZW5lck9wdGlvbnN9IFtvcHRpb25zXVxuICogQHJldHVybnMgeygpID0+IHZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaXN0ZW4obm9kZSwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpIHtcblx0bm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcblx0cmV0dXJuICgpID0+IG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogQHJldHVybnMgeyhldmVudDogYW55KSA9PiBhbnl9ICovXG5leHBvcnQgZnVuY3Rpb24gcHJldmVudF9kZWZhdWx0KGZuKSB7XG5cdHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRyZXR1cm4gZm4uY2FsbCh0aGlzLCBldmVudCk7XG5cdH07XG59XG5cbi8qKlxuICogQHJldHVybnMgeyhldmVudDogYW55KSA9PiBhbnl9ICovXG5leHBvcnQgZnVuY3Rpb24gc3RvcF9wcm9wYWdhdGlvbihmbikge1xuXHRyZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdHJldHVybiBmbi5jYWxsKHRoaXMsIGV2ZW50KTtcblx0fTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7KGV2ZW50OiBhbnkpID0+IGFueX0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdG9wX2ltbWVkaWF0ZV9wcm9wYWdhdGlvbihmbikge1xuXHRyZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdHJldHVybiBmbi5jYWxsKHRoaXMsIGV2ZW50KTtcblx0fTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7KGV2ZW50OiBhbnkpID0+IHZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gc2VsZihmbikge1xuXHRyZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdGlmIChldmVudC50YXJnZXQgPT09IHRoaXMpIGZuLmNhbGwodGhpcywgZXZlbnQpO1xuXHR9O1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHsoZXZlbnQ6IGFueSkgPT4gdm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cnVzdGVkKGZuKSB7XG5cdHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0aWYgKGV2ZW50LmlzVHJ1c3RlZCkgZm4uY2FsbCh0aGlzLCBldmVudCk7XG5cdH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gW3ZhbHVlXVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhdHRyKG5vZGUsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcblx0aWYgKHZhbHVlID09IG51bGwpIG5vZGUucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG5cdGVsc2UgaWYgKG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZSkgIT09IHZhbHVlKSBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIHZhbHVlKTtcbn1cbi8qKlxuICogTGlzdCBvZiBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIGFsd2F5cyBiZSBzZXQgdGhyb3VnaCB0aGUgYXR0ciBtZXRob2QsXG4gKiBiZWNhdXNlIHVwZGF0aW5nIHRoZW0gdGhyb3VnaCB0aGUgcHJvcGVydHkgc2V0dGVyIGRvZXNuJ3Qgd29yayByZWxpYWJseS5cbiAqIEluIHRoZSBleGFtcGxlIG9mIGB3aWR0aGAvYGhlaWdodGAsIHRoZSBwcm9ibGVtIGlzIHRoYXQgdGhlIHNldHRlciBvbmx5XG4gKiBhY2NlcHRzIG51bWVyaWMgdmFsdWVzLCBidXQgdGhlIGF0dHJpYnV0ZSBjYW4gYWxzbyBiZSBzZXQgdG8gYSBzdHJpbmcgbGlrZSBgNTAlYC5cbiAqIElmIHRoaXMgbGlzdCBiZWNvbWVzIHRvbyBiaWcsIHJldGhpbmsgdGhpcyBhcHByb2FjaC5cbiAqL1xuY29uc3QgYWx3YXlzX3NldF90aHJvdWdoX3NldF9hdHRyaWJ1dGUgPSBbJ3dpZHRoJywgJ2hlaWdodCddO1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudCAmIEVsZW1lbnRDU1NJbmxpbmVTdHlsZX0gbm9kZVxuICogQHBhcmFtIHt7IFt4OiBzdHJpbmddOiBzdHJpbmcgfX0gYXR0cmlidXRlc1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfYXR0cmlidXRlcyhub2RlLCBhdHRyaWJ1dGVzKSB7XG5cdC8vIEB0cy1pZ25vcmVcblx0Y29uc3QgZGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhub2RlLl9fcHJvdG9fXyk7XG5cdGZvciAoY29uc3Qga2V5IGluIGF0dHJpYnV0ZXMpIHtcblx0XHRpZiAoYXR0cmlidXRlc1trZXldID09IG51bGwpIHtcblx0XHRcdG5vZGUucmVtb3ZlQXR0cmlidXRlKGtleSk7XG5cdFx0fSBlbHNlIGlmIChrZXkgPT09ICdzdHlsZScpIHtcblx0XHRcdG5vZGUuc3R5bGUuY3NzVGV4dCA9IGF0dHJpYnV0ZXNba2V5XTtcblx0XHR9IGVsc2UgaWYgKGtleSA9PT0gJ19fdmFsdWUnKSB7XG5cdFx0XHQvKiogQHR5cGUge2FueX0gKi8gKG5vZGUpLnZhbHVlID0gbm9kZVtrZXldID0gYXR0cmlidXRlc1trZXldO1xuXHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRkZXNjcmlwdG9yc1trZXldICYmXG5cdFx0XHRkZXNjcmlwdG9yc1trZXldLnNldCAmJlxuXHRcdFx0YWx3YXlzX3NldF90aHJvdWdoX3NldF9hdHRyaWJ1dGUuaW5kZXhPZihrZXkpID09PSAtMVxuXHRcdCkge1xuXHRcdFx0bm9kZVtrZXldID0gYXR0cmlidXRlc1trZXldO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhdHRyKG5vZGUsIGtleSwgYXR0cmlidXRlc1trZXldKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnQgJiBFbGVtZW50Q1NTSW5saW5lU3R5bGV9IG5vZGVcbiAqIEBwYXJhbSB7eyBbeDogc3RyaW5nXTogc3RyaW5nIH19IGF0dHJpYnV0ZXNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X3N2Z19hdHRyaWJ1dGVzKG5vZGUsIGF0dHJpYnV0ZXMpIHtcblx0Zm9yIChjb25zdCBrZXkgaW4gYXR0cmlidXRlcykge1xuXHRcdGF0dHIobm9kZSwga2V5LCBhdHRyaWJ1dGVzW2tleV0pO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn0gZGF0YV9tYXBcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2N1c3RvbV9lbGVtZW50X2RhdGFfbWFwKG5vZGUsIGRhdGFfbWFwKSB7XG5cdE9iamVjdC5rZXlzKGRhdGFfbWFwKS5mb3JFYWNoKChrZXkpID0+IHtcblx0XHRzZXRfY3VzdG9tX2VsZW1lbnRfZGF0YShub2RlLCBrZXksIGRhdGFfbWFwW2tleV0pO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfY3VzdG9tX2VsZW1lbnRfZGF0YShub2RlLCBwcm9wLCB2YWx1ZSkge1xuXHRjb25zdCBsb3dlciA9IHByb3AudG9Mb3dlckNhc2UoKTsgLy8gZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggZXhpc3RpbmcgYmVoYXZpb3Igd2UgZG8gbG93ZXJjYXNlIGZpcnN0XG5cdGlmIChsb3dlciBpbiBub2RlKSB7XG5cdFx0bm9kZVtsb3dlcl0gPSB0eXBlb2Ygbm9kZVtsb3dlcl0gPT09ICdib29sZWFuJyAmJiB2YWx1ZSA9PT0gJycgPyB0cnVlIDogdmFsdWU7XG5cdH0gZWxzZSBpZiAocHJvcCBpbiBub2RlKSB7XG5cdFx0bm9kZVtwcm9wXSA9IHR5cGVvZiBub2RlW3Byb3BdID09PSAnYm9vbGVhbicgJiYgdmFsdWUgPT09ICcnID8gdHJ1ZSA6IHZhbHVlO1xuXHR9IGVsc2Uge1xuXHRcdGF0dHIobm9kZSwgcHJvcCwgdmFsdWUpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2R5bmFtaWNfZWxlbWVudF9kYXRhKHRhZykge1xuXHRyZXR1cm4gLy0vLnRlc3QodGFnKSA/IHNldF9jdXN0b21fZWxlbWVudF9kYXRhX21hcCA6IHNldF9hdHRyaWJ1dGVzO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24geGxpbmtfYXR0cihub2RlLCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG5cdG5vZGUuc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCBhdHRyaWJ1dGUsIHZhbHVlKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0X3N2ZWx0ZV9kYXRhc2V0KG5vZGUpIHtcblx0cmV0dXJuIG5vZGUuZGF0YXNldC5zdmVsdGVIO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHt1bmtub3duW119ICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0X2JpbmRpbmdfZ3JvdXBfdmFsdWUoZ3JvdXAsIF9fdmFsdWUsIGNoZWNrZWQpIHtcblx0Y29uc3QgdmFsdWUgPSBuZXcgU2V0KCk7XG5cdGZvciAobGV0IGkgPSAwOyBpIDwgZ3JvdXAubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRpZiAoZ3JvdXBbaV0uY2hlY2tlZCkgdmFsdWUuYWRkKGdyb3VwW2ldLl9fdmFsdWUpO1xuXHR9XG5cdGlmICghY2hlY2tlZCkge1xuXHRcdHZhbHVlLmRlbGV0ZShfX3ZhbHVlKTtcblx0fVxuXHRyZXR1cm4gQXJyYXkuZnJvbSh2YWx1ZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50W119IGdyb3VwXG4gKiBAcmV0dXJucyB7eyBwKC4uLmlucHV0czogSFRNTElucHV0RWxlbWVudFtdKTogdm9pZDsgcigpOiB2b2lkOyB9fVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdF9iaW5kaW5nX2dyb3VwKGdyb3VwKSB7XG5cdC8qKlxuXHQgKiBAdHlwZSB7SFRNTElucHV0RWxlbWVudFtdfSAqL1xuXHRsZXQgX2lucHV0cztcblx0cmV0dXJuIHtcblx0XHQvKiBwdXNoICovIHAoLi4uaW5wdXRzKSB7XG5cdFx0XHRfaW5wdXRzID0gaW5wdXRzO1xuXHRcdFx0X2lucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4gZ3JvdXAucHVzaChpbnB1dCkpO1xuXHRcdH0sXG5cdFx0LyogcmVtb3ZlICovIHIoKSB7XG5cdFx0XHRfaW5wdXRzLmZvckVhY2goKGlucHV0KSA9PiBncm91cC5zcGxpY2UoZ3JvdXAuaW5kZXhPZihpbnB1dCksIDEpKTtcblx0XHR9XG5cdH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJbXX0gaW5kZXhlc1xuICogQHJldHVybnMge3sgdShuZXdfaW5kZXhlczogbnVtYmVyW10pOiB2b2lkOyBwKC4uLmlucHV0czogSFRNTElucHV0RWxlbWVudFtdKTogdm9pZDsgcjogKCkgPT4gdm9pZDsgfX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluaXRfYmluZGluZ19ncm91cF9keW5hbWljKGdyb3VwLCBpbmRleGVzKSB7XG5cdC8qKlxuXHQgKiBAdHlwZSB7SFRNTElucHV0RWxlbWVudFtdfSAqL1xuXHRsZXQgX2dyb3VwID0gZ2V0X2JpbmRpbmdfZ3JvdXAoZ3JvdXApO1xuXG5cdC8qKlxuXHQgKiBAdHlwZSB7SFRNTElucHV0RWxlbWVudFtdfSAqL1xuXHRsZXQgX2lucHV0cztcblxuXHRmdW5jdGlvbiBnZXRfYmluZGluZ19ncm91cChncm91cCkge1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXhlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0Z3JvdXAgPSBncm91cFtpbmRleGVzW2ldXSA9IGdyb3VwW2luZGV4ZXNbaV1dIHx8IFtdO1xuXHRcdH1cblx0XHRyZXR1cm4gZ3JvdXA7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge3ZvaWR9ICovXG5cdGZ1bmN0aW9uIHB1c2goKSB7XG5cdFx0X2lucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4gX2dyb3VwLnB1c2goaW5wdXQpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7dm9pZH0gKi9cblx0ZnVuY3Rpb24gcmVtb3ZlKCkge1xuXHRcdF9pbnB1dHMuZm9yRWFjaCgoaW5wdXQpID0+IF9ncm91cC5zcGxpY2UoX2dyb3VwLmluZGV4T2YoaW5wdXQpLCAxKSk7XG5cdH1cblx0cmV0dXJuIHtcblx0XHQvKiB1cGRhdGUgKi8gdShuZXdfaW5kZXhlcykge1xuXHRcdFx0aW5kZXhlcyA9IG5ld19pbmRleGVzO1xuXHRcdFx0Y29uc3QgbmV3X2dyb3VwID0gZ2V0X2JpbmRpbmdfZ3JvdXAoZ3JvdXApO1xuXHRcdFx0aWYgKG5ld19ncm91cCAhPT0gX2dyb3VwKSB7XG5cdFx0XHRcdHJlbW92ZSgpO1xuXHRcdFx0XHRfZ3JvdXAgPSBuZXdfZ3JvdXA7XG5cdFx0XHRcdHB1c2goKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdC8qIHB1c2ggKi8gcCguLi5pbnB1dHMpIHtcblx0XHRcdF9pbnB1dHMgPSBpbnB1dHM7XG5cdFx0XHRwdXNoKCk7XG5cdFx0fSxcblx0XHQvKiByZW1vdmUgKi8gcjogcmVtb3ZlXG5cdH07XG59XG5cbi8qKiBAcmV0dXJucyB7bnVtYmVyfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvX251bWJlcih2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUgPT09ICcnID8gbnVsbCA6ICt2YWx1ZTtcbn1cblxuLyoqIEByZXR1cm5zIHthbnlbXX0gKi9cbmV4cG9ydCBmdW5jdGlvbiB0aW1lX3Jhbmdlc190b19hcnJheShyYW5nZXMpIHtcblx0Y29uc3QgYXJyYXkgPSBbXTtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRhcnJheS5wdXNoKHsgc3RhcnQ6IHJhbmdlcy5zdGFydChpKSwgZW5kOiByYW5nZXMuZW5kKGkpIH0pO1xuXHR9XG5cdHJldHVybiBhcnJheTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtDaGlsZE5vZGVbXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoaWxkcmVuKGVsZW1lbnQpIHtcblx0cmV0dXJuIEFycmF5LmZyb20oZWxlbWVudC5jaGlsZE5vZGVzKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NoaWxkTm9kZUFycmF5fSBub2Rlc1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIGluaXRfY2xhaW1faW5mbyhub2Rlcykge1xuXHRpZiAobm9kZXMuY2xhaW1faW5mbyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0bm9kZXMuY2xhaW1faW5mbyA9IHsgbGFzdF9pbmRleDogMCwgdG90YWxfY2xhaW1lZDogMCB9O1xuXHR9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIHtDaGlsZE5vZGVFeH0gUlxuICogQHBhcmFtIHtDaGlsZE5vZGVBcnJheX0gbm9kZXNcbiAqIEBwYXJhbSB7KG5vZGU6IENoaWxkTm9kZUV4KSA9PiBub2RlIGlzIFJ9IHByZWRpY2F0ZVxuICogQHBhcmFtIHsobm9kZTogQ2hpbGROb2RlRXgpID0+IENoaWxkTm9kZUV4IHwgdW5kZWZpbmVkfSBwcm9jZXNzX25vZGVcbiAqIEBwYXJhbSB7KCkgPT4gUn0gY3JlYXRlX25vZGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZG9udF91cGRhdGVfbGFzdF9pbmRleFxuICogQHJldHVybnMge1J9XG4gKi9cbmZ1bmN0aW9uIGNsYWltX25vZGUobm9kZXMsIHByZWRpY2F0ZSwgcHJvY2Vzc19ub2RlLCBjcmVhdGVfbm9kZSwgZG9udF91cGRhdGVfbGFzdF9pbmRleCA9IGZhbHNlKSB7XG5cdC8vIFRyeSB0byBmaW5kIG5vZGVzIGluIGFuIG9yZGVyIHN1Y2ggdGhhdCB3ZSBsZW5ndGhlbiB0aGUgbG9uZ2VzdCBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlXG5cdGluaXRfY2xhaW1faW5mbyhub2Rlcyk7XG5cdGNvbnN0IHJlc3VsdF9ub2RlID0gKCgpID0+IHtcblx0XHQvLyBXZSBmaXJzdCB0cnkgdG8gZmluZCBhbiBlbGVtZW50IGFmdGVyIHRoZSBwcmV2aW91cyBvbmVcblx0XHRmb3IgKGxldCBpID0gbm9kZXMuY2xhaW1faW5mby5sYXN0X2luZGV4OyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcblx0XHRcdGlmIChwcmVkaWNhdGUobm9kZSkpIHtcblx0XHRcdFx0Y29uc3QgcmVwbGFjZW1lbnQgPSBwcm9jZXNzX25vZGUobm9kZSk7XG5cdFx0XHRcdGlmIChyZXBsYWNlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0bm9kZXMuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG5vZGVzW2ldID0gcmVwbGFjZW1lbnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFkb250X3VwZGF0ZV9sYXN0X2luZGV4KSB7XG5cdFx0XHRcdFx0bm9kZXMuY2xhaW1faW5mby5sYXN0X2luZGV4ID0gaTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbm9kZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gT3RoZXJ3aXNlLCB3ZSB0cnkgdG8gZmluZCBvbmUgYmVmb3JlXG5cdFx0Ly8gV2UgaXRlcmF0ZSBpbiByZXZlcnNlIHNvIHRoYXQgd2UgZG9uJ3QgZ28gdG9vIGZhciBiYWNrXG5cdFx0Zm9yIChsZXQgaSA9IG5vZGVzLmNsYWltX2luZm8ubGFzdF9pbmRleCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRjb25zdCBub2RlID0gbm9kZXNbaV07XG5cdFx0XHRpZiAocHJlZGljYXRlKG5vZGUpKSB7XG5cdFx0XHRcdGNvbnN0IHJlcGxhY2VtZW50ID0gcHJvY2Vzc19ub2RlKG5vZGUpO1xuXHRcdFx0XHRpZiAocmVwbGFjZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdG5vZGVzLnNwbGljZShpLCAxKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRub2Rlc1tpXSA9IHJlcGxhY2VtZW50O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghZG9udF91cGRhdGVfbGFzdF9pbmRleCkge1xuXHRcdFx0XHRcdG5vZGVzLmNsYWltX2luZm8ubGFzdF9pbmRleCA9IGk7XG5cdFx0XHRcdH0gZWxzZSBpZiAocmVwbGFjZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdC8vIFNpbmNlIHdlIHNwbGljZWQgYmVmb3JlIHRoZSBsYXN0X2luZGV4LCB3ZSBkZWNyZWFzZSBpdFxuXHRcdFx0XHRcdG5vZGVzLmNsYWltX2luZm8ubGFzdF9pbmRleC0tO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBub2RlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBJZiB3ZSBjYW4ndCBmaW5kIGFueSBtYXRjaGluZyBub2RlLCB3ZSBjcmVhdGUgYSBuZXcgb25lXG5cdFx0cmV0dXJuIGNyZWF0ZV9ub2RlKCk7XG5cdH0pKCk7XG5cdHJlc3VsdF9ub2RlLmNsYWltX29yZGVyID0gbm9kZXMuY2xhaW1faW5mby50b3RhbF9jbGFpbWVkO1xuXHRub2Rlcy5jbGFpbV9pbmZvLnRvdGFsX2NsYWltZWQgKz0gMTtcblx0cmV0dXJuIHJlc3VsdF9ub2RlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Q2hpbGROb2RlQXJyYXl9IG5vZGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHt7IFtrZXk6IHN0cmluZ106IGJvb2xlYW4gfX0gYXR0cmlidXRlc1xuICogQHBhcmFtIHsobmFtZTogc3RyaW5nKSA9PiBFbGVtZW50IHwgU1ZHRWxlbWVudH0gY3JlYXRlX2VsZW1lbnRcbiAqIEByZXR1cm5zIHtFbGVtZW50IHwgU1ZHRWxlbWVudH1cbiAqL1xuZnVuY3Rpb24gY2xhaW1fZWxlbWVudF9iYXNlKG5vZGVzLCBuYW1lLCBhdHRyaWJ1dGVzLCBjcmVhdGVfZWxlbWVudCkge1xuXHRyZXR1cm4gY2xhaW1fbm9kZShcblx0XHRub2Rlcyxcblx0XHQvKiogQHJldHVybnMge25vZGUgaXMgRWxlbWVudCB8IFNWR0VsZW1lbnR9ICovXG5cdFx0KG5vZGUpID0+IG5vZGUubm9kZU5hbWUgPT09IG5hbWUsXG5cdFx0LyoqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSAqL1xuXHRcdChub2RlKSA9PiB7XG5cdFx0XHRjb25zdCByZW1vdmUgPSBbXTtcblx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgbm9kZS5hdHRyaWJ1dGVzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGNvbnN0IGF0dHJpYnV0ZSA9IG5vZGUuYXR0cmlidXRlc1tqXTtcblx0XHRcdFx0aWYgKCFhdHRyaWJ1dGVzW2F0dHJpYnV0ZS5uYW1lXSkge1xuXHRcdFx0XHRcdHJlbW92ZS5wdXNoKGF0dHJpYnV0ZS5uYW1lKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmVtb3ZlLmZvckVhY2goKHYpID0+IG5vZGUucmVtb3ZlQXR0cmlidXRlKHYpKTtcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0fSxcblx0XHQoKSA9PiBjcmVhdGVfZWxlbWVudChuYW1lKVxuXHQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Q2hpbGROb2RlQXJyYXl9IG5vZGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHt7IFtrZXk6IHN0cmluZ106IGJvb2xlYW4gfX0gYXR0cmlidXRlc1xuICogQHJldHVybnMge0VsZW1lbnQgfCBTVkdFbGVtZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xhaW1fZWxlbWVudChub2RlcywgbmFtZSwgYXR0cmlidXRlcykge1xuXHRyZXR1cm4gY2xhaW1fZWxlbWVudF9iYXNlKG5vZGVzLCBuYW1lLCBhdHRyaWJ1dGVzLCBlbGVtZW50KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NoaWxkTm9kZUFycmF5fSBub2Rlc1xuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7eyBba2V5OiBzdHJpbmddOiBib29sZWFuIH19IGF0dHJpYnV0ZXNcbiAqIEByZXR1cm5zIHtFbGVtZW50IHwgU1ZHRWxlbWVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsYWltX3N2Z19lbGVtZW50KG5vZGVzLCBuYW1lLCBhdHRyaWJ1dGVzKSB7XG5cdHJldHVybiBjbGFpbV9lbGVtZW50X2Jhc2Uobm9kZXMsIG5hbWUsIGF0dHJpYnV0ZXMsIHN2Z19lbGVtZW50KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NoaWxkTm9kZUFycmF5fSBub2Rlc1xuICogQHJldHVybnMge1RleHR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGFpbV90ZXh0KG5vZGVzLCBkYXRhKSB7XG5cdHJldHVybiBjbGFpbV9ub2RlKFxuXHRcdG5vZGVzLFxuXHRcdC8qKiBAcmV0dXJucyB7bm9kZSBpcyBUZXh0fSAqL1xuXHRcdChub2RlKSA9PiBub2RlLm5vZGVUeXBlID09PSAzLFxuXHRcdC8qKiBAcGFyYW0ge1RleHR9IG5vZGUgKi9cblx0XHQobm9kZSkgPT4ge1xuXHRcdFx0Y29uc3QgZGF0YV9zdHIgPSAnJyArIGRhdGE7XG5cdFx0XHRpZiAobm9kZS5kYXRhLnN0YXJ0c1dpdGgoZGF0YV9zdHIpKSB7XG5cdFx0XHRcdGlmIChub2RlLmRhdGEubGVuZ3RoICE9PSBkYXRhX3N0ci5sZW5ndGgpIHtcblx0XHRcdFx0XHRyZXR1cm4gbm9kZS5zcGxpdFRleHQoZGF0YV9zdHIubGVuZ3RoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bm9kZS5kYXRhID0gZGF0YV9zdHI7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQoKSA9PiB0ZXh0KGRhdGEpLFxuXHRcdHRydWUgLy8gVGV4dCBub2RlcyBzaG91bGQgbm90IHVwZGF0ZSBsYXN0IGluZGV4IHNpbmNlIGl0IGlzIGxpa2VseSBub3Qgd29ydGggaXQgdG8gZWxpbWluYXRlIGFuIGluY3JlYXNpbmcgc3Vic2VxdWVuY2Ugb2YgYWN0dWFsIGVsZW1lbnRzXG5cdCk7XG59XG5cbi8qKlxuICogQHJldHVybnMge1RleHR9ICovXG5leHBvcnQgZnVuY3Rpb24gY2xhaW1fc3BhY2Uobm9kZXMpIHtcblx0cmV0dXJuIGNsYWltX3RleHQobm9kZXMsICcgJyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtDaGlsZE5vZGVBcnJheX0gbm9kZXNcbiAqIEByZXR1cm5zIHtDb21tZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xhaW1fY29tbWVudChub2RlcywgZGF0YSkge1xuXHRyZXR1cm4gY2xhaW1fbm9kZShcblx0XHRub2Rlcyxcblx0XHQvKiogQHJldHVybnMge25vZGUgaXMgQ29tbWVudH0gKi9cblx0XHQobm9kZSkgPT4gbm9kZS5ub2RlVHlwZSA9PT0gOCxcblx0XHQvKiogQHBhcmFtIHtDb21tZW50fSBub2RlICovXG5cdFx0KG5vZGUpID0+IHtcblx0XHRcdG5vZGUuZGF0YSA9ICcnICsgZGF0YTtcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0fSxcblx0XHQoKSA9PiBjb21tZW50KGRhdGEpLFxuXHRcdHRydWVcblx0KTtcbn1cblxuZnVuY3Rpb24gZ2V0X2NvbW1lbnRfaWR4KG5vZGVzLCB0ZXh0LCBzdGFydCkge1xuXHRmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBub2Rlcy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcblx0XHRpZiAobm9kZS5ub2RlVHlwZSA9PT0gOCAvKiBjb21tZW50IG5vZGUgKi8gJiYgbm9kZS50ZXh0Q29udGVudC50cmltKCkgPT09IHRleHQpIHtcblx0XHRcdHJldHVybiBpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gLTE7XG59XG5cbi8qKlxuICogQHBhcmFtIHtib29sZWFufSBpc19zdmdcbiAqIEByZXR1cm5zIHtIdG1sVGFnSHlkcmF0aW9ufVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xhaW1faHRtbF90YWcobm9kZXMsIGlzX3N2Zykge1xuXHQvLyBmaW5kIGh0bWwgb3BlbmluZyB0YWdcblx0Y29uc3Qgc3RhcnRfaW5kZXggPSBnZXRfY29tbWVudF9pZHgobm9kZXMsICdIVE1MX1RBR19TVEFSVCcsIDApO1xuXHRjb25zdCBlbmRfaW5kZXggPSBnZXRfY29tbWVudF9pZHgobm9kZXMsICdIVE1MX1RBR19FTkQnLCBzdGFydF9pbmRleCArIDEpO1xuXHRpZiAoc3RhcnRfaW5kZXggPT09IC0xIHx8IGVuZF9pbmRleCA9PT0gLTEpIHtcblx0XHRyZXR1cm4gbmV3IEh0bWxUYWdIeWRyYXRpb24oaXNfc3ZnKTtcblx0fVxuXG5cdGluaXRfY2xhaW1faW5mbyhub2Rlcyk7XG5cdGNvbnN0IGh0bWxfdGFnX25vZGVzID0gbm9kZXMuc3BsaWNlKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDEpO1xuXHRkZXRhY2goaHRtbF90YWdfbm9kZXNbMF0pO1xuXHRkZXRhY2goaHRtbF90YWdfbm9kZXNbaHRtbF90YWdfbm9kZXMubGVuZ3RoIC0gMV0pO1xuXHRjb25zdCBjbGFpbWVkX25vZGVzID0gaHRtbF90YWdfbm9kZXMuc2xpY2UoMSwgaHRtbF90YWdfbm9kZXMubGVuZ3RoIC0gMSk7XG5cdGlmIChjbGFpbWVkX25vZGVzLmxlbmd0aCA9PT0gMCkge1xuXHRcdHJldHVybiBuZXcgSHRtbFRhZ0h5ZHJhdGlvbihpc19zdmcpO1xuXHR9XG5cdGZvciAoY29uc3QgbiBvZiBjbGFpbWVkX25vZGVzKSB7XG5cdFx0bi5jbGFpbV9vcmRlciA9IG5vZGVzLmNsYWltX2luZm8udG90YWxfY2xhaW1lZDtcblx0XHRub2Rlcy5jbGFpbV9pbmZvLnRvdGFsX2NsYWltZWQgKz0gMTtcblx0fVxuXHRyZXR1cm4gbmV3IEh0bWxUYWdIeWRyYXRpb24oaXNfc3ZnLCBjbGFpbWVkX25vZGVzKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RleHR9IHRleHRcbiAqIEBwYXJhbSB7dW5rbm93bn0gZGF0YVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfZGF0YSh0ZXh0LCBkYXRhKSB7XG5cdGRhdGEgPSAnJyArIGRhdGE7XG5cdGlmICh0ZXh0LmRhdGEgPT09IGRhdGEpIHJldHVybjtcblx0dGV4dC5kYXRhID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovIChkYXRhKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RleHR9IHRleHRcbiAqIEBwYXJhbSB7dW5rbm93bn0gZGF0YVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfZGF0YV9jb250ZW50ZWRpdGFibGUodGV4dCwgZGF0YSkge1xuXHRkYXRhID0gJycgKyBkYXRhO1xuXHRpZiAodGV4dC53aG9sZVRleHQgPT09IGRhdGEpIHJldHVybjtcblx0dGV4dC5kYXRhID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovIChkYXRhKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RleHR9IHRleHRcbiAqIEBwYXJhbSB7dW5rbm93bn0gZGF0YVxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJfdmFsdWVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2RhdGFfbWF5YmVfY29udGVudGVkaXRhYmxlKHRleHQsIGRhdGEsIGF0dHJfdmFsdWUpIHtcblx0aWYgKH5jb250ZW50ZWRpdGFibGVfdHJ1dGh5X3ZhbHVlcy5pbmRleE9mKGF0dHJfdmFsdWUpKSB7XG5cdFx0c2V0X2RhdGFfY29udGVudGVkaXRhYmxlKHRleHQsIGRhdGEpO1xuXHR9IGVsc2Uge1xuXHRcdHNldF9kYXRhKHRleHQsIGRhdGEpO1xuXHR9XG59XG5cbi8qKlxuICogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2lucHV0X3ZhbHVlKGlucHV0LCB2YWx1ZSkge1xuXHRpbnB1dC52YWx1ZSA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9pbnB1dF90eXBlKGlucHV0LCB0eXBlKSB7XG5cdHRyeSB7XG5cdFx0aW5wdXQudHlwZSA9IHR5cGU7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBkbyBub3RoaW5nXG5cdH1cbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfc3R5bGUobm9kZSwga2V5LCB2YWx1ZSwgaW1wb3J0YW50KSB7XG5cdGlmICh2YWx1ZSA9PSBudWxsKSB7XG5cdFx0bm9kZS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShrZXkpO1xuXHR9IGVsc2Uge1xuXHRcdG5vZGUuc3R5bGUuc2V0UHJvcGVydHkoa2V5LCB2YWx1ZSwgaW1wb3J0YW50ID8gJ2ltcG9ydGFudCcgOiAnJyk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZWxlY3Rfb3B0aW9uKHNlbGVjdCwgdmFsdWUsIG1vdW50aW5nKSB7XG5cdGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZWN0Lm9wdGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRjb25zdCBvcHRpb24gPSBzZWxlY3Qub3B0aW9uc1tpXTtcblx0XHRpZiAob3B0aW9uLl9fdmFsdWUgPT09IHZhbHVlKSB7XG5cdFx0XHRvcHRpb24uc2VsZWN0ZWQgPSB0cnVlO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0fVxuXHRpZiAoIW1vdW50aW5nIHx8IHZhbHVlICE9PSB1bmRlZmluZWQpIHtcblx0XHRzZWxlY3Quc2VsZWN0ZWRJbmRleCA9IC0xOyAvLyBubyBvcHRpb24gc2hvdWxkIGJlIHNlbGVjdGVkXG5cdH1cbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZWxlY3Rfb3B0aW9ucyhzZWxlY3QsIHZhbHVlKSB7XG5cdGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZWN0Lm9wdGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRjb25zdCBvcHRpb24gPSBzZWxlY3Qub3B0aW9uc1tpXTtcblx0XHRvcHRpb24uc2VsZWN0ZWQgPSB+dmFsdWUuaW5kZXhPZihvcHRpb24uX192YWx1ZSk7XG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdF92YWx1ZShzZWxlY3QpIHtcblx0Y29uc3Qgc2VsZWN0ZWRfb3B0aW9uID0gc2VsZWN0LnF1ZXJ5U2VsZWN0b3IoJzpjaGVja2VkJyk7XG5cdHJldHVybiBzZWxlY3RlZF9vcHRpb24gJiYgc2VsZWN0ZWRfb3B0aW9uLl9fdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZWxlY3RfbXVsdGlwbGVfdmFsdWUoc2VsZWN0KSB7XG5cdHJldHVybiBbXS5tYXAuY2FsbChzZWxlY3QucXVlcnlTZWxlY3RvckFsbCgnOmNoZWNrZWQnKSwgKG9wdGlvbikgPT4gb3B0aW9uLl9fdmFsdWUpO1xufVxuLy8gdW5mb3J0dW5hdGVseSB0aGlzIGNhbid0IGJlIGEgY29uc3RhbnQgYXMgdGhhdCB3b3VsZG4ndCBiZSB0cmVlLXNoYWtlYWJsZVxuLy8gc28gd2UgY2FjaGUgdGhlIHJlc3VsdCBpbnN0ZWFkXG5cbi8qKlxuICogQHR5cGUge2Jvb2xlYW59ICovXG5sZXQgY3Jvc3NvcmlnaW47XG5cbi8qKlxuICogQHJldHVybnMge2Jvb2xlYW59ICovXG5leHBvcnQgZnVuY3Rpb24gaXNfY3Jvc3NvcmlnaW4oKSB7XG5cdGlmIChjcm9zc29yaWdpbiA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0Y3Jvc3NvcmlnaW4gPSBmYWxzZTtcblx0XHR0cnkge1xuXHRcdFx0aWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wYXJlbnQpIHtcblx0XHRcdFx0dm9pZCB3aW5kb3cucGFyZW50LmRvY3VtZW50O1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjcm9zc29yaWdpbiA9IHRydWU7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBjcm9zc29yaWdpbjtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IGZuXG4gKiBAcmV0dXJucyB7KCkgPT4gdm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZF9pZnJhbWVfcmVzaXplX2xpc3RlbmVyKG5vZGUsIGZuKSB7XG5cdGNvbnN0IGNvbXB1dGVkX3N0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcblx0aWYgKGNvbXB1dGVkX3N0eWxlLnBvc2l0aW9uID09PSAnc3RhdGljJykge1xuXHRcdG5vZGUuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuXHR9XG5cdGNvbnN0IGlmcmFtZSA9IGVsZW1lbnQoJ2lmcmFtZScpO1xuXHRpZnJhbWUuc2V0QXR0cmlidXRlKFxuXHRcdCdzdHlsZScsXG5cdFx0J2Rpc3BsYXk6IGJsb2NrOyBwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogMDsgbGVmdDogMDsgd2lkdGg6IDEwMCU7IGhlaWdodDogMTAwJTsgJyArXG5cdFx0XHQnb3ZlcmZsb3c6IGhpZGRlbjsgYm9yZGVyOiAwOyBvcGFjaXR5OiAwOyBwb2ludGVyLWV2ZW50czogbm9uZTsgei1pbmRleDogLTE7J1xuXHQpO1xuXHRpZnJhbWUuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG5cdGlmcmFtZS50YWJJbmRleCA9IC0xO1xuXHRjb25zdCBjcm9zc29yaWdpbiA9IGlzX2Nyb3Nzb3JpZ2luKCk7XG5cblx0LyoqXG5cdCAqIEB0eXBlIHsoKSA9PiB2b2lkfVxuXHQgKi9cblx0bGV0IHVuc3Vic2NyaWJlO1xuXHRpZiAoY3Jvc3NvcmlnaW4pIHtcblx0XHRpZnJhbWUuc3JjID0gXCJkYXRhOnRleHQvaHRtbCw8c2NyaXB0Pm9ucmVzaXplPWZ1bmN0aW9uKCl7cGFyZW50LnBvc3RNZXNzYWdlKDAsJyonKX08L3NjcmlwdD5cIjtcblx0XHR1bnN1YnNjcmliZSA9IGxpc3Rlbihcblx0XHRcdHdpbmRvdyxcblx0XHRcdCdtZXNzYWdlJyxcblx0XHRcdC8qKiBAcGFyYW0ge01lc3NhZ2VFdmVudH0gZXZlbnQgKi8gKGV2ZW50KSA9PiB7XG5cdFx0XHRcdGlmIChldmVudC5zb3VyY2UgPT09IGlmcmFtZS5jb250ZW50V2luZG93KSBmbigpO1xuXHRcdFx0fVxuXHRcdCk7XG5cdH0gZWxzZSB7XG5cdFx0aWZyYW1lLnNyYyA9ICdhYm91dDpibGFuayc7XG5cdFx0aWZyYW1lLm9ubG9hZCA9ICgpID0+IHtcblx0XHRcdHVuc3Vic2NyaWJlID0gbGlzdGVuKGlmcmFtZS5jb250ZW50V2luZG93LCAncmVzaXplJywgZm4pO1xuXHRcdFx0Ly8gbWFrZSBzdXJlIGFuIGluaXRpYWwgcmVzaXplIGV2ZW50IGlzIGZpcmVkIF9hZnRlcl8gdGhlIGlmcmFtZSBpcyBsb2FkZWQgKHdoaWNoIGlzIGFzeW5jaHJvbm91cylcblx0XHRcdC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vc3ZlbHRlanMvc3ZlbHRlL2lzc3Vlcy80MjMzXG5cdFx0XHRmbigpO1xuXHRcdH07XG5cdH1cblx0YXBwZW5kKG5vZGUsIGlmcmFtZSk7XG5cdHJldHVybiAoKSA9PiB7XG5cdFx0aWYgKGNyb3Nzb3JpZ2luKSB7XG5cdFx0XHR1bnN1YnNjcmliZSgpO1xuXHRcdH0gZWxzZSBpZiAodW5zdWJzY3JpYmUgJiYgaWZyYW1lLmNvbnRlbnRXaW5kb3cpIHtcblx0XHRcdHVuc3Vic2NyaWJlKCk7XG5cdFx0fVxuXHRcdGRldGFjaChpZnJhbWUpO1xuXHR9O1xufVxuZXhwb3J0IGNvbnN0IHJlc2l6ZV9vYnNlcnZlcl9jb250ZW50X2JveCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgUmVzaXplT2JzZXJ2ZXJTaW5nbGV0b24oe1xuXHRib3g6ICdjb250ZW50LWJveCdcbn0pO1xuZXhwb3J0IGNvbnN0IHJlc2l6ZV9vYnNlcnZlcl9ib3JkZXJfYm94ID0gLyogQF9fUFVSRV9fICovIG5ldyBSZXNpemVPYnNlcnZlclNpbmdsZXRvbih7XG5cdGJveDogJ2JvcmRlci1ib3gnXG59KTtcbmV4cG9ydCBjb25zdCByZXNpemVfb2JzZXJ2ZXJfZGV2aWNlX3BpeGVsX2NvbnRlbnRfYm94ID0gLyogQF9fUFVSRV9fICovIG5ldyBSZXNpemVPYnNlcnZlclNpbmdsZXRvbihcblx0eyBib3g6ICdkZXZpY2UtcGl4ZWwtY29udGVudC1ib3gnIH1cbik7XG5leHBvcnQgeyBSZXNpemVPYnNlcnZlclNpbmdsZXRvbiB9O1xuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvZ2dsZV9jbGFzcyhlbGVtZW50LCBuYW1lLCB0b2dnbGUpIHtcblx0Ly8gVGhlIGAhIWAgaXMgcmVxdWlyZWQgYmVjYXVzZSBhbiBgdW5kZWZpbmVkYCBmbGFnIG1lYW5zIGZsaXBwaW5nIHRoZSBjdXJyZW50IHN0YXRlLlxuXHRlbGVtZW50LmNsYXNzTGlzdC50b2dnbGUobmFtZSwgISF0b2dnbGUpO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtUfSBbZGV0YWlsXVxuICogQHBhcmFtIHt7IGJ1YmJsZXM/OiBib29sZWFuLCBjYW5jZWxhYmxlPzogYm9vbGVhbiB9fSBbb3B0aW9uc11cbiAqIEByZXR1cm5zIHtDdXN0b21FdmVudDxUPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGN1c3RvbV9ldmVudCh0eXBlLCBkZXRhaWwsIHsgYnViYmxlcyA9IGZhbHNlLCBjYW5jZWxhYmxlID0gZmFsc2UgfSA9IHt9KSB7XG5cdHJldHVybiBuZXcgQ3VzdG9tRXZlbnQodHlwZSwgeyBkZXRhaWwsIGJ1YmJsZXMsIGNhbmNlbGFibGUgfSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRcbiAqIEByZXR1cm5zIHtDaGlsZE5vZGVBcnJheX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1ZXJ5X3NlbGVjdG9yX2FsbChzZWxlY3RvciwgcGFyZW50ID0gZG9jdW1lbnQuYm9keSkge1xuXHRyZXR1cm4gQXJyYXkuZnJvbShwYXJlbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBub2RlSWRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGhlYWRcbiAqIEByZXR1cm5zIHthbnlbXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhlYWRfc2VsZWN0b3Iobm9kZUlkLCBoZWFkKSB7XG5cdGNvbnN0IHJlc3VsdCA9IFtdO1xuXHRsZXQgc3RhcnRlZCA9IDA7XG5cdGZvciAoY29uc3Qgbm9kZSBvZiBoZWFkLmNoaWxkTm9kZXMpIHtcblx0XHRpZiAobm9kZS5ub2RlVHlwZSA9PT0gOCAvKiBjb21tZW50IG5vZGUgKi8pIHtcblx0XHRcdGNvbnN0IGNvbW1lbnQgPSBub2RlLnRleHRDb250ZW50LnRyaW0oKTtcblx0XHRcdGlmIChjb21tZW50ID09PSBgSEVBRF8ke25vZGVJZH1fRU5EYCkge1xuXHRcdFx0XHRzdGFydGVkIC09IDE7XG5cdFx0XHRcdHJlc3VsdC5wdXNoKG5vZGUpO1xuXHRcdFx0fSBlbHNlIGlmIChjb21tZW50ID09PSBgSEVBRF8ke25vZGVJZH1fU1RBUlRgKSB7XG5cdFx0XHRcdHN0YXJ0ZWQgKz0gMTtcblx0XHRcdFx0cmVzdWx0LnB1c2gobm9kZSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChzdGFydGVkID4gMCkge1xuXHRcdFx0cmVzdWx0LnB1c2gobm9kZSk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiByZXN1bHQ7XG59XG4vKiogKi9cbmV4cG9ydCBjbGFzcyBIdG1sVGFnIHtcblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBkZWZhdWx0IGZhbHNlXG5cdCAqL1xuXHRpc19zdmcgPSBmYWxzZTtcblx0LyoqIHBhcmVudCBmb3IgY3JlYXRpbmcgbm9kZSAqL1xuXHRlID0gdW5kZWZpbmVkO1xuXHQvKiogaHRtbCB0YWcgbm9kZXMgKi9cblx0biA9IHVuZGVmaW5lZDtcblx0LyoqIHRhcmdldCAqL1xuXHR0ID0gdW5kZWZpbmVkO1xuXHQvKiogYW5jaG9yICovXG5cdGEgPSB1bmRlZmluZWQ7XG5cdGNvbnN0cnVjdG9yKGlzX3N2ZyA9IGZhbHNlKSB7XG5cdFx0dGhpcy5pc19zdmcgPSBpc19zdmc7XG5cdFx0dGhpcy5lID0gdGhpcy5uID0gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdGMoaHRtbCkge1xuXHRcdHRoaXMuaChodG1sKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50IHwgU1ZHRWxlbWVudH0gdGFyZ2V0XG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50fSBhbmNob3Jcblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRtKGh0bWwsIHRhcmdldCwgYW5jaG9yID0gbnVsbCkge1xuXHRcdGlmICghdGhpcy5lKSB7XG5cdFx0XHRpZiAodGhpcy5pc19zdmcpXG5cdFx0XHRcdHRoaXMuZSA9IHN2Z19lbGVtZW50KC8qKiBAdHlwZSB7a2V5b2YgU1ZHRWxlbWVudFRhZ05hbWVNYXB9ICovICh0YXJnZXQubm9kZU5hbWUpKTtcblx0XHRcdC8qKiAjNzM2NCAgdGFyZ2V0IGZvciA8dGVtcGxhdGU+IG1heSBiZSBwcm92aWRlZCBhcyAjZG9jdW1lbnQtZnJhZ21lbnQoMTEpICovIGVsc2Vcblx0XHRcdFx0dGhpcy5lID0gZWxlbWVudChcblx0XHRcdFx0XHQvKiogQHR5cGUge2tleW9mIEhUTUxFbGVtZW50VGFnTmFtZU1hcH0gKi8gKFxuXHRcdFx0XHRcdFx0dGFyZ2V0Lm5vZGVUeXBlID09PSAxMSA/ICdURU1QTEFURScgOiB0YXJnZXQubm9kZU5hbWVcblx0XHRcdFx0XHQpXG5cdFx0XHRcdCk7XG5cdFx0XHR0aGlzLnQgPVxuXHRcdFx0XHR0YXJnZXQudGFnTmFtZSAhPT0gJ1RFTVBMQVRFJ1xuXHRcdFx0XHRcdD8gdGFyZ2V0XG5cdFx0XHRcdFx0OiAvKiogQHR5cGUge0hUTUxUZW1wbGF0ZUVsZW1lbnR9ICovICh0YXJnZXQpLmNvbnRlbnQ7XG5cdFx0XHR0aGlzLmMoaHRtbCk7XG5cdFx0fVxuXHRcdHRoaXMuaShhbmNob3IpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0aChodG1sKSB7XG5cdFx0dGhpcy5lLmlubmVySFRNTCA9IGh0bWw7XG5cdFx0dGhpcy5uID0gQXJyYXkuZnJvbShcblx0XHRcdHRoaXMuZS5ub2RlTmFtZSA9PT0gJ1RFTVBMQVRFJyA/IHRoaXMuZS5jb250ZW50LmNoaWxkTm9kZXMgOiB0aGlzLmUuY2hpbGROb2Rlc1xuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge3ZvaWR9ICovXG5cdGkoYW5jaG9yKSB7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm4ubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRcdGluc2VydCh0aGlzLnQsIHRoaXMubltpXSwgYW5jaG9yKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRwKGh0bWwpIHtcblx0XHR0aGlzLmQoKTtcblx0XHR0aGlzLmgoaHRtbCk7XG5cdFx0dGhpcy5pKHRoaXMuYSk7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge3ZvaWR9ICovXG5cdGQoKSB7XG5cdFx0dGhpcy5uLmZvckVhY2goZGV0YWNoKTtcblx0fVxufVxuXG5leHBvcnQgY2xhc3MgSHRtbFRhZ0h5ZHJhdGlvbiBleHRlbmRzIEh0bWxUYWcge1xuXHQvKiogQHR5cGUge0VsZW1lbnRbXX0gaHlkcmF0aW9uIGNsYWltZWQgbm9kZXMgKi9cblx0bCA9IHVuZGVmaW5lZDtcblxuXHRjb25zdHJ1Y3Rvcihpc19zdmcgPSBmYWxzZSwgY2xhaW1lZF9ub2Rlcykge1xuXHRcdHN1cGVyKGlzX3N2Zyk7XG5cdFx0dGhpcy5lID0gdGhpcy5uID0gbnVsbDtcblx0XHR0aGlzLmwgPSBjbGFpbWVkX25vZGVzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0YyhodG1sKSB7XG5cdFx0aWYgKHRoaXMubCkge1xuXHRcdFx0dGhpcy5uID0gdGhpcy5sO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdXBlci5jKGh0bWwpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7dm9pZH0gKi9cblx0aShhbmNob3IpIHtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubi5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdFx0aW5zZXJ0X2h5ZHJhdGlvbih0aGlzLnQsIHRoaXMubltpXSwgYW5jaG9yKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge05hbWVkTm9kZU1hcH0gYXR0cmlidXRlc1xuICogQHJldHVybnMge3t9fVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXR0cmlidXRlX3RvX29iamVjdChhdHRyaWJ1dGVzKSB7XG5cdGNvbnN0IHJlc3VsdCA9IHt9O1xuXHRmb3IgKGNvbnN0IGF0dHJpYnV0ZSBvZiBhdHRyaWJ1dGVzKSB7XG5cdFx0cmVzdWx0W2F0dHJpYnV0ZS5uYW1lXSA9IGF0dHJpYnV0ZS52YWx1ZTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG5jb25zdCBlc2NhcGVkID0ge1xuXHQnXCInOiAnJnF1b3Q7Jyxcblx0JyYnOiAnJmFtcDsnLFxuXHQnPCc6ICcmbHQ7J1xufTtcblxuY29uc3QgcmVnZXhfYXR0cmlidXRlX2NoYXJhY3RlcnNfdG9fZXNjYXBlID0gL1tcIiY8XS9nO1xuXG4vKipcbiAqIE5vdGUgdGhhdCB0aGUgYXR0cmlidXRlIGl0c2VsZiBzaG91bGQgYmUgc3Vycm91bmRlZCBpbiBkb3VibGUgcXVvdGVzXG4gKiBAcGFyYW0ge2FueX0gYXR0cmlidXRlXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZV9hdHRyaWJ1dGUoYXR0cmlidXRlKSB7XG5cdHJldHVybiBTdHJpbmcoYXR0cmlidXRlKS5yZXBsYWNlKHJlZ2V4X2F0dHJpYnV0ZV9jaGFyYWN0ZXJzX3RvX2VzY2FwZSwgKG1hdGNoKSA9PiBlc2NhcGVkW21hdGNoXSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fSBhdHRyaWJ1dGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnlfc3ByZWFkKGF0dHJpYnV0ZXMpIHtcblx0bGV0IHN0ciA9ICcgJztcblx0Zm9yIChjb25zdCBrZXkgaW4gYXR0cmlidXRlcykge1xuXHRcdGlmIChhdHRyaWJ1dGVzW2tleV0gIT0gbnVsbCkge1xuXHRcdFx0c3RyICs9IGAke2tleX09XCIke2VzY2FwZV9hdHRyaWJ1dGUoYXR0cmlidXRlc1trZXldKX1cIiBgO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBzdHI7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge3t9fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0X2N1c3RvbV9lbGVtZW50c19zbG90cyhlbGVtZW50KSB7XG5cdGNvbnN0IHJlc3VsdCA9IHt9O1xuXHRlbGVtZW50LmNoaWxkTm9kZXMuZm9yRWFjaChcblx0XHQvKiogQHBhcmFtIHtFbGVtZW50fSBub2RlICovIChub2RlKSA9PiB7XG5cdFx0XHRyZXN1bHRbbm9kZS5zbG90IHx8ICdkZWZhdWx0J10gPSB0cnVlO1xuXHRcdH1cblx0KTtcblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnN0cnVjdF9zdmVsdGVfY29tcG9uZW50KGNvbXBvbmVudCwgcHJvcHMpIHtcblx0cmV0dXJuIG5ldyBjb21wb25lbnQocHJvcHMpO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtOb2RlICYge1xuICogXHRjbGFpbV9vcmRlcj86IG51bWJlcjtcbiAqIFx0aHlkcmF0ZV9pbml0PzogdHJ1ZTtcbiAqIFx0YWN0dWFsX2VuZF9jaGlsZD86IE5vZGVFeDtcbiAqIFx0Y2hpbGROb2RlczogTm9kZUxpc3RPZjxOb2RlRXg+O1xuICogfX0gTm9kZUV4XG4gKi9cblxuLyoqIEB0eXBlZGVmIHtDaGlsZE5vZGUgJiBOb2RlRXh9IENoaWxkTm9kZUV4ICovXG5cbi8qKiBAdHlwZWRlZiB7Tm9kZUV4ICYgeyBjbGFpbV9vcmRlcjogbnVtYmVyIH19IE5vZGVFeDIgKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7Q2hpbGROb2RlRXhbXSAmIHtcbiAqIFx0Y2xhaW1faW5mbz86IHtcbiAqIFx0XHRsYXN0X2luZGV4OiBudW1iZXI7XG4gKiBcdFx0dG90YWxfY2xhaW1lZDogbnVtYmVyO1xuICogXHR9O1xuICogfX0gQ2hpbGROb2RlQXJyYXlcbiAqL1xuIiwgImltcG9ydCB7IGN1c3RvbV9ldmVudCB9IGZyb20gJy4vZG9tLmpzJztcblxuZXhwb3J0IGxldCBjdXJyZW50X2NvbXBvbmVudDtcblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9jdXJyZW50X2NvbXBvbmVudChjb21wb25lbnQpIHtcblx0Y3VycmVudF9jb21wb25lbnQgPSBjb21wb25lbnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRfY3VycmVudF9jb21wb25lbnQoKSB7XG5cdGlmICghY3VycmVudF9jb21wb25lbnQpIHRocm93IG5ldyBFcnJvcignRnVuY3Rpb24gY2FsbGVkIG91dHNpZGUgY29tcG9uZW50IGluaXRpYWxpemF0aW9uJyk7XG5cdHJldHVybiBjdXJyZW50X2NvbXBvbmVudDtcbn1cblxuLyoqXG4gKiBTY2hlZHVsZXMgYSBjYWxsYmFjayB0byBydW4gaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgdXBkYXRlZCBhZnRlciBhbnkgc3RhdGUgY2hhbmdlLlxuICpcbiAqIFRoZSBmaXJzdCB0aW1lIHRoZSBjYWxsYmFjayBydW5zIHdpbGwgYmUgYmVmb3JlIHRoZSBpbml0aWFsIGBvbk1vdW50YFxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZSNiZWZvcmV1cGRhdGVcbiAqIEBwYXJhbSB7KCkgPT4gYW55fSBmblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiZWZvcmVVcGRhdGUoZm4pIHtcblx0Z2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuYmVmb3JlX3VwZGF0ZS5wdXNoKGZuKTtcbn1cblxuLyoqXG4gKiBUaGUgYG9uTW91bnRgIGZ1bmN0aW9uIHNjaGVkdWxlcyBhIGNhbGxiYWNrIHRvIHJ1biBhcyBzb29uIGFzIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZCB0byB0aGUgRE9NLlxuICogSXQgbXVzdCBiZSBjYWxsZWQgZHVyaW5nIHRoZSBjb21wb25lbnQncyBpbml0aWFsaXNhdGlvbiAoYnV0IGRvZXNuJ3QgbmVlZCB0byBsaXZlICppbnNpZGUqIHRoZSBjb21wb25lbnQ7XG4gKiBpdCBjYW4gYmUgY2FsbGVkIGZyb20gYW4gZXh0ZXJuYWwgbW9kdWxlKS5cbiAqXG4gKiBJZiBhIGZ1bmN0aW9uIGlzIHJldHVybmVkIF9zeW5jaHJvbm91c2x5XyBmcm9tIGBvbk1vdW50YCwgaXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIHVubW91bnRlZC5cbiAqXG4gKiBgb25Nb3VudGAgZG9lcyBub3QgcnVuIGluc2lkZSBhIFtzZXJ2ZXItc2lkZSBjb21wb25lbnRdKGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzI3J1bi10aW1lLXNlcnZlci1zaWRlLWNvbXBvbmVudC1hcGkpLlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZSNvbm1vdW50XG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHsoKSA9PiBpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLk5vdEZ1bmN0aW9uPFQ+IHwgUHJvbWlzZTxpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLk5vdEZ1bmN0aW9uPFQ+PiB8ICgoKSA9PiBhbnkpfSBmblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvbk1vdW50KGZuKSB7XG5cdGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLm9uX21vdW50LnB1c2goZm4pO1xufVxuXG4vKipcbiAqIFNjaGVkdWxlcyBhIGNhbGxiYWNrIHRvIHJ1biBpbW1lZGlhdGVseSBhZnRlciB0aGUgY29tcG9uZW50IGhhcyBiZWVuIHVwZGF0ZWQuXG4gKlxuICogVGhlIGZpcnN0IHRpbWUgdGhlIGNhbGxiYWNrIHJ1bnMgd2lsbCBiZSBhZnRlciB0aGUgaW5pdGlhbCBgb25Nb3VudGBcbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUjYWZ0ZXJ1cGRhdGVcbiAqIEBwYXJhbSB7KCkgPT4gYW55fSBmblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZnRlclVwZGF0ZShmbikge1xuXHRnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5hZnRlcl91cGRhdGUucHVzaChmbik7XG59XG5cbi8qKlxuICogU2NoZWR1bGVzIGEgY2FsbGJhY2sgdG8gcnVuIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIHVubW91bnRlZC5cbiAqXG4gKiBPdXQgb2YgYG9uTW91bnRgLCBgYmVmb3JlVXBkYXRlYCwgYGFmdGVyVXBkYXRlYCBhbmQgYG9uRGVzdHJveWAsIHRoaXMgaXMgdGhlXG4gKiBvbmx5IG9uZSB0aGF0IHJ1bnMgaW5zaWRlIGEgc2VydmVyLXNpZGUgY29tcG9uZW50LlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZSNvbmRlc3Ryb3lcbiAqIEBwYXJhbSB7KCkgPT4gYW55fSBmblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvbkRlc3Ryb3koZm4pIHtcblx0Z2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQub25fZGVzdHJveS5wdXNoKGZuKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGV2ZW50IGRpc3BhdGNoZXIgdGhhdCBjYW4gYmUgdXNlZCB0byBkaXNwYXRjaCBbY29tcG9uZW50IGV2ZW50c10oaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3MjdGVtcGxhdGUtc3ludGF4LWNvbXBvbmVudC1kaXJlY3RpdmVzLW9uLWV2ZW50bmFtZSkuXG4gKiBFdmVudCBkaXNwYXRjaGVycyBhcmUgZnVuY3Rpb25zIHRoYXQgY2FuIHRha2UgdHdvIGFyZ3VtZW50czogYG5hbWVgIGFuZCBgZGV0YWlsYC5cbiAqXG4gKiBDb21wb25lbnQgZXZlbnRzIGNyZWF0ZWQgd2l0aCBgY3JlYXRlRXZlbnREaXNwYXRjaGVyYCBjcmVhdGUgYVxuICogW0N1c3RvbUV2ZW50XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3VzdG9tRXZlbnQpLlxuICogVGhlc2UgZXZlbnRzIGRvIG5vdCBbYnViYmxlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0xlYXJuL0phdmFTY3JpcHQvQnVpbGRpbmdfYmxvY2tzL0V2ZW50cyNFdmVudF9idWJibGluZ19hbmRfY2FwdHVyZSkuXG4gKiBUaGUgYGRldGFpbGAgYXJndW1lbnQgY29ycmVzcG9uZHMgdG8gdGhlIFtDdXN0b21FdmVudC5kZXRhaWxdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DdXN0b21FdmVudC9kZXRhaWwpXG4gKiBwcm9wZXJ0eSBhbmQgY2FuIGNvbnRhaW4gYW55IHR5cGUgb2YgZGF0YS5cbiAqXG4gKiBUaGUgZXZlbnQgZGlzcGF0Y2hlciBjYW4gYmUgdHlwZWQgdG8gbmFycm93IHRoZSBhbGxvd2VkIGV2ZW50IG5hbWVzIGFuZCB0aGUgdHlwZSBvZiB0aGUgYGRldGFpbGAgYXJndW1lbnQ6XG4gKiBgYGB0c1xuICogY29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXI8e1xuICogIGxvYWRlZDogbmV2ZXI7IC8vIGRvZXMgbm90IHRha2UgYSBkZXRhaWwgYXJndW1lbnRcbiAqICBjaGFuZ2U6IHN0cmluZzsgLy8gdGFrZXMgYSBkZXRhaWwgYXJndW1lbnQgb2YgdHlwZSBzdHJpbmcsIHdoaWNoIGlzIHJlcXVpcmVkXG4gKiAgb3B0aW9uYWw6IG51bWJlciB8IG51bGw7IC8vIHRha2VzIGFuIG9wdGlvbmFsIGRldGFpbCBhcmd1bWVudCBvZiB0eXBlIG51bWJlclxuICogfT4oKTtcbiAqIGBgYFxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZSNjcmVhdGVldmVudGRpc3BhdGNoZXJcbiAqIEB0ZW1wbGF0ZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gW0V2ZW50TWFwPWFueV1cbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vcHVibGljLmpzJykuRXZlbnREaXNwYXRjaGVyPEV2ZW50TWFwPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpIHtcblx0Y29uc3QgY29tcG9uZW50ID0gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCk7XG5cdHJldHVybiAodHlwZSwgZGV0YWlsLCB7IGNhbmNlbGFibGUgPSBmYWxzZSB9ID0ge30pID0+IHtcblx0XHRjb25zdCBjYWxsYmFja3MgPSBjb21wb25lbnQuJCQuY2FsbGJhY2tzW3R5cGVdO1xuXHRcdGlmIChjYWxsYmFja3MpIHtcblx0XHRcdC8vIFRPRE8gYXJlIHRoZXJlIHNpdHVhdGlvbnMgd2hlcmUgZXZlbnRzIGNvdWxkIGJlIGRpc3BhdGNoZWRcblx0XHRcdC8vIGluIGEgc2VydmVyIChub24tRE9NKSBlbnZpcm9ubWVudD9cblx0XHRcdGNvbnN0IGV2ZW50ID0gY3VzdG9tX2V2ZW50KC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAodHlwZSksIGRldGFpbCwgeyBjYW5jZWxhYmxlIH0pO1xuXHRcdFx0Y2FsbGJhY2tzLnNsaWNlKCkuZm9yRWFjaCgoZm4pID0+IHtcblx0XHRcdFx0Zm4uY2FsbChjb21wb25lbnQsIGV2ZW50KTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuICFldmVudC5kZWZhdWx0UHJldmVudGVkO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcbn1cblxuLyoqXG4gKiBBc3NvY2lhdGVzIGFuIGFyYml0cmFyeSBgY29udGV4dGAgb2JqZWN0IHdpdGggdGhlIGN1cnJlbnQgY29tcG9uZW50IGFuZCB0aGUgc3BlY2lmaWVkIGBrZXlgXG4gKiBhbmQgcmV0dXJucyB0aGF0IG9iamVjdC4gVGhlIGNvbnRleHQgaXMgdGhlbiBhdmFpbGFibGUgdG8gY2hpbGRyZW4gb2YgdGhlIGNvbXBvbmVudFxuICogKGluY2x1ZGluZyBzbG90dGVkIGNvbnRlbnQpIHdpdGggYGdldENvbnRleHRgLlxuICpcbiAqIExpa2UgbGlmZWN5Y2xlIGZ1bmN0aW9ucywgdGhpcyBtdXN0IGJlIGNhbGxlZCBkdXJpbmcgY29tcG9uZW50IGluaXRpYWxpc2F0aW9uLlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZSNzZXRjb250ZXh0XG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHthbnl9IGtleVxuICogQHBhcmFtIHtUfSBjb250ZXh0XG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldENvbnRleHQoa2V5LCBjb250ZXh0KSB7XG5cdGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmNvbnRleHQuc2V0KGtleSwgY29udGV4dCk7XG5cdHJldHVybiBjb250ZXh0O1xufVxuXG4vKipcbiAqIFJldHJpZXZlcyB0aGUgY29udGV4dCB0aGF0IGJlbG9uZ3MgdG8gdGhlIGNsb3Nlc3QgcGFyZW50IGNvbXBvbmVudCB3aXRoIHRoZSBzcGVjaWZpZWQgYGtleWAuXG4gKiBNdXN0IGJlIGNhbGxlZCBkdXJpbmcgY29tcG9uZW50IGluaXRpYWxpc2F0aW9uLlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZSNnZXRjb250ZXh0XG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHthbnl9IGtleVxuICogQHJldHVybnMge1R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb250ZXh0KGtleSkge1xuXHRyZXR1cm4gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuY29udGV4dC5nZXQoa2V5KTtcbn1cblxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIHdob2xlIGNvbnRleHQgbWFwIHRoYXQgYmVsb25ncyB0byB0aGUgY2xvc2VzdCBwYXJlbnQgY29tcG9uZW50LlxuICogTXVzdCBiZSBjYWxsZWQgZHVyaW5nIGNvbXBvbmVudCBpbml0aWFsaXNhdGlvbi4gVXNlZnVsLCBmb3IgZXhhbXBsZSwgaWYgeW91XG4gKiBwcm9ncmFtbWF0aWNhbGx5IGNyZWF0ZSBhIGNvbXBvbmVudCBhbmQgd2FudCB0byBwYXNzIHRoZSBleGlzdGluZyBjb250ZXh0IHRvIGl0LlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZSNnZXRhbGxjb250ZXh0c1xuICogQHRlbXBsYXRlIHtNYXA8YW55LCBhbnk+fSBbVD1NYXA8YW55LCBhbnk+XVxuICogQHJldHVybnMge1R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBbGxDb250ZXh0cygpIHtcblx0cmV0dXJuIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmNvbnRleHQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYSBnaXZlbiBga2V5YCBoYXMgYmVlbiBzZXQgaW4gdGhlIGNvbnRleHQgb2YgYSBwYXJlbnQgY29tcG9uZW50LlxuICogTXVzdCBiZSBjYWxsZWQgZHVyaW5nIGNvbXBvbmVudCBpbml0aWFsaXNhdGlvbi5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUjaGFzY29udGV4dFxuICogQHBhcmFtIHthbnl9IGtleVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNDb250ZXh0KGtleSkge1xuXHRyZXR1cm4gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuY29udGV4dC5oYXMoa2V5KTtcbn1cblxuLy8gVE9ETyBmaWd1cmUgb3V0IGlmIHdlIHN0aWxsIHdhbnQgdG8gc3VwcG9ydFxuLy8gc2hvcnRoYW5kIGV2ZW50cywgb3IgaWYgd2Ugd2FudCB0byBpbXBsZW1lbnRcbi8vIGEgcmVhbCBidWJibGluZyBtZWNoYW5pc21cbi8qKlxuICogQHBhcmFtIGNvbXBvbmVudFxuICogQHBhcmFtIGV2ZW50XG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1YmJsZShjb21wb25lbnQsIGV2ZW50KSB7XG5cdGNvbnN0IGNhbGxiYWNrcyA9IGNvbXBvbmVudC4kJC5jYWxsYmFja3NbZXZlbnQudHlwZV07XG5cdGlmIChjYWxsYmFja3MpIHtcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0Y2FsbGJhY2tzLnNsaWNlKCkuZm9yRWFjaCgoZm4pID0+IGZuLmNhbGwodGhpcywgZXZlbnQpKTtcblx0fVxufVxuIiwgImltcG9ydCB7IHJ1bl9hbGwgfSBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7IGN1cnJlbnRfY29tcG9uZW50LCBzZXRfY3VycmVudF9jb21wb25lbnQgfSBmcm9tICcuL2xpZmVjeWNsZS5qcyc7XG5cbmV4cG9ydCBjb25zdCBkaXJ0eV9jb21wb25lbnRzID0gW107XG5leHBvcnQgY29uc3QgaW50cm9zID0geyBlbmFibGVkOiBmYWxzZSB9O1xuZXhwb3J0IGNvbnN0IGJpbmRpbmdfY2FsbGJhY2tzID0gW107XG5cbmxldCByZW5kZXJfY2FsbGJhY2tzID0gW107XG5cbmNvbnN0IGZsdXNoX2NhbGxiYWNrcyA9IFtdO1xuXG5jb25zdCByZXNvbHZlZF9wcm9taXNlID0gLyogQF9fUFVSRV9fICovIFByb21pc2UucmVzb2x2ZSgpO1xuXG5sZXQgdXBkYXRlX3NjaGVkdWxlZCA9IGZhbHNlO1xuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gc2NoZWR1bGVfdXBkYXRlKCkge1xuXHRpZiAoIXVwZGF0ZV9zY2hlZHVsZWQpIHtcblx0XHR1cGRhdGVfc2NoZWR1bGVkID0gdHJ1ZTtcblx0XHRyZXNvbHZlZF9wcm9taXNlLnRoZW4oZmx1c2gpO1xuXHR9XG59XG5cbi8qKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gKi9cbmV4cG9ydCBmdW5jdGlvbiB0aWNrKCkge1xuXHRzY2hlZHVsZV91cGRhdGUoKTtcblx0cmV0dXJuIHJlc29sdmVkX3Byb21pc2U7XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRfcmVuZGVyX2NhbGxiYWNrKGZuKSB7XG5cdHJlbmRlcl9jYWxsYmFja3MucHVzaChmbik7XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRfZmx1c2hfY2FsbGJhY2soZm4pIHtcblx0Zmx1c2hfY2FsbGJhY2tzLnB1c2goZm4pO1xufVxuXG4vLyBmbHVzaCgpIGNhbGxzIGNhbGxiYWNrcyBpbiB0aGlzIG9yZGVyOlxuLy8gMS4gQWxsIGJlZm9yZVVwZGF0ZSBjYWxsYmFja3MsIGluIG9yZGVyOiBwYXJlbnRzIGJlZm9yZSBjaGlsZHJlblxuLy8gMi4gQWxsIGJpbmQ6dGhpcyBjYWxsYmFja3MsIGluIHJldmVyc2Ugb3JkZXI6IGNoaWxkcmVuIGJlZm9yZSBwYXJlbnRzLlxuLy8gMy4gQWxsIGFmdGVyVXBkYXRlIGNhbGxiYWNrcywgaW4gb3JkZXI6IHBhcmVudHMgYmVmb3JlIGNoaWxkcmVuLiBFWENFUFRcbi8vICAgIGZvciBhZnRlclVwZGF0ZXMgY2FsbGVkIGR1cmluZyB0aGUgaW5pdGlhbCBvbk1vdW50LCB3aGljaCBhcmUgY2FsbGVkIGluXG4vLyAgICByZXZlcnNlIG9yZGVyOiBjaGlsZHJlbiBiZWZvcmUgcGFyZW50cy5cbi8vIFNpbmNlIGNhbGxiYWNrcyBtaWdodCB1cGRhdGUgY29tcG9uZW50IHZhbHVlcywgd2hpY2ggY291bGQgdHJpZ2dlciBhbm90aGVyXG4vLyBjYWxsIHRvIGZsdXNoKCksIHRoZSBmb2xsb3dpbmcgc3RlcHMgZ3VhcmQgYWdhaW5zdCB0aGlzOlxuLy8gMS4gRHVyaW5nIGJlZm9yZVVwZGF0ZSwgYW55IHVwZGF0ZWQgY29tcG9uZW50cyB3aWxsIGJlIGFkZGVkIHRvIHRoZVxuLy8gICAgZGlydHlfY29tcG9uZW50cyBhcnJheSBhbmQgd2lsbCBjYXVzZSBhIHJlZW50cmFudCBjYWxsIHRvIGZsdXNoKCkuIEJlY2F1c2Vcbi8vICAgIHRoZSBmbHVzaCBpbmRleCBpcyBrZXB0IG91dHNpZGUgdGhlIGZ1bmN0aW9uLCB0aGUgcmVlbnRyYW50IGNhbGwgd2lsbCBwaWNrXG4vLyAgICB1cCB3aGVyZSB0aGUgZWFybGllciBjYWxsIGxlZnQgb2ZmIGFuZCBnbyB0aHJvdWdoIGFsbCBkaXJ0eSBjb21wb25lbnRzLiBUaGVcbi8vICAgIGN1cnJlbnRfY29tcG9uZW50IHZhbHVlIGlzIHNhdmVkIGFuZCByZXN0b3JlZCBzbyB0aGF0IHRoZSByZWVudHJhbnQgY2FsbCB3aWxsXG4vLyAgICBub3QgaW50ZXJmZXJlIHdpdGggdGhlIFwicGFyZW50XCIgZmx1c2goKSBjYWxsLlxuLy8gMi4gYmluZDp0aGlzIGNhbGxiYWNrcyBjYW5ub3QgdHJpZ2dlciBuZXcgZmx1c2goKSBjYWxscy5cbi8vIDMuIER1cmluZyBhZnRlclVwZGF0ZSwgYW55IHVwZGF0ZWQgY29tcG9uZW50cyB3aWxsIE5PVCBoYXZlIHRoZWlyIGFmdGVyVXBkYXRlXG4vLyAgICBjYWxsYmFjayBjYWxsZWQgYSBzZWNvbmQgdGltZTsgdGhlIHNlZW5fY2FsbGJhY2tzIHNldCwgb3V0c2lkZSB0aGUgZmx1c2goKVxuLy8gICAgZnVuY3Rpb24sIGd1YXJhbnRlZXMgdGhpcyBiZWhhdmlvci5cbmNvbnN0IHNlZW5fY2FsbGJhY2tzID0gbmV3IFNldCgpO1xuXG5sZXQgZmx1c2hpZHggPSAwOyAvLyBEbyAqbm90KiBtb3ZlIHRoaXMgaW5zaWRlIHRoZSBmbHVzaCgpIGZ1bmN0aW9uXG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBmbHVzaCgpIHtcblx0Ly8gRG8gbm90IHJlZW50ZXIgZmx1c2ggd2hpbGUgZGlydHkgY29tcG9uZW50cyBhcmUgdXBkYXRlZCwgYXMgdGhpcyBjYW5cblx0Ly8gcmVzdWx0IGluIGFuIGluZmluaXRlIGxvb3AuIEluc3RlYWQsIGxldCB0aGUgaW5uZXIgZmx1c2ggaGFuZGxlIGl0LlxuXHQvLyBSZWVudHJhbmN5IGlzIG9rIGFmdGVyd2FyZHMgZm9yIGJpbmRpbmdzIGV0Yy5cblx0aWYgKGZsdXNoaWR4ICE9PSAwKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdGNvbnN0IHNhdmVkX2NvbXBvbmVudCA9IGN1cnJlbnRfY29tcG9uZW50O1xuXHRkbyB7XG5cdFx0Ly8gZmlyc3QsIGNhbGwgYmVmb3JlVXBkYXRlIGZ1bmN0aW9uc1xuXHRcdC8vIGFuZCB1cGRhdGUgY29tcG9uZW50c1xuXHRcdHRyeSB7XG5cdFx0XHR3aGlsZSAoZmx1c2hpZHggPCBkaXJ0eV9jb21wb25lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRjb25zdCBjb21wb25lbnQgPSBkaXJ0eV9jb21wb25lbnRzW2ZsdXNoaWR4XTtcblx0XHRcdFx0Zmx1c2hpZHgrKztcblx0XHRcdFx0c2V0X2N1cnJlbnRfY29tcG9uZW50KGNvbXBvbmVudCk7XG5cdFx0XHRcdHVwZGF0ZShjb21wb25lbnQuJCQpO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdC8vIHJlc2V0IGRpcnR5IHN0YXRlIHRvIG5vdCBlbmQgdXAgaW4gYSBkZWFkbG9ja2VkIHN0YXRlIGFuZCB0aGVuIHJldGhyb3dcblx0XHRcdGRpcnR5X2NvbXBvbmVudHMubGVuZ3RoID0gMDtcblx0XHRcdGZsdXNoaWR4ID0gMDtcblx0XHRcdHRocm93IGU7XG5cdFx0fVxuXHRcdHNldF9jdXJyZW50X2NvbXBvbmVudChudWxsKTtcblx0XHRkaXJ0eV9jb21wb25lbnRzLmxlbmd0aCA9IDA7XG5cdFx0Zmx1c2hpZHggPSAwO1xuXHRcdHdoaWxlIChiaW5kaW5nX2NhbGxiYWNrcy5sZW5ndGgpIGJpbmRpbmdfY2FsbGJhY2tzLnBvcCgpKCk7XG5cdFx0Ly8gdGhlbiwgb25jZSBjb21wb25lbnRzIGFyZSB1cGRhdGVkLCBjYWxsXG5cdFx0Ly8gYWZ0ZXJVcGRhdGUgZnVuY3Rpb25zLiBUaGlzIG1heSBjYXVzZVxuXHRcdC8vIHN1YnNlcXVlbnQgdXBkYXRlcy4uLlxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcmVuZGVyX2NhbGxiYWNrcy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdFx0Y29uc3QgY2FsbGJhY2sgPSByZW5kZXJfY2FsbGJhY2tzW2ldO1xuXHRcdFx0aWYgKCFzZWVuX2NhbGxiYWNrcy5oYXMoY2FsbGJhY2spKSB7XG5cdFx0XHRcdC8vIC4uLnNvIGd1YXJkIGFnYWluc3QgaW5maW5pdGUgbG9vcHNcblx0XHRcdFx0c2Vlbl9jYWxsYmFja3MuYWRkKGNhbGxiYWNrKTtcblx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmVuZGVyX2NhbGxiYWNrcy5sZW5ndGggPSAwO1xuXHR9IHdoaWxlIChkaXJ0eV9jb21wb25lbnRzLmxlbmd0aCk7XG5cdHdoaWxlIChmbHVzaF9jYWxsYmFja3MubGVuZ3RoKSB7XG5cdFx0Zmx1c2hfY2FsbGJhY2tzLnBvcCgpKCk7XG5cdH1cblx0dXBkYXRlX3NjaGVkdWxlZCA9IGZhbHNlO1xuXHRzZWVuX2NhbGxiYWNrcy5jbGVhcigpO1xuXHRzZXRfY3VycmVudF9jb21wb25lbnQoc2F2ZWRfY29tcG9uZW50KTtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZnVuY3Rpb24gdXBkYXRlKCQkKSB7XG5cdGlmICgkJC5mcmFnbWVudCAhPT0gbnVsbCkge1xuXHRcdCQkLnVwZGF0ZSgpO1xuXHRcdHJ1bl9hbGwoJCQuYmVmb3JlX3VwZGF0ZSk7XG5cdFx0Y29uc3QgZGlydHkgPSAkJC5kaXJ0eTtcblx0XHQkJC5kaXJ0eSA9IFstMV07XG5cdFx0JCQuZnJhZ21lbnQgJiYgJCQuZnJhZ21lbnQucCgkJC5jdHgsIGRpcnR5KTtcblx0XHQkJC5hZnRlcl91cGRhdGUuZm9yRWFjaChhZGRfcmVuZGVyX2NhbGxiYWNrKTtcblx0fVxufVxuXG4vKipcbiAqIFVzZWZ1bCBmb3IgZXhhbXBsZSB0byBleGVjdXRlIHJlbWFpbmluZyBgYWZ0ZXJVcGRhdGVgIGNhbGxiYWNrcyBiZWZvcmUgZXhlY3V0aW5nIGBkZXN0cm95YC5cbiAqIEBwYXJhbSB7RnVuY3Rpb25bXX0gZm5zXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZsdXNoX3JlbmRlcl9jYWxsYmFja3MoZm5zKSB7XG5cdGNvbnN0IGZpbHRlcmVkID0gW107XG5cdGNvbnN0IHRhcmdldHMgPSBbXTtcblx0cmVuZGVyX2NhbGxiYWNrcy5mb3JFYWNoKChjKSA9PiAoZm5zLmluZGV4T2YoYykgPT09IC0xID8gZmlsdGVyZWQucHVzaChjKSA6IHRhcmdldHMucHVzaChjKSkpO1xuXHR0YXJnZXRzLmZvckVhY2goKGMpID0+IGMoKSk7XG5cdHJlbmRlcl9jYWxsYmFja3MgPSBmaWx0ZXJlZDtcbn1cbiIsICJpbXBvcnQgeyBpZGVudGl0eSBhcyBsaW5lYXIsIGlzX2Z1bmN0aW9uLCBub29wLCBydW5fYWxsIH0gZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyBub3cgfSBmcm9tICcuL2Vudmlyb25tZW50LmpzJztcbmltcG9ydCB7IGxvb3AgfSBmcm9tICcuL2xvb3AuanMnO1xuaW1wb3J0IHsgY3JlYXRlX3J1bGUsIGRlbGV0ZV9ydWxlIH0gZnJvbSAnLi9zdHlsZV9tYW5hZ2VyLmpzJztcbmltcG9ydCB7IGN1c3RvbV9ldmVudCB9IGZyb20gJy4vZG9tLmpzJztcbmltcG9ydCB7IGFkZF9yZW5kZXJfY2FsbGJhY2sgfSBmcm9tICcuL3NjaGVkdWxlci5qcyc7XG5cbi8qKlxuICogQHR5cGUge1Byb21pc2U8dm9pZD4gfCBudWxsfVxuICovXG5sZXQgcHJvbWlzZTtcblxuLyoqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAqL1xuZnVuY3Rpb24gd2FpdCgpIHtcblx0aWYgKCFwcm9taXNlKSB7XG5cdFx0cHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuXHRcdHByb21pc2UudGhlbigoKSA9PiB7XG5cdFx0XHRwcm9taXNlID0gbnVsbDtcblx0XHR9KTtcblx0fVxuXHRyZXR1cm4gcHJvbWlzZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7SU5UUk8gfCBPVVRSTyB8IGJvb2xlYW59IGRpcmVjdGlvblxuICogQHBhcmFtIHsnc3RhcnQnIHwgJ2VuZCd9IGtpbmRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBkaXNwYXRjaChub2RlLCBkaXJlY3Rpb24sIGtpbmQpIHtcblx0bm9kZS5kaXNwYXRjaEV2ZW50KGN1c3RvbV9ldmVudChgJHtkaXJlY3Rpb24gPyAnaW50cm8nIDogJ291dHJvJ30ke2tpbmR9YCkpO1xufVxuXG5jb25zdCBvdXRyb2luZyA9IG5ldyBTZXQoKTtcblxuLyoqXG4gKiBAdHlwZSB7T3V0cm99XG4gKi9cbmxldCBvdXRyb3M7XG5cbi8qKlxuICogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gZ3JvdXBfb3V0cm9zKCkge1xuXHRvdXRyb3MgPSB7XG5cdFx0cjogMCxcblx0XHRjOiBbXSxcblx0XHRwOiBvdXRyb3MgLy8gcGFyZW50IGdyb3VwXG5cdH07XG59XG5cbi8qKlxuICogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tfb3V0cm9zKCkge1xuXHRpZiAoIW91dHJvcy5yKSB7XG5cdFx0cnVuX2FsbChvdXRyb3MuYyk7XG5cdH1cblx0b3V0cm9zID0gb3V0cm9zLnA7XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLkZyYWdtZW50fSBibG9ja1xuICogQHBhcmFtIHswIHwgMX0gW2xvY2FsXVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2l0aW9uX2luKGJsb2NrLCBsb2NhbCkge1xuXHRpZiAoYmxvY2sgJiYgYmxvY2suaSkge1xuXHRcdG91dHJvaW5nLmRlbGV0ZShibG9jayk7XG5cdFx0YmxvY2suaShsb2NhbCk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9wcml2YXRlLmpzJykuRnJhZ21lbnR9IGJsb2NrXG4gKiBAcGFyYW0gezAgfCAxfSBsb2NhbFxuICogQHBhcmFtIHswIHwgMX0gW2RldGFjaF1cbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gW2NhbGxiYWNrXVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2l0aW9uX291dChibG9jaywgbG9jYWwsIGRldGFjaCwgY2FsbGJhY2spIHtcblx0aWYgKGJsb2NrICYmIGJsb2NrLm8pIHtcblx0XHRpZiAob3V0cm9pbmcuaGFzKGJsb2NrKSkgcmV0dXJuO1xuXHRcdG91dHJvaW5nLmFkZChibG9jayk7XG5cdFx0b3V0cm9zLmMucHVzaCgoKSA9PiB7XG5cdFx0XHRvdXRyb2luZy5kZWxldGUoYmxvY2spO1xuXHRcdFx0aWYgKGNhbGxiYWNrKSB7XG5cdFx0XHRcdGlmIChkZXRhY2gpIGJsb2NrLmQoMSk7XG5cdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0YmxvY2subyhsb2NhbCk7XG5cdH0gZWxzZSBpZiAoY2FsbGJhY2spIHtcblx0XHRjYWxsYmFjaygpO1xuXHR9XG59XG5cbi8qKlxuICogQHR5cGUge2ltcG9ydCgnLi4vdHJhbnNpdGlvbi9wdWJsaWMuanMnKS5UcmFuc2l0aW9uQ29uZmlnfVxuICovXG5jb25zdCBudWxsX3RyYW5zaXRpb24gPSB7IGR1cmF0aW9uOiAwIH07XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50ICYgRWxlbWVudENTU0lubGluZVN0eWxlfSBub2RlXG4gKiBAcGFyYW0ge1RyYW5zaXRpb25Gbn0gZm5cbiAqIEBwYXJhbSB7YW55fSBwYXJhbXNcbiAqIEByZXR1cm5zIHt7IHN0YXJ0KCk6IHZvaWQ7IGludmFsaWRhdGUoKTogdm9pZDsgZW5kKCk6IHZvaWQ7IH19XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVfaW5fdHJhbnNpdGlvbihub2RlLCBmbiwgcGFyYW1zKSB7XG5cdC8qKlxuXHQgKiBAdHlwZSB7VHJhbnNpdGlvbk9wdGlvbnN9ICovXG5cdGNvbnN0IG9wdGlvbnMgPSB7IGRpcmVjdGlvbjogJ2luJyB9O1xuXHRsZXQgY29uZmlnID0gZm4obm9kZSwgcGFyYW1zLCBvcHRpb25zKTtcblx0bGV0IHJ1bm5pbmcgPSBmYWxzZTtcblx0bGV0IGFuaW1hdGlvbl9uYW1lO1xuXHRsZXQgdGFzaztcblx0bGV0IHVpZCA9IDA7XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHt2b2lkfSAqL1xuXHRmdW5jdGlvbiBjbGVhbnVwKCkge1xuXHRcdGlmIChhbmltYXRpb25fbmFtZSkgZGVsZXRlX3J1bGUobm9kZSwgYW5pbWF0aW9uX25hbWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHt2b2lkfSAqL1xuXHRmdW5jdGlvbiBnbygpIHtcblx0XHRjb25zdCB7XG5cdFx0XHRkZWxheSA9IDAsXG5cdFx0XHRkdXJhdGlvbiA9IDMwMCxcblx0XHRcdGVhc2luZyA9IGxpbmVhcixcblx0XHRcdHRpY2sgPSBub29wLFxuXHRcdFx0Y3NzXG5cdFx0fSA9IGNvbmZpZyB8fCBudWxsX3RyYW5zaXRpb247XG5cdFx0aWYgKGNzcykgYW5pbWF0aW9uX25hbWUgPSBjcmVhdGVfcnVsZShub2RlLCAwLCAxLCBkdXJhdGlvbiwgZGVsYXksIGVhc2luZywgY3NzLCB1aWQrKyk7XG5cdFx0dGljaygwLCAxKTtcblx0XHRjb25zdCBzdGFydF90aW1lID0gbm93KCkgKyBkZWxheTtcblx0XHRjb25zdCBlbmRfdGltZSA9IHN0YXJ0X3RpbWUgKyBkdXJhdGlvbjtcblx0XHRpZiAodGFzaykgdGFzay5hYm9ydCgpO1xuXHRcdHJ1bm5pbmcgPSB0cnVlO1xuXHRcdGFkZF9yZW5kZXJfY2FsbGJhY2soKCkgPT4gZGlzcGF0Y2gobm9kZSwgdHJ1ZSwgJ3N0YXJ0JykpO1xuXHRcdHRhc2sgPSBsb29wKChub3cpID0+IHtcblx0XHRcdGlmIChydW5uaW5nKSB7XG5cdFx0XHRcdGlmIChub3cgPj0gZW5kX3RpbWUpIHtcblx0XHRcdFx0XHR0aWNrKDEsIDApO1xuXHRcdFx0XHRcdGRpc3BhdGNoKG5vZGUsIHRydWUsICdlbmQnKTtcblx0XHRcdFx0XHRjbGVhbnVwKCk7XG5cdFx0XHRcdFx0cmV0dXJuIChydW5uaW5nID0gZmFsc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChub3cgPj0gc3RhcnRfdGltZSkge1xuXHRcdFx0XHRcdGNvbnN0IHQgPSBlYXNpbmcoKG5vdyAtIHN0YXJ0X3RpbWUpIC8gZHVyYXRpb24pO1xuXHRcdFx0XHRcdHRpY2sodCwgMSAtIHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcnVubmluZztcblx0XHR9KTtcblx0fVxuXHRsZXQgc3RhcnRlZCA9IGZhbHNlO1xuXHRyZXR1cm4ge1xuXHRcdHN0YXJ0KCkge1xuXHRcdFx0aWYgKHN0YXJ0ZWQpIHJldHVybjtcblx0XHRcdHN0YXJ0ZWQgPSB0cnVlO1xuXHRcdFx0ZGVsZXRlX3J1bGUobm9kZSk7XG5cdFx0XHRpZiAoaXNfZnVuY3Rpb24oY29uZmlnKSkge1xuXHRcdFx0XHRjb25maWcgPSBjb25maWcob3B0aW9ucyk7XG5cdFx0XHRcdHdhaXQoKS50aGVuKGdvKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGdvKCk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRpbnZhbGlkYXRlKCkge1xuXHRcdFx0c3RhcnRlZCA9IGZhbHNlO1xuXHRcdH0sXG5cdFx0ZW5kKCkge1xuXHRcdFx0aWYgKHJ1bm5pbmcpIHtcblx0XHRcdFx0Y2xlYW51cCgpO1xuXHRcdFx0XHRydW5uaW5nID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudCAmIEVsZW1lbnRDU1NJbmxpbmVTdHlsZX0gbm9kZVxuICogQHBhcmFtIHtUcmFuc2l0aW9uRm59IGZuXG4gKiBAcGFyYW0ge2FueX0gcGFyYW1zXG4gKiBAcmV0dXJucyB7eyBlbmQocmVzZXQ6IGFueSk6IHZvaWQ7IH19XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVfb3V0X3RyYW5zaXRpb24obm9kZSwgZm4sIHBhcmFtcykge1xuXHQvKiogQHR5cGUge1RyYW5zaXRpb25PcHRpb25zfSAqL1xuXHRjb25zdCBvcHRpb25zID0geyBkaXJlY3Rpb246ICdvdXQnIH07XG5cdGxldCBjb25maWcgPSBmbihub2RlLCBwYXJhbXMsIG9wdGlvbnMpO1xuXHRsZXQgcnVubmluZyA9IHRydWU7XG5cdGxldCBhbmltYXRpb25fbmFtZTtcblx0Y29uc3QgZ3JvdXAgPSBvdXRyb3M7XG5cdGdyb3VwLnIgKz0gMTtcblx0LyoqIEB0eXBlIHtib29sZWFufSAqL1xuXHRsZXQgb3JpZ2luYWxfaW5lcnRfdmFsdWU7XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHt2b2lkfSAqL1xuXHRmdW5jdGlvbiBnbygpIHtcblx0XHRjb25zdCB7XG5cdFx0XHRkZWxheSA9IDAsXG5cdFx0XHRkdXJhdGlvbiA9IDMwMCxcblx0XHRcdGVhc2luZyA9IGxpbmVhcixcblx0XHRcdHRpY2sgPSBub29wLFxuXHRcdFx0Y3NzXG5cdFx0fSA9IGNvbmZpZyB8fCBudWxsX3RyYW5zaXRpb247XG5cblx0XHRpZiAoY3NzKSBhbmltYXRpb25fbmFtZSA9IGNyZWF0ZV9ydWxlKG5vZGUsIDEsIDAsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nLCBjc3MpO1xuXG5cdFx0Y29uc3Qgc3RhcnRfdGltZSA9IG5vdygpICsgZGVsYXk7XG5cdFx0Y29uc3QgZW5kX3RpbWUgPSBzdGFydF90aW1lICsgZHVyYXRpb247XG5cdFx0YWRkX3JlbmRlcl9jYWxsYmFjaygoKSA9PiBkaXNwYXRjaChub2RlLCBmYWxzZSwgJ3N0YXJ0JykpO1xuXG5cdFx0aWYgKCdpbmVydCcgaW4gbm9kZSkge1xuXHRcdFx0b3JpZ2luYWxfaW5lcnRfdmFsdWUgPSAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyAobm9kZSkuaW5lcnQ7XG5cdFx0XHRub2RlLmluZXJ0ID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRsb29wKChub3cpID0+IHtcblx0XHRcdGlmIChydW5uaW5nKSB7XG5cdFx0XHRcdGlmIChub3cgPj0gZW5kX3RpbWUpIHtcblx0XHRcdFx0XHR0aWNrKDAsIDEpO1xuXHRcdFx0XHRcdGRpc3BhdGNoKG5vZGUsIGZhbHNlLCAnZW5kJyk7XG5cdFx0XHRcdFx0aWYgKCEtLWdyb3VwLnIpIHtcblx0XHRcdFx0XHRcdC8vIHRoaXMgd2lsbCByZXN1bHQgaW4gYGVuZCgpYCBiZWluZyBjYWxsZWQsXG5cdFx0XHRcdFx0XHQvLyBzbyB3ZSBkb24ndCBuZWVkIHRvIGNsZWFuIHVwIGhlcmVcblx0XHRcdFx0XHRcdHJ1bl9hbGwoZ3JvdXAuYyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobm93ID49IHN0YXJ0X3RpbWUpIHtcblx0XHRcdFx0XHRjb25zdCB0ID0gZWFzaW5nKChub3cgLSBzdGFydF90aW1lKSAvIGR1cmF0aW9uKTtcblx0XHRcdFx0XHR0aWNrKDEgLSB0LCB0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJ1bm5pbmc7XG5cdFx0fSk7XG5cdH1cblxuXHRpZiAoaXNfZnVuY3Rpb24oY29uZmlnKSkge1xuXHRcdHdhaXQoKS50aGVuKCgpID0+IHtcblx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdGNvbmZpZyA9IGNvbmZpZyhvcHRpb25zKTtcblx0XHRcdGdvKCk7XG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0Z28oKTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0ZW5kKHJlc2V0KSB7XG5cdFx0XHRpZiAocmVzZXQgJiYgJ2luZXJ0JyBpbiBub2RlKSB7XG5cdFx0XHRcdG5vZGUuaW5lcnQgPSBvcmlnaW5hbF9pbmVydF92YWx1ZTtcblx0XHRcdH1cblx0XHRcdGlmIChyZXNldCAmJiBjb25maWcudGljaykge1xuXHRcdFx0XHRjb25maWcudGljaygxLCAwKTtcblx0XHRcdH1cblx0XHRcdGlmIChydW5uaW5nKSB7XG5cdFx0XHRcdGlmIChhbmltYXRpb25fbmFtZSkgZGVsZXRlX3J1bGUobm9kZSwgYW5pbWF0aW9uX25hbWUpO1xuXHRcdFx0XHRydW5uaW5nID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudCAmIEVsZW1lbnRDU1NJbmxpbmVTdHlsZX0gbm9kZVxuICogQHBhcmFtIHtUcmFuc2l0aW9uRm59IGZuXG4gKiBAcGFyYW0ge2FueX0gcGFyYW1zXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGludHJvXG4gKiBAcmV0dXJucyB7eyBydW4oYjogMCB8IDEpOiB2b2lkOyBlbmQoKTogdm9pZDsgfX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZV9iaWRpcmVjdGlvbmFsX3RyYW5zaXRpb24obm9kZSwgZm4sIHBhcmFtcywgaW50cm8pIHtcblx0LyoqXG5cdCAqIEB0eXBlIHtUcmFuc2l0aW9uT3B0aW9uc30gKi9cblx0Y29uc3Qgb3B0aW9ucyA9IHsgZGlyZWN0aW9uOiAnYm90aCcgfTtcblx0bGV0IGNvbmZpZyA9IGZuKG5vZGUsIHBhcmFtcywgb3B0aW9ucyk7XG5cdGxldCB0ID0gaW50cm8gPyAwIDogMTtcblxuXHQvKipcblx0ICogQHR5cGUge1Byb2dyYW0gfCBudWxsfSAqL1xuXHRsZXQgcnVubmluZ19wcm9ncmFtID0gbnVsbDtcblxuXHQvKipcblx0ICogQHR5cGUge1BlbmRpbmdQcm9ncmFtIHwgbnVsbH0gKi9cblx0bGV0IHBlbmRpbmdfcHJvZ3JhbSA9IG51bGw7XG5cdGxldCBhbmltYXRpb25fbmFtZSA9IG51bGw7XG5cblx0LyoqIEB0eXBlIHtib29sZWFufSAqL1xuXHRsZXQgb3JpZ2luYWxfaW5lcnRfdmFsdWU7XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHt2b2lkfSAqL1xuXHRmdW5jdGlvbiBjbGVhcl9hbmltYXRpb24oKSB7XG5cdFx0aWYgKGFuaW1hdGlvbl9uYW1lKSBkZWxldGVfcnVsZShub2RlLCBhbmltYXRpb25fbmFtZSk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtQZW5kaW5nUHJvZ3JhbX0gcHJvZ3JhbVxuXHQgKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb25cblx0ICogQHJldHVybnMge1Byb2dyYW19XG5cdCAqL1xuXHRmdW5jdGlvbiBpbml0KHByb2dyYW0sIGR1cmF0aW9uKSB7XG5cdFx0Y29uc3QgZCA9IC8qKiBAdHlwZSB7UHJvZ3JhbVsnZCddfSAqLyAocHJvZ3JhbS5iIC0gdCk7XG5cdFx0ZHVyYXRpb24gKj0gTWF0aC5hYnMoZCk7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGE6IHQsXG5cdFx0XHRiOiBwcm9ncmFtLmIsXG5cdFx0XHRkLFxuXHRcdFx0ZHVyYXRpb24sXG5cdFx0XHRzdGFydDogcHJvZ3JhbS5zdGFydCxcblx0XHRcdGVuZDogcHJvZ3JhbS5zdGFydCArIGR1cmF0aW9uLFxuXHRcdFx0Z3JvdXA6IHByb2dyYW0uZ3JvdXBcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7SU5UUk8gfCBPVVRST30gYlxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdGZ1bmN0aW9uIGdvKGIpIHtcblx0XHRjb25zdCB7XG5cdFx0XHRkZWxheSA9IDAsXG5cdFx0XHRkdXJhdGlvbiA9IDMwMCxcblx0XHRcdGVhc2luZyA9IGxpbmVhcixcblx0XHRcdHRpY2sgPSBub29wLFxuXHRcdFx0Y3NzXG5cdFx0fSA9IGNvbmZpZyB8fCBudWxsX3RyYW5zaXRpb247XG5cblx0XHQvKipcblx0XHQgKiBAdHlwZSB7UGVuZGluZ1Byb2dyYW19ICovXG5cdFx0Y29uc3QgcHJvZ3JhbSA9IHtcblx0XHRcdHN0YXJ0OiBub3coKSArIGRlbGF5LFxuXHRcdFx0YlxuXHRcdH07XG5cblx0XHRpZiAoIWIpIHtcblx0XHRcdC8vIEB0cy1pZ25vcmUgdG9kbzogaW1wcm92ZSB0eXBpbmdzXG5cdFx0XHRwcm9ncmFtLmdyb3VwID0gb3V0cm9zO1xuXHRcdFx0b3V0cm9zLnIgKz0gMTtcblx0XHR9XG5cblx0XHRpZiAoJ2luZXJ0JyBpbiBub2RlKSB7XG5cdFx0XHRpZiAoYikge1xuXHRcdFx0XHRpZiAob3JpZ2luYWxfaW5lcnRfdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdC8vIGFib3J0ZWQvcmV2ZXJzZWQgb3V0cm8gXHUyMDE0IHJlc3RvcmUgcHJldmlvdXMgaW5lcnQgdmFsdWVcblx0XHRcdFx0XHRub2RlLmluZXJ0ID0gb3JpZ2luYWxfaW5lcnRfdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9yaWdpbmFsX2luZXJ0X3ZhbHVlID0gLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8gKG5vZGUpLmluZXJ0O1xuXHRcdFx0XHRub2RlLmluZXJ0ID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAocnVubmluZ19wcm9ncmFtIHx8IHBlbmRpbmdfcHJvZ3JhbSkge1xuXHRcdFx0cGVuZGluZ19wcm9ncmFtID0gcHJvZ3JhbTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gaWYgdGhpcyBpcyBhbiBpbnRybywgYW5kIHRoZXJlJ3MgYSBkZWxheSwgd2UgbmVlZCB0byBkb1xuXHRcdFx0Ly8gYW4gaW5pdGlhbCB0aWNrIGFuZC9vciBhcHBseSBDU1MgYW5pbWF0aW9uIGltbWVkaWF0ZWx5XG5cdFx0XHRpZiAoY3NzKSB7XG5cdFx0XHRcdGNsZWFyX2FuaW1hdGlvbigpO1xuXHRcdFx0XHRhbmltYXRpb25fbmFtZSA9IGNyZWF0ZV9ydWxlKG5vZGUsIHQsIGIsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nLCBjc3MpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGIpIHRpY2soMCwgMSk7XG5cdFx0XHRydW5uaW5nX3Byb2dyYW0gPSBpbml0KHByb2dyYW0sIGR1cmF0aW9uKTtcblx0XHRcdGFkZF9yZW5kZXJfY2FsbGJhY2soKCkgPT4gZGlzcGF0Y2gobm9kZSwgYiwgJ3N0YXJ0JykpO1xuXHRcdFx0bG9vcCgobm93KSA9PiB7XG5cdFx0XHRcdGlmIChwZW5kaW5nX3Byb2dyYW0gJiYgbm93ID4gcGVuZGluZ19wcm9ncmFtLnN0YXJ0KSB7XG5cdFx0XHRcdFx0cnVubmluZ19wcm9ncmFtID0gaW5pdChwZW5kaW5nX3Byb2dyYW0sIGR1cmF0aW9uKTtcblx0XHRcdFx0XHRwZW5kaW5nX3Byb2dyYW0gPSBudWxsO1xuXHRcdFx0XHRcdGRpc3BhdGNoKG5vZGUsIHJ1bm5pbmdfcHJvZ3JhbS5iLCAnc3RhcnQnKTtcblx0XHRcdFx0XHRpZiAoY3NzKSB7XG5cdFx0XHRcdFx0XHRjbGVhcl9hbmltYXRpb24oKTtcblx0XHRcdFx0XHRcdGFuaW1hdGlvbl9uYW1lID0gY3JlYXRlX3J1bGUoXG5cdFx0XHRcdFx0XHRcdG5vZGUsXG5cdFx0XHRcdFx0XHRcdHQsXG5cdFx0XHRcdFx0XHRcdHJ1bm5pbmdfcHJvZ3JhbS5iLFxuXHRcdFx0XHRcdFx0XHRydW5uaW5nX3Byb2dyYW0uZHVyYXRpb24sXG5cdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdGVhc2luZyxcblx0XHRcdFx0XHRcdFx0Y29uZmlnLmNzc1xuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHJ1bm5pbmdfcHJvZ3JhbSkge1xuXHRcdFx0XHRcdGlmIChub3cgPj0gcnVubmluZ19wcm9ncmFtLmVuZCkge1xuXHRcdFx0XHRcdFx0dGljaygodCA9IHJ1bm5pbmdfcHJvZ3JhbS5iKSwgMSAtIHQpO1xuXHRcdFx0XHRcdFx0ZGlzcGF0Y2gobm9kZSwgcnVubmluZ19wcm9ncmFtLmIsICdlbmQnKTtcblx0XHRcdFx0XHRcdGlmICghcGVuZGluZ19wcm9ncmFtKSB7XG5cdFx0XHRcdFx0XHRcdC8vIHdlJ3JlIGRvbmVcblx0XHRcdFx0XHRcdFx0aWYgKHJ1bm5pbmdfcHJvZ3JhbS5iKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gaW50cm8gXHUyMDE0IHdlIGNhbiB0aWR5IHVwIGltbWVkaWF0ZWx5XG5cdFx0XHRcdFx0XHRcdFx0Y2xlYXJfYW5pbWF0aW9uKCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gb3V0cm8gXHUyMDE0IG5lZWRzIHRvIGJlIGNvb3JkaW5hdGVkXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCEtLXJ1bm5pbmdfcHJvZ3JhbS5ncm91cC5yKSBydW5fYWxsKHJ1bm5pbmdfcHJvZ3JhbS5ncm91cC5jKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cnVubmluZ19wcm9ncmFtID0gbnVsbDtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKG5vdyA+PSBydW5uaW5nX3Byb2dyYW0uc3RhcnQpIHtcblx0XHRcdFx0XHRcdGNvbnN0IHAgPSBub3cgLSBydW5uaW5nX3Byb2dyYW0uc3RhcnQ7XG5cdFx0XHRcdFx0XHR0ID0gcnVubmluZ19wcm9ncmFtLmEgKyBydW5uaW5nX3Byb2dyYW0uZCAqIGVhc2luZyhwIC8gcnVubmluZ19wcm9ncmFtLmR1cmF0aW9uKTtcblx0XHRcdFx0XHRcdHRpY2sodCwgMSAtIHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gISEocnVubmluZ19wcm9ncmFtIHx8IHBlbmRpbmdfcHJvZ3JhbSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHtcblx0XHRydW4oYikge1xuXHRcdFx0aWYgKGlzX2Z1bmN0aW9uKGNvbmZpZykpIHtcblx0XHRcdFx0d2FpdCgpLnRoZW4oKCkgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IG9wdHMgPSB7IGRpcmVjdGlvbjogYiA/ICdpbicgOiAnb3V0JyB9O1xuXHRcdFx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdFx0XHRjb25maWcgPSBjb25maWcob3B0cyk7XG5cdFx0XHRcdFx0Z28oYik7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Z28oYik7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRlbmQoKSB7XG5cdFx0XHRjbGVhcl9hbmltYXRpb24oKTtcblx0XHRcdHJ1bm5pbmdfcHJvZ3JhbSA9IHBlbmRpbmdfcHJvZ3JhbSA9IG51bGw7XG5cdFx0fVxuXHR9O1xufVxuXG4vKiogQHR5cGVkZWYgezF9IElOVFJPICovXG4vKiogQHR5cGVkZWYgezB9IE9VVFJPICovXG4vKiogQHR5cGVkZWYge3sgZGlyZWN0aW9uOiAnaW4nIHwgJ291dCcgfCAnYm90aCcgfX0gVHJhbnNpdGlvbk9wdGlvbnMgKi9cbi8qKiBAdHlwZWRlZiB7KG5vZGU6IEVsZW1lbnQsIHBhcmFtczogYW55LCBvcHRpb25zOiBUcmFuc2l0aW9uT3B0aW9ucykgPT4gaW1wb3J0KCcuLi90cmFuc2l0aW9uL3B1YmxpYy5qcycpLlRyYW5zaXRpb25Db25maWd9IFRyYW5zaXRpb25GbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE91dHJvXG4gKiBAcHJvcGVydHkge251bWJlcn0gclxuICogQHByb3BlcnR5IHtGdW5jdGlvbltdfSBjXG4gKiBAcHJvcGVydHkge09iamVjdH0gcFxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUGVuZGluZ1Byb2dyYW1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzdGFydFxuICogQHByb3BlcnR5IHtJTlRST3xPVVRST30gYlxuICogQHByb3BlcnR5IHtPdXRyb30gW2dyb3VwXVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUHJvZ3JhbVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGFcbiAqIEBwcm9wZXJ0eSB7SU5UUk98T1VUUk99IGJcbiAqIEBwcm9wZXJ0eSB7MXwtMX0gZFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGR1cmF0aW9uXG4gKiBAcHJvcGVydHkge251bWJlcn0gc3RhcnRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBlbmRcbiAqIEBwcm9wZXJ0eSB7T3V0cm99IFtncm91cF1cbiAqL1xuIiwgImltcG9ydCB7IHRyYW5zaXRpb25faW4sIHRyYW5zaXRpb25fb3V0IH0gZnJvbSAnLi90cmFuc2l0aW9ucy5qcyc7XG5pbXBvcnQgeyBydW5fYWxsIH0gZnJvbSAnLi91dGlscy5qcyc7XG5cbi8vIGdlbmVyYWwgZWFjaCBmdW5jdGlvbnM6XG5cbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVfYXJyYXlfbGlrZShhcnJheV9saWtlX29yX2l0ZXJhdG9yKSB7XG5cdHJldHVybiBhcnJheV9saWtlX29yX2l0ZXJhdG9yPy5sZW5ndGggIT09IHVuZGVmaW5lZFxuXHRcdD8gYXJyYXlfbGlrZV9vcl9pdGVyYXRvclxuXHRcdDogQXJyYXkuZnJvbShhcnJheV9saWtlX29yX2l0ZXJhdG9yKTtcbn1cblxuLy8ga2V5ZWQgZWFjaCBmdW5jdGlvbnM6XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApIHtcblx0YmxvY2suZCgxKTtcblx0bG9va3VwLmRlbGV0ZShibG9jay5rZXkpO1xufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gb3V0cm9fYW5kX2Rlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCkge1xuXHR0cmFuc2l0aW9uX291dChibG9jaywgMSwgMSwgKCkgPT4ge1xuXHRcdGxvb2t1cC5kZWxldGUoYmxvY2sua2V5KTtcblx0fSk7XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaXhfYW5kX2Rlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCkge1xuXHRibG9jay5mKCk7XG5cdGRlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCk7XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaXhfYW5kX291dHJvX2FuZF9kZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApIHtcblx0YmxvY2suZigpO1xuXHRvdXRyb19hbmRfZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKTtcbn1cblxuLyoqIEByZXR1cm5zIHthbnlbXX0gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVfa2V5ZWRfZWFjaChcblx0b2xkX2Jsb2Nrcyxcblx0ZGlydHksXG5cdGdldF9rZXksXG5cdGR5bmFtaWMsXG5cdGN0eCxcblx0bGlzdCxcblx0bG9va3VwLFxuXHRub2RlLFxuXHRkZXN0cm95LFxuXHRjcmVhdGVfZWFjaF9ibG9jayxcblx0bmV4dCxcblx0Z2V0X2NvbnRleHRcbikge1xuXHRsZXQgbyA9IG9sZF9ibG9ja3MubGVuZ3RoO1xuXHRsZXQgbiA9IGxpc3QubGVuZ3RoO1xuXHRsZXQgaSA9IG87XG5cdGNvbnN0IG9sZF9pbmRleGVzID0ge307XG5cdHdoaWxlIChpLS0pIG9sZF9pbmRleGVzW29sZF9ibG9ja3NbaV0ua2V5XSA9IGk7XG5cdGNvbnN0IG5ld19ibG9ja3MgPSBbXTtcblx0Y29uc3QgbmV3X2xvb2t1cCA9IG5ldyBNYXAoKTtcblx0Y29uc3QgZGVsdGFzID0gbmV3IE1hcCgpO1xuXHRjb25zdCB1cGRhdGVzID0gW107XG5cdGkgPSBuO1xuXHR3aGlsZSAoaS0tKSB7XG5cdFx0Y29uc3QgY2hpbGRfY3R4ID0gZ2V0X2NvbnRleHQoY3R4LCBsaXN0LCBpKTtcblx0XHRjb25zdCBrZXkgPSBnZXRfa2V5KGNoaWxkX2N0eCk7XG5cdFx0bGV0IGJsb2NrID0gbG9va3VwLmdldChrZXkpO1xuXHRcdGlmICghYmxvY2spIHtcblx0XHRcdGJsb2NrID0gY3JlYXRlX2VhY2hfYmxvY2soa2V5LCBjaGlsZF9jdHgpO1xuXHRcdFx0YmxvY2suYygpO1xuXHRcdH0gZWxzZSBpZiAoZHluYW1pYykge1xuXHRcdFx0Ly8gZGVmZXIgdXBkYXRlcyB1bnRpbCBhbGwgdGhlIERPTSBzaHVmZmxpbmcgaXMgZG9uZVxuXHRcdFx0dXBkYXRlcy5wdXNoKCgpID0+IGJsb2NrLnAoY2hpbGRfY3R4LCBkaXJ0eSkpO1xuXHRcdH1cblx0XHRuZXdfbG9va3VwLnNldChrZXksIChuZXdfYmxvY2tzW2ldID0gYmxvY2spKTtcblx0XHRpZiAoa2V5IGluIG9sZF9pbmRleGVzKSBkZWx0YXMuc2V0KGtleSwgTWF0aC5hYnMoaSAtIG9sZF9pbmRleGVzW2tleV0pKTtcblx0fVxuXHRjb25zdCB3aWxsX21vdmUgPSBuZXcgU2V0KCk7XG5cdGNvbnN0IGRpZF9tb3ZlID0gbmV3IFNldCgpO1xuXHQvKiogQHJldHVybnMge3ZvaWR9ICovXG5cdGZ1bmN0aW9uIGluc2VydChibG9jaykge1xuXHRcdHRyYW5zaXRpb25faW4oYmxvY2ssIDEpO1xuXHRcdGJsb2NrLm0obm9kZSwgbmV4dCk7XG5cdFx0bG9va3VwLnNldChibG9jay5rZXksIGJsb2NrKTtcblx0XHRuZXh0ID0gYmxvY2suZmlyc3Q7XG5cdFx0bi0tO1xuXHR9XG5cdHdoaWxlIChvICYmIG4pIHtcblx0XHRjb25zdCBuZXdfYmxvY2sgPSBuZXdfYmxvY2tzW24gLSAxXTtcblx0XHRjb25zdCBvbGRfYmxvY2sgPSBvbGRfYmxvY2tzW28gLSAxXTtcblx0XHRjb25zdCBuZXdfa2V5ID0gbmV3X2Jsb2NrLmtleTtcblx0XHRjb25zdCBvbGRfa2V5ID0gb2xkX2Jsb2NrLmtleTtcblx0XHRpZiAobmV3X2Jsb2NrID09PSBvbGRfYmxvY2spIHtcblx0XHRcdC8vIGRvIG5vdGhpbmdcblx0XHRcdG5leHQgPSBuZXdfYmxvY2suZmlyc3Q7XG5cdFx0XHRvLS07XG5cdFx0XHRuLS07XG5cdFx0fSBlbHNlIGlmICghbmV3X2xvb2t1cC5oYXMob2xkX2tleSkpIHtcblx0XHRcdC8vIHJlbW92ZSBvbGQgYmxvY2tcblx0XHRcdGRlc3Ryb3kob2xkX2Jsb2NrLCBsb29rdXApO1xuXHRcdFx0by0tO1xuXHRcdH0gZWxzZSBpZiAoIWxvb2t1cC5oYXMobmV3X2tleSkgfHwgd2lsbF9tb3ZlLmhhcyhuZXdfa2V5KSkge1xuXHRcdFx0aW5zZXJ0KG5ld19ibG9jayk7XG5cdFx0fSBlbHNlIGlmIChkaWRfbW92ZS5oYXMob2xkX2tleSkpIHtcblx0XHRcdG8tLTtcblx0XHR9IGVsc2UgaWYgKGRlbHRhcy5nZXQobmV3X2tleSkgPiBkZWx0YXMuZ2V0KG9sZF9rZXkpKSB7XG5cdFx0XHRkaWRfbW92ZS5hZGQobmV3X2tleSk7XG5cdFx0XHRpbnNlcnQobmV3X2Jsb2NrKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0d2lsbF9tb3ZlLmFkZChvbGRfa2V5KTtcblx0XHRcdG8tLTtcblx0XHR9XG5cdH1cblx0d2hpbGUgKG8tLSkge1xuXHRcdGNvbnN0IG9sZF9ibG9jayA9IG9sZF9ibG9ja3Nbb107XG5cdFx0aWYgKCFuZXdfbG9va3VwLmhhcyhvbGRfYmxvY2sua2V5KSkgZGVzdHJveShvbGRfYmxvY2ssIGxvb2t1cCk7XG5cdH1cblx0d2hpbGUgKG4pIGluc2VydChuZXdfYmxvY2tzW24gLSAxXSk7XG5cdHJ1bl9hbGwodXBkYXRlcyk7XG5cdHJldHVybiBuZXdfYmxvY2tzO1xufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVfZWFjaF9rZXlzKGN0eCwgbGlzdCwgZ2V0X2NvbnRleHQsIGdldF9rZXkpIHtcblx0Y29uc3Qga2V5cyA9IG5ldyBNYXAoKTtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0Y29uc3Qga2V5ID0gZ2V0X2tleShnZXRfY29udGV4dChjdHgsIGxpc3QsIGkpKTtcblx0XHRpZiAoa2V5cy5oYXMoa2V5KSkge1xuXHRcdFx0bGV0IHZhbHVlID0gJyc7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR2YWx1ZSA9IGB3aXRoIHZhbHVlICcke1N0cmluZyhrZXkpfScgYDtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0Ly8gY2FuJ3Qgc3RyaW5naWZ5XG5cdFx0XHR9XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdGBDYW5ub3QgaGF2ZSBkdXBsaWNhdGUga2V5cyBpbiBhIGtleWVkIGVhY2g6IEtleXMgYXQgaW5kZXggJHtrZXlzLmdldChcblx0XHRcdFx0XHRrZXlcblx0XHRcdFx0KX0gYW5kICR7aX0gJHt2YWx1ZX1hcmUgZHVwbGljYXRlc2Bcblx0XHRcdCk7XG5cdFx0fVxuXHRcdGtleXMuc2V0KGtleSwgaSk7XG5cdH1cbn1cbiIsICJjb25zdCBfYm9vbGVhbl9hdHRyaWJ1dGVzID0gLyoqIEB0eXBlIHtjb25zdH0gKi8gKFtcblx0J2FsbG93ZnVsbHNjcmVlbicsXG5cdCdhbGxvd3BheW1lbnRyZXF1ZXN0Jyxcblx0J2FzeW5jJyxcblx0J2F1dG9mb2N1cycsXG5cdCdhdXRvcGxheScsXG5cdCdjaGVja2VkJyxcblx0J2NvbnRyb2xzJyxcblx0J2RlZmF1bHQnLFxuXHQnZGVmZXInLFxuXHQnZGlzYWJsZWQnLFxuXHQnZm9ybW5vdmFsaWRhdGUnLFxuXHQnaGlkZGVuJyxcblx0J2luZXJ0Jyxcblx0J2lzbWFwJyxcblx0J2xvb3AnLFxuXHQnbXVsdGlwbGUnLFxuXHQnbXV0ZWQnLFxuXHQnbm9tb2R1bGUnLFxuXHQnbm92YWxpZGF0ZScsXG5cdCdvcGVuJyxcblx0J3BsYXlzaW5saW5lJyxcblx0J3JlYWRvbmx5Jyxcblx0J3JlcXVpcmVkJyxcblx0J3JldmVyc2VkJyxcblx0J3NlbGVjdGVkJ1xuXSk7XG5cbi8qKlxuICogTGlzdCBvZiBIVE1MIGJvb2xlYW4gYXR0cmlidXRlcyAoZS5nLiBgPGlucHV0IGRpc2FibGVkPmApLlxuICogU291cmNlOiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmRpY2VzLmh0bWxcbiAqXG4gKiBAdHlwZSB7U2V0PHN0cmluZz59XG4gKi9cbmV4cG9ydCBjb25zdCBib29sZWFuX2F0dHJpYnV0ZXMgPSBuZXcgU2V0KFsuLi5fYm9vbGVhbl9hdHRyaWJ1dGVzXSk7XG5cbi8qKiBAdHlwZWRlZiB7dHlwZW9mIF9ib29sZWFuX2F0dHJpYnV0ZXNbbnVtYmVyXX0gQm9vbGVhbkF0dHJpYnV0ZXMgKi9cbiIsICJpbXBvcnQge1xuXHRhZGRfcmVuZGVyX2NhbGxiYWNrLFxuXHRmbHVzaCxcblx0Zmx1c2hfcmVuZGVyX2NhbGxiYWNrcyxcblx0c2NoZWR1bGVfdXBkYXRlLFxuXHRkaXJ0eV9jb21wb25lbnRzXG59IGZyb20gJy4vc2NoZWR1bGVyLmpzJztcbmltcG9ydCB7IGN1cnJlbnRfY29tcG9uZW50LCBzZXRfY3VycmVudF9jb21wb25lbnQgfSBmcm9tICcuL2xpZmVjeWNsZS5qcyc7XG5pbXBvcnQgeyBibGFua19vYmplY3QsIGlzX2VtcHR5LCBpc19mdW5jdGlvbiwgcnVuLCBydW5fYWxsLCBub29wIH0gZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQge1xuXHRjaGlsZHJlbixcblx0ZGV0YWNoLFxuXHRzdGFydF9oeWRyYXRpbmcsXG5cdGVuZF9oeWRyYXRpbmcsXG5cdGdldF9jdXN0b21fZWxlbWVudHNfc2xvdHMsXG5cdGluc2VydCxcblx0ZWxlbWVudCxcblx0YXR0clxufSBmcm9tICcuL2RvbS5qcyc7XG5pbXBvcnQgeyB0cmFuc2l0aW9uX2luIH0gZnJvbSAnLi90cmFuc2l0aW9ucy5qcyc7XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kKGNvbXBvbmVudCwgbmFtZSwgY2FsbGJhY2spIHtcblx0Y29uc3QgaW5kZXggPSBjb21wb25lbnQuJCQucHJvcHNbbmFtZV07XG5cdGlmIChpbmRleCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0Y29tcG9uZW50LiQkLmJvdW5kW2luZGV4XSA9IGNhbGxiYWNrO1xuXHRcdGNhbGxiYWNrKGNvbXBvbmVudC4kJC5jdHhbaW5kZXhdKTtcblx0fVxufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlX2NvbXBvbmVudChibG9jaykge1xuXHRibG9jayAmJiBibG9jay5jKCk7XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGFpbV9jb21wb25lbnQoYmxvY2ssIHBhcmVudF9ub2Rlcykge1xuXHRibG9jayAmJiBibG9jay5sKHBhcmVudF9ub2Rlcyk7XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBtb3VudF9jb21wb25lbnQoY29tcG9uZW50LCB0YXJnZXQsIGFuY2hvcikge1xuXHRjb25zdCB7IGZyYWdtZW50LCBhZnRlcl91cGRhdGUgfSA9IGNvbXBvbmVudC4kJDtcblx0ZnJhZ21lbnQgJiYgZnJhZ21lbnQubSh0YXJnZXQsIGFuY2hvcik7XG5cdC8vIG9uTW91bnQgaGFwcGVucyBiZWZvcmUgdGhlIGluaXRpYWwgYWZ0ZXJVcGRhdGVcblx0YWRkX3JlbmRlcl9jYWxsYmFjaygoKSA9PiB7XG5cdFx0Y29uc3QgbmV3X29uX2Rlc3Ryb3kgPSBjb21wb25lbnQuJCQub25fbW91bnQubWFwKHJ1bikuZmlsdGVyKGlzX2Z1bmN0aW9uKTtcblx0XHQvLyBpZiB0aGUgY29tcG9uZW50IHdhcyBkZXN0cm95ZWQgaW1tZWRpYXRlbHlcblx0XHQvLyBpdCB3aWxsIHVwZGF0ZSB0aGUgYCQkLm9uX2Rlc3Ryb3lgIHJlZmVyZW5jZSB0byBgbnVsbGAuXG5cdFx0Ly8gdGhlIGRlc3RydWN0dXJlZCBvbl9kZXN0cm95IG1heSBzdGlsbCByZWZlcmVuY2UgdG8gdGhlIG9sZCBhcnJheVxuXHRcdGlmIChjb21wb25lbnQuJCQub25fZGVzdHJveSkge1xuXHRcdFx0Y29tcG9uZW50LiQkLm9uX2Rlc3Ryb3kucHVzaCguLi5uZXdfb25fZGVzdHJveSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEVkZ2UgY2FzZSAtIGNvbXBvbmVudCB3YXMgZGVzdHJveWVkIGltbWVkaWF0ZWx5LFxuXHRcdFx0Ly8gbW9zdCBsaWtlbHkgYXMgYSByZXN1bHQgb2YgYSBiaW5kaW5nIGluaXRpYWxpc2luZ1xuXHRcdFx0cnVuX2FsbChuZXdfb25fZGVzdHJveSk7XG5cdFx0fVxuXHRcdGNvbXBvbmVudC4kJC5vbl9tb3VudCA9IFtdO1xuXHR9KTtcblx0YWZ0ZXJfdXBkYXRlLmZvckVhY2goYWRkX3JlbmRlcl9jYWxsYmFjayk7XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXN0cm95X2NvbXBvbmVudChjb21wb25lbnQsIGRldGFjaGluZykge1xuXHRjb25zdCAkJCA9IGNvbXBvbmVudC4kJDtcblx0aWYgKCQkLmZyYWdtZW50ICE9PSBudWxsKSB7XG5cdFx0Zmx1c2hfcmVuZGVyX2NhbGxiYWNrcygkJC5hZnRlcl91cGRhdGUpO1xuXHRcdHJ1bl9hbGwoJCQub25fZGVzdHJveSk7XG5cdFx0JCQuZnJhZ21lbnQgJiYgJCQuZnJhZ21lbnQuZChkZXRhY2hpbmcpO1xuXHRcdC8vIFRPRE8gbnVsbCBvdXQgb3RoZXIgcmVmcywgaW5jbHVkaW5nIGNvbXBvbmVudC4kJCAoYnV0IG5lZWQgdG9cblx0XHQvLyBwcmVzZXJ2ZSBmaW5hbCBzdGF0ZT8pXG5cdFx0JCQub25fZGVzdHJveSA9ICQkLmZyYWdtZW50ID0gbnVsbDtcblx0XHQkJC5jdHggPSBbXTtcblx0fVxufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5mdW5jdGlvbiBtYWtlX2RpcnR5KGNvbXBvbmVudCwgaSkge1xuXHRpZiAoY29tcG9uZW50LiQkLmRpcnR5WzBdID09PSAtMSkge1xuXHRcdGRpcnR5X2NvbXBvbmVudHMucHVzaChjb21wb25lbnQpO1xuXHRcdHNjaGVkdWxlX3VwZGF0ZSgpO1xuXHRcdGNvbXBvbmVudC4kJC5kaXJ0eS5maWxsKDApO1xuXHR9XG5cdGNvbXBvbmVudC4kJC5kaXJ0eVsoaSAvIDMxKSB8IDBdIHw9IDEgPDwgaSAlIDMxO1xufVxuXG4vLyBUT0RPOiBEb2N1bWVudCB0aGUgb3RoZXIgcGFyYW1zXG4vKipcbiAqIEBwYXJhbSB7U3ZlbHRlQ29tcG9uZW50fSBjb21wb25lbnRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3B1YmxpYy5qcycpLkNvbXBvbmVudENvbnN0cnVjdG9yT3B0aW9uc30gb3B0aW9uc1xuICpcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3V0aWxzLmpzJylbJ25vdF9lcXVhbCddfSBub3RfZXF1YWwgVXNlZCB0byBjb21wYXJlIHByb3BzIGFuZCBzdGF0ZSB2YWx1ZXMuXG4gKiBAcGFyYW0geyh0YXJnZXQ6IEVsZW1lbnQgfCBTaGFkb3dSb290KSA9PiB2b2lkfSBbYXBwZW5kX3N0eWxlc10gRnVuY3Rpb24gdGhhdCBhcHBlbmRzIHN0eWxlcyB0byB0aGUgRE9NIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBmaXJzdCBpbml0aWFsaXNlZC5cbiAqIFRoaXMgd2lsbCBiZSB0aGUgYGFkZF9jc3NgIGZ1bmN0aW9uIGZyb20gdGhlIGNvbXBpbGVkIGNvbXBvbmVudC5cbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluaXQoXG5cdGNvbXBvbmVudCxcblx0b3B0aW9ucyxcblx0aW5zdGFuY2UsXG5cdGNyZWF0ZV9mcmFnbWVudCxcblx0bm90X2VxdWFsLFxuXHRwcm9wcyxcblx0YXBwZW5kX3N0eWxlcyA9IG51bGwsXG5cdGRpcnR5ID0gWy0xXVxuKSB7XG5cdGNvbnN0IHBhcmVudF9jb21wb25lbnQgPSBjdXJyZW50X2NvbXBvbmVudDtcblx0c2V0X2N1cnJlbnRfY29tcG9uZW50KGNvbXBvbmVudCk7XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL3ByaXZhdGUuanMnKS5UJCR9ICovXG5cdGNvbnN0ICQkID0gKGNvbXBvbmVudC4kJCA9IHtcblx0XHRmcmFnbWVudDogbnVsbCxcblx0XHRjdHg6IFtdLFxuXHRcdC8vIHN0YXRlXG5cdFx0cHJvcHMsXG5cdFx0dXBkYXRlOiBub29wLFxuXHRcdG5vdF9lcXVhbCxcblx0XHRib3VuZDogYmxhbmtfb2JqZWN0KCksXG5cdFx0Ly8gbGlmZWN5Y2xlXG5cdFx0b25fbW91bnQ6IFtdLFxuXHRcdG9uX2Rlc3Ryb3k6IFtdLFxuXHRcdG9uX2Rpc2Nvbm5lY3Q6IFtdLFxuXHRcdGJlZm9yZV91cGRhdGU6IFtdLFxuXHRcdGFmdGVyX3VwZGF0ZTogW10sXG5cdFx0Y29udGV4dDogbmV3IE1hcChvcHRpb25zLmNvbnRleHQgfHwgKHBhcmVudF9jb21wb25lbnQgPyBwYXJlbnRfY29tcG9uZW50LiQkLmNvbnRleHQgOiBbXSkpLFxuXHRcdC8vIGV2ZXJ5dGhpbmcgZWxzZVxuXHRcdGNhbGxiYWNrczogYmxhbmtfb2JqZWN0KCksXG5cdFx0ZGlydHksXG5cdFx0c2tpcF9ib3VuZDogZmFsc2UsXG5cdFx0cm9vdDogb3B0aW9ucy50YXJnZXQgfHwgcGFyZW50X2NvbXBvbmVudC4kJC5yb290XG5cdH0pO1xuXHRhcHBlbmRfc3R5bGVzICYmIGFwcGVuZF9zdHlsZXMoJCQucm9vdCk7XG5cdGxldCByZWFkeSA9IGZhbHNlO1xuXHQkJC5jdHggPSBpbnN0YW5jZVxuXHRcdD8gaW5zdGFuY2UoY29tcG9uZW50LCBvcHRpb25zLnByb3BzIHx8IHt9LCAoaSwgcmV0LCAuLi5yZXN0KSA9PiB7XG5cdFx0XHRcdGNvbnN0IHZhbHVlID0gcmVzdC5sZW5ndGggPyByZXN0WzBdIDogcmV0O1xuXHRcdFx0XHRpZiAoJCQuY3R4ICYmIG5vdF9lcXVhbCgkJC5jdHhbaV0sICgkJC5jdHhbaV0gPSB2YWx1ZSkpKSB7XG5cdFx0XHRcdFx0aWYgKCEkJC5za2lwX2JvdW5kICYmICQkLmJvdW5kW2ldKSAkJC5ib3VuZFtpXSh2YWx1ZSk7XG5cdFx0XHRcdFx0aWYgKHJlYWR5KSBtYWtlX2RpcnR5KGNvbXBvbmVudCwgaSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHQgIH0pXG5cdFx0OiBbXTtcblx0JCQudXBkYXRlKCk7XG5cdHJlYWR5ID0gdHJ1ZTtcblx0cnVuX2FsbCgkJC5iZWZvcmVfdXBkYXRlKTtcblx0Ly8gYGZhbHNlYCBhcyBhIHNwZWNpYWwgY2FzZSBvZiBubyBET00gY29tcG9uZW50XG5cdCQkLmZyYWdtZW50ID0gY3JlYXRlX2ZyYWdtZW50ID8gY3JlYXRlX2ZyYWdtZW50KCQkLmN0eCkgOiBmYWxzZTtcblx0aWYgKG9wdGlvbnMudGFyZ2V0KSB7XG5cdFx0aWYgKG9wdGlvbnMuaHlkcmF0ZSkge1xuXHRcdFx0c3RhcnRfaHlkcmF0aW5nKCk7XG5cdFx0XHQvLyBUT0RPOiB3aGF0IGlzIHRoZSBjb3JyZWN0IHR5cGUgaGVyZT9cblx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRcdGNvbnN0IG5vZGVzID0gY2hpbGRyZW4ob3B0aW9ucy50YXJnZXQpO1xuXHRcdFx0JCQuZnJhZ21lbnQgJiYgJCQuZnJhZ21lbnQubChub2Rlcyk7XG5cdFx0XHRub2Rlcy5mb3JFYWNoKGRldGFjaCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG5cdFx0XHQkJC5mcmFnbWVudCAmJiAkJC5mcmFnbWVudC5jKCk7XG5cdFx0fVxuXHRcdGlmIChvcHRpb25zLmludHJvKSB0cmFuc2l0aW9uX2luKGNvbXBvbmVudC4kJC5mcmFnbWVudCk7XG5cdFx0bW91bnRfY29tcG9uZW50KGNvbXBvbmVudCwgb3B0aW9ucy50YXJnZXQsIG9wdGlvbnMuYW5jaG9yKTtcblx0XHRlbmRfaHlkcmF0aW5nKCk7XG5cdFx0Zmx1c2goKTtcblx0fVxuXHRzZXRfY3VycmVudF9jb21wb25lbnQocGFyZW50X2NvbXBvbmVudCk7XG59XG5cbmV4cG9ydCBsZXQgU3ZlbHRlRWxlbWVudDtcblxuaWYgKHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRTdmVsdGVFbGVtZW50ID0gY2xhc3MgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG5cdFx0LyoqIFRoZSBTdmVsdGUgY29tcG9uZW50IGNvbnN0cnVjdG9yICovXG5cdFx0JCRjdG9yO1xuXHRcdC8qKiBTbG90cyAqL1xuXHRcdCQkcztcblx0XHQvKiogVGhlIFN2ZWx0ZSBjb21wb25lbnQgaW5zdGFuY2UgKi9cblx0XHQkJGM7XG5cdFx0LyoqIFdoZXRoZXIgb3Igbm90IHRoZSBjdXN0b20gZWxlbWVudCBpcyBjb25uZWN0ZWQgKi9cblx0XHQkJGNuID0gZmFsc2U7XG5cdFx0LyoqIENvbXBvbmVudCBwcm9wcyBkYXRhICovXG5cdFx0JCRkID0ge307XG5cdFx0LyoqIGB0cnVlYCBpZiBjdXJyZW50bHkgaW4gdGhlIHByb2Nlc3Mgb2YgcmVmbGVjdGluZyBjb21wb25lbnQgcHJvcHMgYmFjayB0byBhdHRyaWJ1dGVzICovXG5cdFx0JCRyID0gZmFsc2U7XG5cdFx0LyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBDdXN0b21FbGVtZW50UHJvcERlZmluaXRpb24+fSBQcm9wcyBkZWZpbml0aW9uIChuYW1lLCByZWZsZWN0ZWQsIHR5cGUgZXRjKSAqL1xuXHRcdCQkcF9kID0ge307XG5cdFx0LyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBGdW5jdGlvbltdPn0gRXZlbnQgbGlzdGVuZXJzICovXG5cdFx0JCRsID0ge307XG5cdFx0LyoqIEB0eXBlIHtNYXA8RnVuY3Rpb24sIEZ1bmN0aW9uPn0gRXZlbnQgbGlzdGVuZXIgdW5zdWJzY3JpYmUgZnVuY3Rpb25zICovXG5cdFx0JCRsX3UgPSBuZXcgTWFwKCk7XG5cblx0XHRjb25zdHJ1Y3RvcigkJGNvbXBvbmVudEN0b3IsICQkc2xvdHMsIHVzZV9zaGFkb3dfZG9tKSB7XG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0dGhpcy4kJGN0b3IgPSAkJGNvbXBvbmVudEN0b3I7XG5cdFx0XHR0aGlzLiQkcyA9ICQkc2xvdHM7XG5cdFx0XHRpZiAodXNlX3NoYWRvd19kb20pIHtcblx0XHRcdFx0dGhpcy5hdHRhY2hTaGFkb3coeyBtb2RlOiAnb3BlbicgfSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0YWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuXHRcdFx0Ly8gV2UgY2FuJ3QgZGV0ZXJtaW5lIHVwZnJvbnQgaWYgdGhlIGV2ZW50IGlzIGEgY3VzdG9tIGV2ZW50IG9yIG5vdCwgc28gd2UgaGF2ZSB0b1xuXHRcdFx0Ly8gbGlzdGVuIHRvIGJvdGguIElmIHNvbWVvbmUgdXNlcyBhIGN1c3RvbSBldmVudCB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgYSByZWd1bGFyXG5cdFx0XHQvLyBicm93c2VyIGV2ZW50LCB0aGlzIGZpcmVzIHR3aWNlIC0gd2UgY2FuJ3QgYXZvaWQgdGhhdC5cblx0XHRcdHRoaXMuJCRsW3R5cGVdID0gdGhpcy4kJGxbdHlwZV0gfHwgW107XG5cdFx0XHR0aGlzLiQkbFt0eXBlXS5wdXNoKGxpc3RlbmVyKTtcblx0XHRcdGlmICh0aGlzLiQkYykge1xuXHRcdFx0XHRjb25zdCB1bnN1YiA9IHRoaXMuJCRjLiRvbih0eXBlLCBsaXN0ZW5lcik7XG5cdFx0XHRcdHRoaXMuJCRsX3Uuc2V0KGxpc3RlbmVyLCB1bnN1Yik7XG5cdFx0XHR9XG5cdFx0XHRzdXBlci5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKTtcblx0XHR9XG5cblx0XHRyZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG5cdFx0XHRzdXBlci5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKTtcblx0XHRcdGlmICh0aGlzLiQkYykge1xuXHRcdFx0XHRjb25zdCB1bnN1YiA9IHRoaXMuJCRsX3UuZ2V0KGxpc3RlbmVyKTtcblx0XHRcdFx0aWYgKHVuc3ViKSB7XG5cdFx0XHRcdFx0dW5zdWIoKTtcblx0XHRcdFx0XHR0aGlzLiQkbF91LmRlbGV0ZShsaXN0ZW5lcik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLiQkbFt0eXBlXSkge1xuXHRcdFx0XHRjb25zdCBpZHggPSB0aGlzLiQkbFt0eXBlXS5pbmRleE9mKGxpc3RlbmVyKTtcblx0XHRcdFx0aWYgKGlkeCA+PSAwKSB7XG5cdFx0XHRcdFx0dGhpcy4kJGxbdHlwZV0uc3BsaWNlKGlkeCwgMSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRhc3luYyBjb25uZWN0ZWRDYWxsYmFjaygpIHtcblx0XHRcdHRoaXMuJCRjbiA9IHRydWU7XG5cdFx0XHRpZiAoIXRoaXMuJCRjKSB7XG5cdFx0XHRcdC8vIFdlIHdhaXQgb25lIHRpY2sgdG8gbGV0IHBvc3NpYmxlIGNoaWxkIHNsb3QgZWxlbWVudHMgYmUgY3JlYXRlZC9tb3VudGVkXG5cdFx0XHRcdGF3YWl0IFByb21pc2UucmVzb2x2ZSgpO1xuXHRcdFx0XHRpZiAoIXRoaXMuJCRjbiB8fCB0aGlzLiQkYykge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRmdW5jdGlvbiBjcmVhdGVfc2xvdChuYW1lKSB7XG5cdFx0XHRcdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdFx0XHRcdGxldCBub2RlO1xuXHRcdFx0XHRcdFx0Y29uc3Qgb2JqID0ge1xuXHRcdFx0XHRcdFx0XHRjOiBmdW5jdGlvbiBjcmVhdGUoKSB7XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW1lbnQoJ3Nsb3QnKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAobmFtZSAhPT0gJ2RlZmF1bHQnKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRhdHRyKG5vZGUsICduYW1lJywgbmFtZSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHQvKipcblx0XHRcdFx0XHRcdFx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0XG5cdFx0XHRcdFx0XHRcdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IFthbmNob3JdXG5cdFx0XHRcdFx0XHRcdCAqL1xuXHRcdFx0XHRcdFx0XHRtOiBmdW5jdGlvbiBtb3VudCh0YXJnZXQsIGFuY2hvcikge1xuXHRcdFx0XHRcdFx0XHRcdGluc2VydCh0YXJnZXQsIG5vZGUsIGFuY2hvcik7XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGQ6IGZ1bmN0aW9uIGRlc3Ryb3koZGV0YWNoaW5nKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGRldGFjaGluZykge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGV0YWNoKG5vZGUpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdHJldHVybiBvYmo7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb25zdCAkJHNsb3RzID0ge307XG5cdFx0XHRcdGNvbnN0IGV4aXN0aW5nX3Nsb3RzID0gZ2V0X2N1c3RvbV9lbGVtZW50c19zbG90cyh0aGlzKTtcblx0XHRcdFx0Zm9yIChjb25zdCBuYW1lIG9mIHRoaXMuJCRzKSB7XG5cdFx0XHRcdFx0aWYgKG5hbWUgaW4gZXhpc3Rpbmdfc2xvdHMpIHtcblx0XHRcdFx0XHRcdCQkc2xvdHNbbmFtZV0gPSBbY3JlYXRlX3Nsb3QobmFtZSldO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKGNvbnN0IGF0dHJpYnV0ZSBvZiB0aGlzLmF0dHJpYnV0ZXMpIHtcblx0XHRcdFx0XHQvLyB0aGlzLiQkZGF0YSB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgdGhpcy5hdHRyaWJ1dGVzXG5cdFx0XHRcdFx0Y29uc3QgbmFtZSA9IHRoaXMuJCRnX3AoYXR0cmlidXRlLm5hbWUpO1xuXHRcdFx0XHRcdGlmICghKG5hbWUgaW4gdGhpcy4kJGQpKSB7XG5cdFx0XHRcdFx0XHR0aGlzLiQkZFtuYW1lXSA9IGdldF9jdXN0b21fZWxlbWVudF92YWx1ZShuYW1lLCBhdHRyaWJ1dGUudmFsdWUsIHRoaXMuJCRwX2QsICd0b1Byb3AnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gUG9ydCBvdmVyIHByb3BzIHRoYXQgd2VyZSBzZXQgcHJvZ3JhbW1hdGljYWxseSBiZWZvcmUgY2Ugd2FzIGluaXRpYWxpemVkXG5cdFx0XHRcdGZvciAoY29uc3Qga2V5IGluIHRoaXMuJCRwX2QpIHtcblx0XHRcdFx0XHRpZiAoIShrZXkgaW4gdGhpcy4kJGQpICYmIHRoaXNba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHR0aGlzLiQkZFtrZXldID0gdGhpc1trZXldOyAvLyBkb24ndCB0cmFuc2Zvcm0sIHRoZXNlIHdlcmUgc2V0IHRocm91Z2ggSmF2YVNjcmlwdFxuXHRcdFx0XHRcdFx0ZGVsZXRlIHRoaXNba2V5XTsgLy8gcmVtb3ZlIHRoZSBwcm9wZXJ0eSB0aGF0IHNoYWRvd3MgdGhlIGdldHRlci9zZXR0ZXJcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy4kJGMgPSBuZXcgdGhpcy4kJGN0b3Ioe1xuXHRcdFx0XHRcdHRhcmdldDogdGhpcy5zaGFkb3dSb290IHx8IHRoaXMsXG5cdFx0XHRcdFx0cHJvcHM6IHtcblx0XHRcdFx0XHRcdC4uLnRoaXMuJCRkLFxuXHRcdFx0XHRcdFx0JCRzbG90cyxcblx0XHRcdFx0XHRcdCQkc2NvcGU6IHtcblx0XHRcdFx0XHRcdFx0Y3R4OiBbXVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Ly8gUmVmbGVjdCBjb21wb25lbnQgcHJvcHMgYXMgYXR0cmlidXRlc1xuXHRcdFx0XHRjb25zdCByZWZsZWN0X2F0dHJpYnV0ZXMgPSAoKSA9PiB7XG5cdFx0XHRcdFx0dGhpcy4kJHIgPSB0cnVlO1xuXHRcdFx0XHRcdGZvciAoY29uc3Qga2V5IGluIHRoaXMuJCRwX2QpIHtcblx0XHRcdFx0XHRcdHRoaXMuJCRkW2tleV0gPSB0aGlzLiQkYy4kJC5jdHhbdGhpcy4kJGMuJCQucHJvcHNba2V5XV07XG5cdFx0XHRcdFx0XHRpZiAodGhpcy4kJHBfZFtrZXldLnJlZmxlY3QpIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgYXR0cmlidXRlX3ZhbHVlID0gZ2V0X2N1c3RvbV9lbGVtZW50X3ZhbHVlKFxuXHRcdFx0XHRcdFx0XHRcdGtleSxcblx0XHRcdFx0XHRcdFx0XHR0aGlzLiQkZFtrZXldLFxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuJCRwX2QsXG5cdFx0XHRcdFx0XHRcdFx0J3RvQXR0cmlidXRlJ1xuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRpZiAoYXR0cmlidXRlX3ZhbHVlID09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnJlbW92ZUF0dHJpYnV0ZSh0aGlzLiQkcF9kW2tleV0uYXR0cmlidXRlIHx8IGtleSk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUodGhpcy4kJHBfZFtrZXldLmF0dHJpYnV0ZSB8fCBrZXksIGF0dHJpYnV0ZV92YWx1ZSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy4kJHIgPSBmYWxzZTtcblx0XHRcdFx0fTtcblx0XHRcdFx0dGhpcy4kJGMuJCQuYWZ0ZXJfdXBkYXRlLnB1c2gocmVmbGVjdF9hdHRyaWJ1dGVzKTtcblx0XHRcdFx0cmVmbGVjdF9hdHRyaWJ1dGVzKCk7IC8vIG9uY2UgaW5pdGlhbGx5IGJlY2F1c2UgYWZ0ZXJfdXBkYXRlIGlzIGFkZGVkIHRvbyBsYXRlIGZvciBmaXJzdCByZW5kZXJcblxuXHRcdFx0XHRmb3IgKGNvbnN0IHR5cGUgaW4gdGhpcy4kJGwpIHtcblx0XHRcdFx0XHRmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuJCRsW3R5cGVdKSB7XG5cdFx0XHRcdFx0XHRjb25zdCB1bnN1YiA9IHRoaXMuJCRjLiRvbih0eXBlLCBsaXN0ZW5lcik7XG5cdFx0XHRcdFx0XHR0aGlzLiQkbF91LnNldChsaXN0ZW5lciwgdW5zdWIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLiQkbCA9IHt9O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFdlIGRvbid0IG5lZWQgdGhpcyB3aGVuIHdvcmtpbmcgd2l0aGluIFN2ZWx0ZSBjb2RlLCBidXQgZm9yIGNvbXBhdGliaWxpdHkgb2YgcGVvcGxlIHVzaW5nIHRoaXMgb3V0c2lkZSBvZiBTdmVsdGVcblx0XHQvLyBhbmQgc2V0dGluZyBhdHRyaWJ1dGVzIHRocm91Z2ggc2V0QXR0cmlidXRlIGV0YywgdGhpcyBpcyBoZWxwZnVsXG5cdFx0YXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGF0dHIsIF9vbGRWYWx1ZSwgbmV3VmFsdWUpIHtcblx0XHRcdGlmICh0aGlzLiQkcikgcmV0dXJuO1xuXHRcdFx0YXR0ciA9IHRoaXMuJCRnX3AoYXR0cik7XG5cdFx0XHR0aGlzLiQkZFthdHRyXSA9IGdldF9jdXN0b21fZWxlbWVudF92YWx1ZShhdHRyLCBuZXdWYWx1ZSwgdGhpcy4kJHBfZCwgJ3RvUHJvcCcpO1xuXHRcdFx0dGhpcy4kJGM/LiRzZXQoeyBbYXR0cl06IHRoaXMuJCRkW2F0dHJdIH0pO1xuXHRcdH1cblxuXHRcdGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuXHRcdFx0dGhpcy4kJGNuID0gZmFsc2U7XG5cdFx0XHQvLyBJbiBhIG1pY3JvdGFzaywgYmVjYXVzZSB0aGlzIGNvdWxkIGJlIGEgbW92ZSB3aXRoaW4gdGhlIERPTVxuXHRcdFx0UHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG5cdFx0XHRcdGlmICghdGhpcy4kJGNuICYmIHRoaXMuJCRjKSB7XG5cdFx0XHRcdFx0dGhpcy4kJGMuJGRlc3Ryb3koKTtcblx0XHRcdFx0XHR0aGlzLiQkYyA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0JCRnX3AoYXR0cmlidXRlX25hbWUpIHtcblx0XHRcdHJldHVybiAoXG5cdFx0XHRcdE9iamVjdC5rZXlzKHRoaXMuJCRwX2QpLmZpbmQoXG5cdFx0XHRcdFx0KGtleSkgPT5cblx0XHRcdFx0XHRcdHRoaXMuJCRwX2Rba2V5XS5hdHRyaWJ1dGUgPT09IGF0dHJpYnV0ZV9uYW1lIHx8XG5cdFx0XHRcdFx0XHQoIXRoaXMuJCRwX2Rba2V5XS5hdHRyaWJ1dGUgJiYga2V5LnRvTG93ZXJDYXNlKCkgPT09IGF0dHJpYnV0ZV9uYW1lKVxuXHRcdFx0XHQpIHx8IGF0dHJpYnV0ZV9uYW1lXG5cdFx0XHQpO1xuXHRcdH1cblx0fTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcFxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIEN1c3RvbUVsZW1lbnRQcm9wRGVmaW5pdGlvbj59IHByb3BzX2RlZmluaXRpb25cbiAqIEBwYXJhbSB7J3RvQXR0cmlidXRlJyB8ICd0b1Byb3AnfSBbdHJhbnNmb3JtXVxuICovXG5mdW5jdGlvbiBnZXRfY3VzdG9tX2VsZW1lbnRfdmFsdWUocHJvcCwgdmFsdWUsIHByb3BzX2RlZmluaXRpb24sIHRyYW5zZm9ybSkge1xuXHRjb25zdCB0eXBlID0gcHJvcHNfZGVmaW5pdGlvbltwcm9wXT8udHlwZTtcblx0dmFsdWUgPSB0eXBlID09PSAnQm9vbGVhbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbicgPyB2YWx1ZSAhPSBudWxsIDogdmFsdWU7XG5cdGlmICghdHJhbnNmb3JtIHx8ICFwcm9wc19kZWZpbml0aW9uW3Byb3BdKSB7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9IGVsc2UgaWYgKHRyYW5zZm9ybSA9PT0gJ3RvQXR0cmlidXRlJykge1xuXHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0Y2FzZSAnT2JqZWN0Jzpcblx0XHRcdGNhc2UgJ0FycmF5Jzpcblx0XHRcdFx0cmV0dXJuIHZhbHVlID09IG51bGwgPyBudWxsIDogSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuXHRcdFx0Y2FzZSAnQm9vbGVhbic6XG5cdFx0XHRcdHJldHVybiB2YWx1ZSA/ICcnIDogbnVsbDtcblx0XHRcdGNhc2UgJ051bWJlcic6XG5cdFx0XHRcdHJldHVybiB2YWx1ZSA9PSBudWxsID8gbnVsbCA6IHZhbHVlO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdGNhc2UgJ09iamVjdCc6XG5cdFx0XHRjYXNlICdBcnJheSc6XG5cdFx0XHRcdHJldHVybiB2YWx1ZSAmJiBKU09OLnBhcnNlKHZhbHVlKTtcblx0XHRcdGNhc2UgJ0Jvb2xlYW4nOlxuXHRcdFx0XHRyZXR1cm4gdmFsdWU7IC8vIGNvbnZlcnNpb24gYWxyZWFkeSBoYW5kbGVkIGFib3ZlXG5cdFx0XHRjYXNlICdOdW1iZXInOlxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgIT0gbnVsbCA/ICt2YWx1ZSA6IHZhbHVlO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICpcbiAqIFR1cm4gYSBTdmVsdGUgY29tcG9uZW50IGludG8gYSBjdXN0b20gZWxlbWVudC5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3B1YmxpYy5qcycpLkNvbXBvbmVudFR5cGV9IENvbXBvbmVudCAgQSBTdmVsdGUgY29tcG9uZW50IGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIEN1c3RvbUVsZW1lbnRQcm9wRGVmaW5pdGlvbj59IHByb3BzX2RlZmluaXRpb24gIFRoZSBwcm9wcyB0byBvYnNlcnZlXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBzbG90cyAgVGhlIHNsb3RzIHRvIGNyZWF0ZVxuICogQHBhcmFtIHtzdHJpbmdbXX0gYWNjZXNzb3JzICBPdGhlciBhY2Nlc3NvcnMgYmVzaWRlcyB0aGUgb25lcyBmb3IgcHJvcHMgdGhlIGNvbXBvbmVudCBoYXNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdXNlX3NoYWRvd19kb20gIFdoZXRoZXIgdG8gdXNlIHNoYWRvdyBET01cbiAqIEBwYXJhbSB7KGNlOiBuZXcgKCkgPT4gSFRNTEVsZW1lbnQpID0+IG5ldyAoKSA9PiBIVE1MRWxlbWVudH0gW2V4dGVuZF1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZV9jdXN0b21fZWxlbWVudChcblx0Q29tcG9uZW50LFxuXHRwcm9wc19kZWZpbml0aW9uLFxuXHRzbG90cyxcblx0YWNjZXNzb3JzLFxuXHR1c2Vfc2hhZG93X2RvbSxcblx0ZXh0ZW5kXG4pIHtcblx0bGV0IENsYXNzID0gY2xhc3MgZXh0ZW5kcyBTdmVsdGVFbGVtZW50IHtcblx0XHRjb25zdHJ1Y3RvcigpIHtcblx0XHRcdHN1cGVyKENvbXBvbmVudCwgc2xvdHMsIHVzZV9zaGFkb3dfZG9tKTtcblx0XHRcdHRoaXMuJCRwX2QgPSBwcm9wc19kZWZpbml0aW9uO1xuXHRcdH1cblx0XHRzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcblx0XHRcdHJldHVybiBPYmplY3Qua2V5cyhwcm9wc19kZWZpbml0aW9uKS5tYXAoKGtleSkgPT5cblx0XHRcdFx0KHByb3BzX2RlZmluaXRpb25ba2V5XS5hdHRyaWJ1dGUgfHwga2V5KS50b0xvd2VyQ2FzZSgpXG5cdFx0XHQpO1xuXHRcdH1cblx0fTtcblx0T2JqZWN0LmtleXMocHJvcHNfZGVmaW5pdGlvbikuZm9yRWFjaCgocHJvcCkgPT4ge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDbGFzcy5wcm90b3R5cGUsIHByb3AsIHtcblx0XHRcdGdldCgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuJCRjICYmIHByb3AgaW4gdGhpcy4kJGMgPyB0aGlzLiQkY1twcm9wXSA6IHRoaXMuJCRkW3Byb3BdO1xuXHRcdFx0fSxcblx0XHRcdHNldCh2YWx1ZSkge1xuXHRcdFx0XHR2YWx1ZSA9IGdldF9jdXN0b21fZWxlbWVudF92YWx1ZShwcm9wLCB2YWx1ZSwgcHJvcHNfZGVmaW5pdGlvbik7XG5cdFx0XHRcdHRoaXMuJCRkW3Byb3BdID0gdmFsdWU7XG5cdFx0XHRcdHRoaXMuJCRjPy4kc2V0KHsgW3Byb3BdOiB2YWx1ZSB9KTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG5cdGFjY2Vzc29ycy5mb3JFYWNoKChhY2Nlc3NvcikgPT4ge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDbGFzcy5wcm90b3R5cGUsIGFjY2Vzc29yLCB7XG5cdFx0XHRnZXQoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLiQkYz8uW2FjY2Vzc29yXTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG5cdGlmIChleHRlbmQpIHtcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yIC0gYXNzaWduaW5nIGhlcmUgaXMgZmluZVxuXHRcdENsYXNzID0gZXh0ZW5kKENsYXNzKTtcblx0fVxuXHRDb21wb25lbnQuZWxlbWVudCA9IC8qKiBAdHlwZSB7YW55fSAqLyAoQ2xhc3MpO1xuXHRyZXR1cm4gQ2xhc3M7XG59XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgU3ZlbHRlIGNvbXBvbmVudHMuIFVzZWQgd2hlbiBkZXY9ZmFsc2UuXG4gKlxuICogQHRlbXBsYXRlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBbUHJvcHM9YW55XVxuICogQHRlbXBsYXRlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBbRXZlbnRzPWFueV1cbiAqL1xuZXhwb3J0IGNsYXNzIFN2ZWx0ZUNvbXBvbmVudCB7XG5cdC8qKlxuXHQgKiAjIyMgUFJJVkFURSBBUElcblx0ICpcblx0ICogRG8gbm90IHVzZSwgbWF5IGNoYW5nZSBhdCBhbnkgdGltZVxuXHQgKlxuXHQgKiBAdHlwZSB7YW55fVxuXHQgKi9cblx0JCQgPSB1bmRlZmluZWQ7XG5cdC8qKlxuXHQgKiAjIyMgUFJJVkFURSBBUElcblx0ICpcblx0ICogRG8gbm90IHVzZSwgbWF5IGNoYW5nZSBhdCBhbnkgdGltZVxuXHQgKlxuXHQgKiBAdHlwZSB7YW55fVxuXHQgKi9cblx0JCRzZXQgPSB1bmRlZmluZWQ7XG5cblx0LyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuXHQkZGVzdHJveSgpIHtcblx0XHRkZXN0cm95X2NvbXBvbmVudCh0aGlzLCAxKTtcblx0XHR0aGlzLiRkZXN0cm95ID0gbm9vcDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAdGVtcGxhdGUge0V4dHJhY3Q8a2V5b2YgRXZlbnRzLCBzdHJpbmc+fSBLXG5cdCAqIEBwYXJhbSB7S30gdHlwZVxuXHQgKiBAcGFyYW0geygoZTogRXZlbnRzW0tdKSA9PiB2b2lkKSB8IG51bGwgfCB1bmRlZmluZWR9IGNhbGxiYWNrXG5cdCAqIEByZXR1cm5zIHsoKSA9PiB2b2lkfVxuXHQgKi9cblx0JG9uKHR5cGUsIGNhbGxiYWNrKSB7XG5cdFx0aWYgKCFpc19mdW5jdGlvbihjYWxsYmFjaykpIHtcblx0XHRcdHJldHVybiBub29wO1xuXHRcdH1cblx0XHRjb25zdCBjYWxsYmFja3MgPSB0aGlzLiQkLmNhbGxiYWNrc1t0eXBlXSB8fCAodGhpcy4kJC5jYWxsYmFja3NbdHlwZV0gPSBbXSk7XG5cdFx0Y2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuXHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHRjb25zdCBpbmRleCA9IGNhbGxiYWNrcy5pbmRleE9mKGNhbGxiYWNrKTtcblx0XHRcdGlmIChpbmRleCAhPT0gLTEpIGNhbGxiYWNrcy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtQYXJ0aWFsPFByb3BzPn0gcHJvcHNcblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHQkc2V0KHByb3BzKSB7XG5cdFx0aWYgKHRoaXMuJCRzZXQgJiYgIWlzX2VtcHR5KHByb3BzKSkge1xuXHRcdFx0dGhpcy4kJC5za2lwX2JvdW5kID0gdHJ1ZTtcblx0XHRcdHRoaXMuJCRzZXQocHJvcHMpO1xuXHRcdFx0dGhpcy4kJC5za2lwX2JvdW5kID0gZmFsc2U7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQ3VzdG9tRWxlbWVudFByb3BEZWZpbml0aW9uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2F0dHJpYnV0ZV1cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JlZmxlY3RdXG4gKiBAcHJvcGVydHkgeydTdHJpbmcnfCdCb29sZWFuJ3wnTnVtYmVyJ3wnQXJyYXknfCdPYmplY3QnfSBbdHlwZV1cbiAqL1xuIiwgIi8vIGdlbmVyYXRlZCBkdXJpbmcgcmVsZWFzZSwgZG8gbm90IG1vZGlmeVxuXG4vKipcbiAqIFRoZSBjdXJyZW50IHZlcnNpb24sIGFzIHNldCBpbiBwYWNrYWdlLmpzb24uXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLWNvbXBpbGVyI3N2ZWx0ZS12ZXJzaW9uXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgVkVSU0lPTiA9ICc0LjIuMjAnO1xuZXhwb3J0IGNvbnN0IFBVQkxJQ19WRVJTSU9OID0gJzQnO1xuIiwgImltcG9ydCB7IFBVQkxJQ19WRVJTSU9OIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL3ZlcnNpb24uanMnO1xuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpXG5cdC8vIEB0cy1pZ25vcmVcblx0KHdpbmRvdy5fX3N2ZWx0ZSB8fCAod2luZG93Ll9fc3ZlbHRlID0geyB2OiBuZXcgU2V0KCkgfSkpLnYuYWRkKFBVQkxJQ19WRVJTSU9OKTtcbiIsICIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH1cclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19jcmVhdGVCaW5kaW5nID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcclxuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XHJcbiAgICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XHJcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59KTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgbykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBwKSkgX19jcmVhdGVCaW5kaW5nKG8sIG0sIHApO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG4vKiogQGRlcHJlY2F0ZWQgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG4vKiogQGRlcHJlY2F0ZWQgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xyXG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXHJcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgcmV0dXJuIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XHJcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcclxuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcclxuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcblxyXG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XHJcbn0pIDogZnVuY3Rpb24obywgdikge1xyXG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XHJcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0RGVmYXVsdChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZFNldChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4oc3RhdGUsIHJlY2VpdmVyKSB7XHJcbiAgICBpZiAocmVjZWl2ZXIgPT09IG51bGwgfHwgKHR5cGVvZiByZWNlaXZlciAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgcmVjZWl2ZXIgIT09IFwiZnVuY3Rpb25cIikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgdXNlICdpbicgb3BlcmF0b3Igb24gbm9uLW9iamVjdFwiKTtcclxuICAgIHJldHVybiB0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyID09PSBzdGF0ZSA6IHN0YXRlLmhhcyhyZWNlaXZlcik7XHJcbn1cclxuIiwgIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7IG9uTW91bnQsIHRpY2sgfSBmcm9tIFwic3ZlbHRlXCI7XG5cblx0ZXhwb3J0IGxldCBpc0ZpcnN0OiBib29sZWFuO1xuXHRleHBvcnQgbGV0IHJlbW92ZUlucHV0OiAoaWQ6IG51bWJlcikgPT4gdm9pZDtcblx0ZXhwb3J0IGxldCBpZDogbnVtYmVyO1xuXG5cdGV4cG9ydCBsZXQgdHlwZVZhbDogc3RyaW5nID0gXCJ0ZXh0XCI7XG5cdGV4cG9ydCBsZXQgbmFtZVZhbDogc3RyaW5nID0gXCJcIjtcblx0ZXhwb3J0IGxldCB2YWx1ZVZhbDogc3RyaW5nID0gXCJcIjtcblxuXHRsZXQgaW5wdXRFbDogSFRNTElucHV0RWxlbWVudDtcblx0bGV0IHZhbHVlRWw6IEhUTUxJbnB1dEVsZW1lbnQ7XG5cblx0bGV0IG9wdGlvblZhbDogc3RyaW5nXG5cdC8vRm9ybSBuYW1lcyB0aWVkIHRvIGlucHV0IHR5cGVzLlxuXHRjb25zdCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xuXHRcdFRleHQ6IFwic3RyaW5nXCIsXG5cdFx0TnVtYmVyOiBcIm51bWJlclwiLFxuXHRcdENoZWNrYm94OiBcImNoZWNrYm94XCIsXG5cdFx0RGF0ZTogXCJkYXRlXCIsXG5cdFx0RGF0ZXRpbWU6IFwiZGF0ZXRpbWUtbG9jYWxcIixcblx0fTtcblx0Ly9NYXRjaCBPYnNpZGlhbiBkYXRhIHR5cGVzIHRvIGZvcm0gbmFtZXMuXG5cdGNvbnN0IGNvbnZlcnRQcm9wczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcblx0XHR0ZXh0OiBcIlRleHRcIixcblx0XHRtdWx0aXRleHQ6IFwiVGV4dFwiLFxuXHRcdG51bWJlcjogXCJOdW1iZXJcIixcblx0XHRjaGVja2JveDogXCJDaGVja2JveFwiLFxuXHRcdGRhdGU6IFwiRGF0ZVwiLFxuXHRcdGRhdGV0aW1lOiBcIkRhdGV0aW1lXCJcblx0fVxuXG5cdG9uTW91bnQoYXN5bmMgKCkgPT4ge1xuXHRcdGF3YWl0IHRpY2soKTsgIC8vRm9jdXMgd29uJ3Qgd29yayByaWdodCB3aXRob3V0IHRpY2soKS5cblx0XHRpbnB1dEVsLmZvY3VzKCk7XG5cdFx0aW5wdXRFbC5zZWxlY3QoKTtcblxuXHRcdG9wdGlvblZhbCA9IG9wdGlvbnNbY29udmVydFByb3BzW3R5cGVWYWxdXSAgLy9Mb2FkIGRlZmF1bHQgdHlwZS5cblxuXHR9KTtcblxuXHRmdW5jdGlvbiBjaGFuZ2VUeXBlKHR5cGU6IHN0cmluZyl7XG5cdFx0dmFsdWVFbC50eXBlID0gdHlwZVxuXHR9XG48L3NjcmlwdD5cblxuPGRpdiBjbGFzcz1cIm1vZGFsLWlucHV0LWNvbnRhaW5lclwiPlxuXHQ8YnV0dG9uXG5cdFx0dHlwZT1cImJ1dHRvblwiXG5cdFx0aWQ9XCJkZWwtYnRuXCJcblx0XHRvbjpjbGljaz17KCkgPT4ge1xuXHRcdFx0aWYgKCFpc0ZpcnN0KSB7XG5cdFx0XHRcdHJlbW92ZUlucHV0KGlkKTtcblx0XHRcdH1cblx0XHR9fVxuXHRcdGNsYXNzPVwiYnRuLWRlbCB7aXNGaXJzdCA/ICdidG4taW5hY3RpdmUnIDogJyd9XCJcblx0XHR0YWJpbmRleD17aXNGaXJzdCA/IC0xIDogMH1cblx0XHQ+WDwvYnV0dG9uXG5cdD5cblx0PHNlbGVjdCBpZD1cInR5cGUtaW5wdXRcIiBjbGFzcz1cImZsZXgtb2JqXCIgYmluZDp2YWx1ZT17b3B0aW9uVmFsfSBvbjpjaGFuZ2U9eygpID0+IGNoYW5nZVR5cGUob3B0aW9uVmFsKX0+XG5cdFx0eyNlYWNoIE9iamVjdC5rZXlzKG9wdGlvbnMpIGFzIGtleX1cblx0XHRcdDxvcHRpb24gdmFsdWU9e29wdGlvbnNba2V5XX0+e2tleX08L29wdGlvbj5cblx0XHR7L2VhY2h9XG5cdDwvc2VsZWN0PlxuXHQ8aW5wdXRcblx0XHRpZD1cIm5hbWUtaW5wdXRcIlxuXHRcdGJpbmQ6dGhpcz17aW5wdXRFbH1cblx0XHRjbGFzcz1cIm5hbWUtaW5wdXQgZmxleC1vYmpcIlxuXHRcdHR5cGU9XCJ0ZXh0XCJcblx0XHRuYW1lPVwibmFtZVtdXCJcblx0XHRwbGFjZWhvbGRlcj1cIm5hbWVcIlxuXHRcdGJpbmQ6dmFsdWU9e25hbWVWYWx9XG5cdFx0cmVxdWlyZWRcblx0Lz5cblx0PGlucHV0IGJpbmQ6dGhpcz17dmFsdWVFbH1cblx0XHRpZD1cInZhbHVlLWlucHV0XCJcblx0XHR0eXBlPVwidGV4dFwiXG5cdFx0bmFtZT1cInZhbHVlW11cIlxuXHRcdHBsYWNlaG9sZGVyPVwidmFsdWVcIlxuXHRcdGJpbmQ6dmFsdWU9e3ZhbHVlVmFsfVxuXHRcdGNsYXNzPVwidmFsdWUtaW5wdXQgZmxleC1vYmpcIlxuXHQvPlxuPC9kaXY+XG5cbjxzdHlsZT5cblx0aW5wdXQge1xuXHRcdG1heC1oZWlnaHQ6IDI1cHg7XG5cdFx0b3ZlcmZsb3cteDogYXV0bztcblx0fVxuXG5cdHNlbGVjdCB7XG5cdFx0aGVpZ2h0OiAyMXB4O1xuXHR9XG5cblx0I25hbWUtaW5wdXQge1xuXHRcdGZsZXgtZ3JvdzogMDtcblx0XHR3aWR0aDogYXV0bztcblx0fVxuXG5cdC5tb2RhbC1pbnB1dC1jb250YWluZXIge1xuXHRcdHdpZHRoOiA5NSU7XG5cdFx0ZGlzcGxheTogZmxleDtcblx0XHRmbGV4LWRpcmVjdGlvbjogcm93O1xuXHRcdGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cdFx0Z2FwOiAxMHB4O1xuXHRcdG1hcmdpbi10b3A6IDEwcHg7XG5cdH1cblxuXHQuYnRuLWluYWN0aXZlIHtcblx0XHRjdXJzb3I6IG5vdC1hbGxvd2VkO1xuXHRcdHBvaW50ZXItZXZlbnRzOiBub25lO1xuXHRcdG9wYWNpdHk6IDAuNztcblx0fVxuPC9zdHlsZT5cbiIsICIvKiogUmV0dXJuIHZhbHVlIGZyb20gSFRNTCBpbnB1dCBiYXNlZCBvbiB0aGUgaW5wdXQncyB0eXBlLiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VWYWx1ZShpbnB1dDogSFRNTElucHV0RWxlbWVudCwgdHlwZTogc3RyaW5nKSB7XHJcblx0c3dpdGNoICh0eXBlKSB7XHJcblx0XHRjYXNlIFwibnVtYmVyXCI6XHJcblx0XHRcdHJldHVybiBOdW1iZXIoaW5wdXQudmFsdWUpO1xyXG5cdFx0Y2FzZSBcImNoZWNrYm94XCI6XHJcblx0XHRcdHJldHVybiBCb29sZWFuKGlucHV0LmNoZWNrZWQpO1xyXG5cdFx0ZGVmYXVsdDpcclxuXHRcdFx0cmV0dXJuIGlucHV0LnZhbHVlO1xyXG5cdH1cclxufVxyXG5cclxuLyoqIFJlbW92ZSBsZWFkaW5nIGFuZCB0cmFpbGluZyBjb21tYXMsIHRoZW4gcmVwbGFjZSBtdWx0aXBsZSBjb25zZWN1dGl2ZSBjb21tYXMgd2l0aCBhIHNpbmdsZSBjb21tYS4qL1xyXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlRXh0cmFDb21tYXMoc3RyOiBzdHJpbmcpOiBzdHJpbmcge1xyXG5cdHJldHVybiBzdHIucmVwbGFjZSgvXiwqKC4qPyksKiQvZywgXCIkMVwiKS5yZXBsYWNlKC8sezIsfS9nLCBcIixcIik7XHJcbn1cclxuXHJcbi8qKiBSZW1vdmUgYW55IGludmFsaWQgdGFnIGNoYXJhY3RlcnMgZnJvbSBzdHJpbmcuKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFuVGFncyhzdHI6IHN0cmluZykge1xyXG5cdC8vVGFrZW4gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vR29ya3ljcmVhdG9yL29ic2lkaWFuLXF1aWNrLXRhZ2dlci9cclxuXHRsZXQgY2xlYW5TdHIgPSBzdHI7XHJcblx0Zm9yIChsZXQgaW5kZXggaW4gS05PV05fQkFEX0NIQVJBQ1RFUlMpIHtcclxuXHRcdGNsZWFuU3RyID0gY2xlYW5TdHIucmVwbGFjZUFsbChLTk9XTl9CQURfQ0hBUkFDVEVSU1tpbmRleF0sIFwiXCIpO1xyXG5cdH1cclxuXHRyZXR1cm4gY2xlYW5TdHI7XHJcbn1cclxuXHJcbi8vVGFrZW4gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vR29ya3ljcmVhdG9yL29ic2lkaWFuLXF1aWNrLXRhZ2dlci8uXHJcbi8vQ29tbWFzIHJlbW92ZWQuICBXaWxsIGluc3RlYWQgYmUgaGFuZGxlZCBieSByZW1vdmVFeHRyYUNvbW1hcy5cclxuY29uc3QgS05PV05fQkFEX0NIQVJBQ1RFUlMgPSBbXHJcblx0XCJcdTIwMTJcIixcclxuXHRcIlx1MjAxM1wiLFxyXG5cdFwiXHUyMDE0XCIsXHJcblx0XCJcdTIwMTVcIixcclxuXHRcIlx1MjA0RlwiLFxyXG5cdFwiXHUyMDNEXCIsXHJcblx0XCJcdTIwMThcIixcclxuXHRcIlx1MjAxQVwiLFxyXG5cdFwiXHUyMDFCXCIsXHJcblx0XCJcdTIwMzlcIixcclxuXHRcIlx1MjAzQVwiLFxyXG5cdFwiXHUyMDFDXCIsXHJcblx0XCJcdTIwMURcIixcclxuXHRcIlx1MjAxRVwiLFxyXG5cdFwiXHUyMDFGXCIsXHJcblx0XCJcdTIwNDVcIixcclxuXHRcIlx1MjA0NlwiLFxyXG5cdFwiXHUyMDRCXCIsXHJcblx0XCJcdTIwNEVcIixcclxuXHRcIlx1MjA1MVwiLFxyXG5cdFwiXHUyMDQ0XCIsXHJcblx0XCJcdTIwNEFcIixcclxuXHRcIlx1MjAzMFwiLFxyXG5cdFwiXHUyMDMxXCIsXHJcblx0XCJcdTIwNTJcIixcclxuXHRcIlx1MjAyMFwiLFxyXG5cdFwiXHUyMDIxXCIsXHJcblx0XCJcdTIwMjJcIixcclxuXHRcIlx1MjAyM1wiLFxyXG5cdFwiXHUyMDQzXCIsXHJcblx0XCJcdTIwNENcIixcclxuXHRcIlx1MjA0RFwiLFxyXG5cdFwiXHUyMDMyXCIsXHJcblx0XCJcdTIwMzVcIixcclxuXHRcIlx1MjAzOFwiLFxyXG5cdFwiXHUyMDNCXCIsXHJcblx0XCJcdTIwNTBcIixcclxuXHRcIlx1MjA0MVwiLFxyXG5cdFwiXHUyMDQyXCIsXHJcblx0XCJcdTIwMTZcIixcclxuXHRcIlx1MjAxMVwiLFxyXG5cdFwiXHUyMDMzXCIsXHJcblx0XCJcdTIwMzRcIixcclxuXHRcIlx1MjA1N1wiLFxyXG5cdFwiXHUyMDM2XCIsXHJcblx0XCJcdTIwMzdcIixcclxuXHRcImBcIixcclxuXHRcIl5cIixcclxuXHRcIlx1MjAzRVwiLFxyXG5cdFwiXHUyMDE3XCIsXHJcblx0XCJcdTIwNTNcIixcclxuXHRcIjtcIixcclxuXHRcIjpcIixcclxuXHRcIiFcIixcclxuXHRcIlx1MjAzQ1wiLFxyXG5cdFwiXHUyMDQ5XCIsXHJcblx0XCI/XCIsXHJcblx0XCJcdTIwNDhcIixcclxuXHRcIlx1MjA0N1wiLFxyXG5cdFwiLlwiLFxyXG5cdFwiXHUyMDI0XCIsXHJcblx0XCJcdTIwMjVcIixcclxuXHRcIlx1MjAyNlwiLFxyXG5cdFwiJ1wiLFxyXG5cdCdcIicsXHJcblx0XCIoXCIsXHJcblx0XCIpXCIsXHJcblx0XCJbXCIsXHJcblx0XCJdXCIsXHJcblx0XCJ7XCIsXHJcblx0XCJ9XCIsXHJcblx0XCJAXCIsXHJcblx0XCIqXCIsXHJcblx0XCImXCIsXHJcblx0XCIlXCIsXHJcblx0XCJcdTIwNTRcIixcclxuXHRcIitcIixcclxuXHRcIjxcIixcclxuXHRcIj1cIixcclxuXHRcIj5cIixcclxuXHRcInxcIixcclxuXHRcIn5cIixcclxuXHRcIiRcIixcclxuXHRcIlx1MjA1NVwiLFxyXG5cdFwiXHUyMDU2XCIsXHJcblx0XCJcdTIwNThcIixcclxuXHRcIlx1MjA1OVwiLFxyXG5cdFwiXHUyMDVBXCIsXHJcblx0XCJcdTIwNUJcIixcclxuXHRcIlx1MjA1Q1wiLFxyXG5cdFwiXHUyMDVEXCIsXHJcblx0XCJcdTIwNUVcIixcclxuXHRcIlx1MkUwMFwiLFxyXG5cdFwiXHUyRTAxXCIsXHJcblx0XCJcdTJFMDJcIixcclxuXHRcIlx1MkUwM1wiLFxyXG5cdFwiXHUyRTA0XCIsXHJcblx0XCJcdTJFMDVcIixcclxuXHRcIlx1MkUwNlwiLFxyXG5cdFwiXHUyRTA3XCIsXHJcblx0XCJcdTJFMDhcIixcclxuXHRcIlx1MkUwOVwiLFxyXG5cdFwiXHUyRTBBXCIsXHJcblx0XCJcdTJFMEJcIixcclxuXHRcIlx1MkUwQ1wiLFxyXG5cdFwiXHUyRTBEXCIsXHJcblx0XCJcdTJFMEVcIixcclxuXHRcIlx1MkUwRlwiLFxyXG5cdFwiXHUyRTEwXCIsXHJcblx0XCJcdTJFMTFcIixcclxuXHRcIlx1MkUxMlwiLFxyXG5cdFwiXHUyRTEzXCIsXHJcblx0XCJcdTJFMTRcIixcclxuXHRcIlx1MkUxNVwiLFxyXG5cdFwiXHUyRTE2XCIsXHJcblx0XCJcdTJFMTdcIixcclxuXHRcIlx1MkUxQ1wiLFxyXG5cdFwiXHUyRTFEXCIsXHJcblx0XCIgXCIsXHJcblx0XCIjXCIsXHJcbl07XHJcbiIsICI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuICBpbXBvcnQgeyBvbk1vdW50LCB0aWNrIH0gZnJvbSBcInN2ZWx0ZVwiO1xuICBpbXBvcnQgUHJvcElucHV0IGZyb20gXCIuL0FkZFByb3BJbnB1dC5zdmVsdGVcIjtcbiAgaW1wb3J0IHsgTmV3UHJvcERhdGEgfSBmcm9tIFwiLi9tYWluXCI7XG4gIGltcG9ydCB7IGNsZWFuVGFncywgcGFyc2VWYWx1ZSwgcmVtb3ZlRXh0cmFDb21tYXMgfSBmcm9tIFwiLi9oZWxwZXJzXCI7XG4gIGltcG9ydCB0eXBlIHsgUHJvcGVydHlUeXBlcyB9IGZyb20gXCIuL3R5cGVzL2N1c3RvbVwiO1xuXG4gIGV4cG9ydCBsZXQgc3VibWlzc2lvbjogKHByb3BzOiBNYXA8c3RyaW5nLCBOZXdQcm9wRGF0YT4pID0+IHZvaWQ7XG4gIGV4cG9ydCBsZXQgb3ZlcndyaXRlOiBib29sZWFuO1xuICBleHBvcnQgbGV0IGRlbGltaXRlcjogc3RyaW5nO1xuICBleHBvcnQgbGV0IGRlZmF1bHRQcm9wczogeyBuYW1lOiBzdHJpbmc7IHZhbHVlOiBhbnk7IHR5cGU6IFByb3BlcnR5VHlwZXMgfVtdO1xuICBleHBvcnQgbGV0IGNoYW5nZUJvb2w6IChib29sOiBib29sZWFuKSA9PiB2b2lkO1xuXG4gIGxldCBjb3VudElucHV0cyA9IDA7IC8vQ291bGQgcmVwbGFjZSB3aXRoIFVVSUQuXG4gIGxldCBmb3JtRWw6IEhUTUxGb3JtRWxlbWVudDtcbiAgbGV0IGVycm9yRWw6IEhUTUxEaXZFbGVtZW50O1xuICBsZXQgYWxlcnRUZXh0ID0gXCIuXCI7XG5cbiAgbGV0IGlucHV0RWxzOiB7XG4gICAgaWQ6IG51bWJlcjtcbiAgICBpc0ZpcnN0OiBib29sZWFuO1xuICAgIHR5cGVEZWY6IFByb3BlcnR5VHlwZXM7XG4gICAgbmFtZURlZjogc3RyaW5nO1xuICAgIHZhbHVlRGVmOiBhbnk7XG4gIH1bXSA9IFtdO1xuXG4gIGZ1bmN0aW9uIG9uQ2hlY2tib3hDaGFuZ2UoKSB7XG4gICAgb3ZlcndyaXRlID0gIW92ZXJ3cml0ZTtcbiAgICBjaGFuZ2VCb29sKG92ZXJ3cml0ZSk7XG4gIH1cblxuICBvbk1vdW50KCgpID0+IHtcbiAgICBkZWZhdWx0UHJvcHMubGVuZ3RoID4gMFxuICAgICAgPyBhZGRJbnB1dHMoZGVmYXVsdFByb3BzKVxuICAgICAgOiBhZGRJbnB1dHMoW3sgdHlwZTogXCJ0ZXh0XCIsIG5hbWU6IFwiXCIsIHZhbHVlOiBcIlwiIH1dKTtcbiAgfSk7XG5cbiAgLyoqIEFkZCBuZXcgaW5wdXQgdG8gaW5wdXRFbHMgKi9cbiAgZnVuY3Rpb24gYWRkSW5wdXRzKFxuICAgIGlucHV0czogeyB0eXBlOiBQcm9wZXJ0eVR5cGVzOyBuYW1lOiBzdHJpbmc7IHZhbHVlOiBhbnkgfVtdID0gW1xuICAgICAgeyB0eXBlOiBcInRleHRcIiwgbmFtZTogXCJcIiwgdmFsdWU6IFwiXCIgfSxcbiAgICBdXG4gICkge1xuICAgIGxldCBhcnIgPSBbXTtcbiAgICBmb3IgKGxldCBpbnB1dCBvZiBpbnB1dHMpIHtcbiAgICAgIGNvdW50SW5wdXRzKys7XG4gICAgICBhcnIucHVzaCh7XG4gICAgICAgIGlkOiBjb3VudElucHV0cyxcbiAgICAgICAgaXNGaXJzdDogY291bnRJbnB1dHMgPT09IDEgPyB0cnVlIDogZmFsc2UsXG4gICAgICAgIHR5cGVEZWY6IGlucHV0LnR5cGUsXG4gICAgICAgIG5hbWVEZWY6IGlucHV0Lm5hbWUsXG4gICAgICAgIHZhbHVlRGVmOiBpbnB1dC52YWx1ZSxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpbnB1dEVscyA9IFsuLi5pbnB1dEVscywgLi4uYXJyXTtcbiAgfVxuXG4gIC8qKiBSZW1vdmUgaW5wdXQgZnJvbSBpbnB1dEVscyAqL1xuICBhc3luYyBmdW5jdGlvbiByZW1vdmVJbnB1dChpZDogbnVtYmVyKSB7XG4gICAgaW5wdXRFbHMgPSBpbnB1dEVscy5maWx0ZXIoKGlucHV0KSA9PiBpbnB1dC5pZCAhPT0gaWQpO1xuICAgIGF3YWl0IHRpY2soKTtcblxuICAgIC8vU2V0IGZvY3VzIHRvIHByZXZpb3VzIGlucHV0LlxuICAgIGxldCBpbnB1dHM6IE5vZGVMaXN0T2Y8SFRNTElucHV0RWxlbWVudD4gPSBmb3JtRWwucXVlcnlTZWxlY3RvckFsbChcImlucHV0XCIpO1xuICAgIGlmICghaW5wdXRzKSByZXR1cm47XG5cbiAgICBpbnB1dHNbaW5wdXRzLmxlbmd0aCAtIDJdLmZvY3VzKCk7XG4gIH1cblxuICAvKiogU2VlIGlmIHRoZXJlIGFyZSBkdXBsaWNhdGUgcHJvcGVydHkgbmFtZXMuKi9cbiAgZnVuY3Rpb24gY2hlY2tEdXBsaWNhdGVOYW1lcygpIHtcbiAgICBsZXQgc2V0ID0gbmV3IFNldCgpO1xuICAgIGZvciAobGV0IGlucHV0IG9mIGlucHV0RWxzKSBzZXQuYWRkKGlucHV0Lm5hbWVEZWYpO1xuXG4gICAgaWYgKHNldC5zaXplIDwgaW5wdXRFbHMubGVuZ3RoKSByZXR1cm4gdHJ1ZTtcbiAgICBlbHNlIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKiBEaXNwbGF5IGFuIGVycm9yIG1lc3NhZ2UuICovXG4gIGZ1bmN0aW9uIHJ1bkVycm9yKGVycm9yVGV4dDogc3RyaW5nKSB7XG4gICAgYWxlcnRUZXh0ID0gZXJyb3JUZXh0O1xuICAgIGVycm9yRWwuY2xhc3NMaXN0LnJlbW92ZShcImhpZGRlblwiKTsgLy9TaG91bGQgSSBoYXZlIHRoaXMgZXJyb3IgbWVzc2FnZSBmYWRlIGF3YXk/XG4gIH1cblxuICAvKiogU2VhcmNoIGZvciBhbGwgbGFiZWxzIGFuZCB2YWx1ZXMsIGFkZCB0aGVtIHRvIGEgbWFwLCB0aGVuIHBhc3MgdGhlbSBiYWNrIHRvIG1vZGFsLiovXG4gIGZ1bmN0aW9uIG9uU3VibWl0KCkge1xuICAgIC8vTWFrZSBzdXJlIHRoZXJlIGFyZSBubyBkdXBsaWNhdGUgbmFtZXMuXG4gICAgaWYgKGNoZWNrRHVwbGljYXRlTmFtZXMoKSkge1xuICAgICAgcnVuRXJyb3IoXCJEdXBsaWNhdGUgcHJvcGVydHkgbmFtZXMgYXJlIG5vdCBhbGxvd2VkLlwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgb2JqOiBNYXA8c3RyaW5nLCBOZXdQcm9wRGF0YT4gPSBuZXcgTWFwKCk7XG5cbiAgICBsZXQgaW5wdXRzOiBOb2RlTGlzdE9mPEhUTUxJbnB1dEVsZW1lbnQ+ID0gZm9ybUVsLnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAnaW5wdXRbbmFtZV49XCJuYW1lW11cIl0nXG4gICAgKTtcblxuICAgIGlucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4ge1xuICAgICAgLy9DaGVjayBmb3IgcHJvcGVyIGlucHV0cyBiZWluZyBuZXh0IHRvIGVhY2ggb3RoZXIuXG4gICAgICBpZiAoIShpbnB1dC5uZXh0RWxlbWVudFNpYmxpbmcgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50KSkgcmV0dXJuO1xuICAgICAgaWYgKCEoaW5wdXQucHJldmlvdXNFbGVtZW50U2libGluZyBpbnN0YW5jZW9mIEhUTUxTZWxlY3RFbGVtZW50KSkgcmV0dXJuO1xuICAgICAgaWYgKFxuICAgICAgICAhKGlucHV0LnByZXZpb3VzRWxlbWVudFNpYmxpbmcuY2hpbGRyZW5bMF0gaW5zdGFuY2VvZiBIVE1MT3B0aW9uRWxlbWVudClcbiAgICAgIClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgLy9UT0RPOiBJbXBsZW1lbnQgZXJyb3IgaGFuZGxpbmcgaWYgaW5wdXRzIGFyZSBpbmFjY3VyYXRlP1xuICAgICAgLy9UaGUgZW50aXJlIGZvcm0gaXMgZGVwZW5kZW50IG9uIHRoaXMgc3RydWN0dXJlLCB0aG91Z2guXG5cbiAgICAgIC8vR2V0IG5hbWUsIHZhbHVlIGFuZCB0eXBlIGZyb20gaW5wdXRzLlxuICAgICAgbGV0IG5hbWUgPSBpbnB1dC52YWx1ZTtcbiAgICAgIGlmIChuYW1lID09PSBcIlwiKSB7XG4gICAgICAgIGlucHV0LnJlcG9ydFZhbGlkaXR5KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2VsZWN0RWwgPSBpbnB1dC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nIGFzIEhUTUxTZWxlY3RFbGVtZW50O1xuICAgICAgY29uc3QgaHRtbFR5cGUgPSBzZWxlY3RFbC52YWx1ZTtcblxuICAgICAgY29uc3QgcmV2ZXJzZU9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIFByb3BlcnR5VHlwZXM+ID0ge1xuICAgICAgICBcInN0cmluZ1wiOiBcInRleHRcIixcbiAgICAgICAgXCJudW1iZXJcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJjaGVja2JveFwiOiBcImNoZWNrYm94XCIsXG4gICAgICAgIFwiZGF0ZVwiOiBcImRhdGVcIixcbiAgICAgICAgXCJkYXRldGltZS1sb2NhbFwiOiBcImRhdGV0aW1lXCJcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9ic2lkaWFuVHlwZSA9IHJldmVyc2VPcHRpb25zW2h0bWxUeXBlXSA/PyAndGV4dCc7XG5cbiAgICAgIGxldCB2YWx1ZTogYW55ID0gcGFyc2VWYWx1ZShcbiAgICAgICAgaW5wdXQubmV4dEVsZW1lbnRTaWJsaW5nLFxuICAgICAgICBpbnB1dC5uZXh0RWxlbWVudFNpYmxpbmcudHlwZVxuICAgICAgKTtcbiAgICAgIC8vQ2hlY2sgZm9yIHRhZ3MuICBDbGVhbiB0aGVtIG9mIGFueSBpbnZhbGlkIGNoYXJhY3RlcnMsIHRoZW4gc3BsaXQgYnkgY29tbWEuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChuYW1lID09PSBcInRhZ3NcIikge1xuICAgICAgICAgIHZhbHVlID0gY2xlYW5UYWdzKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5pbmNsdWRlcyhcIixcIikpIHtcbiAgICAgICAgICBsZXQgc3RyID0gcmVtb3ZlRXh0cmFDb21tYXModmFsdWUpO1xuICAgICAgICAgIHZhbHVlID0gc3RyLnNwbGl0KGRlbGltaXRlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA9PT0gXCJcIikgdmFsdWUgPSBudWxsO1xuXG4gICAgICAvL1N0b3JlIGRhdGEgaW50byBvYmplY3QuXG4gICAgICBsZXQgcHJvcE9iajogTmV3UHJvcERhdGEgPSB7XG4gICAgICAgIHR5cGU6IG9ic2lkaWFuVHlwZSxcbiAgICAgICAgZGF0YTogdmFsdWUsXG4gICAgICAgIG92ZXJ3cml0ZTogZmFsc2UsXG4gICAgICAgIGRlbGltaXRlcjogZGVsaW1pdGVyLFxuICAgICAgfTtcblxuICAgICAgb2JqLnNldChuYW1lLCBwcm9wT2JqKTtcbiAgICB9KTtcblxuICAgIC8vVE9ETzogRXJyb3IgaGFuZGxpbmcgZm9yIHdoZW4gdXNlciBzdWJtaXRzIHdpdGggYW4gZW1wdHkgbmFtZS5cbiAgICAvL0lucHV0IHZhbGlkYXRpb24gZG9lc24ndCB0cmlnZ2VyIHVubGVzcyB0aGlzIGNvZGUgaXMgaW4uICBXaHk/ICBJIGRpZG4ndCBuZWVkIHRoaXMgYmVmb3JlLlxuICAgIGlmIChvYmouc2l6ZSA8IGlucHV0cy5sZW5ndGgpIHJldHVybjtcblxuICAgIGNvbnNvbGUubG9nKG9iaik7XG5cbiAgICBzdWJtaXNzaW9uKG9iaik7XG4gIH1cbjwvc2NyaXB0PlxuXG48ZGl2IGlkPVwibXVsdGktcHJvcGVydGllcy1tb2RhbFwiIGNsYXNzPVwibW9kYWwtY29udGVudFwiPlxuICA8ZGl2IGlkPVwiYWxlcnQtY29udGFpbmVyXCIgY2xhc3M9XCJhbGVydC1jb250YWluZXIgaGlkZGVuXCIgYmluZDp0aGlzPXtlcnJvckVsfT5cbiAgICA8ZGl2PkVSUk9SPC9kaXY+XG4gICAgPGRpdiBpZD1cImFsZXJ0LXRleHRcIj57YWxlcnRUZXh0fTwvZGl2PlxuICA8L2Rpdj5cbiAgPHA+XG4gICAgVHlwZSBpbiBhIHByb3BlcnR5IG5hbWUsIHRoZW4gdmFsdWUuIFVzZSB0aGUgZHJvcGJveCB0byBjaG9vc2Ugd2hhdCB0eXBlIG9mXG4gICAgZGF0YSB5b3Ugd2lzaCB0byBzdG9yZS5cbiAgPC9wPlxuICA8cD5cbiAgICBJZiB5b3Ugd2FudCB0byBtYWtlIGEgTGlzdCBwcm9wZXJ0eSwgdXNlIHRoZSBUZXh0IGRhdGEgdHlwZSBhbmQgc2VwYXJhdGVcbiAgICBlYWNoIHZhbHVlIHdpdGggYSBcIntkZWxpbWl0ZXJ9XCIuXG4gIDwvcD5cbiAgPHA+SWYgeW91IHdhbnQgdG8gYWRkIFRhZ3MsIHVzZSB0aGUgbmFtZSBcInRhZ3NcIi48L3A+XG4gIDxmb3JtIG9uOnN1Ym1pdHxwcmV2ZW50RGVmYXVsdCBiaW5kOnRoaXM9e2Zvcm1FbH0+XG4gICAgPGxhYmVsXG4gICAgICA+PGlucHV0XG4gICAgICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgICAgIGNoZWNrZWQ9e292ZXJ3cml0ZX1cbiAgICAgICAgb246Y2hhbmdlPXtvbkNoZWNrYm94Q2hhbmdlfVxuICAgICAgLz57XCJPdmVyd3JpdGUgZXhpc3RpbmcgcHJvcGVydGllc1wifTwvbGFiZWxcbiAgICA+XG4gICAgPGRpdiBjbGFzcz1cIm1vZGFsLWlucHV0cy1jb250YWluZXJcIj5cbiAgICAgIHsjZWFjaCBpbnB1dEVscyBhcyBpbnB1dCAoaW5wdXQuaWQpfVxuICAgICAgICA8UHJvcElucHV0XG4gICAgICAgICAgaXNGaXJzdD17aW5wdXQuaXNGaXJzdH1cbiAgICAgICAgICBpZD17aW5wdXQuaWR9XG4gICAgICAgICAgYmluZDp0eXBlVmFsPXtpbnB1dC50eXBlRGVmfVxuICAgICAgICAgIGJpbmQ6bmFtZVZhbD17aW5wdXQubmFtZURlZn1cbiAgICAgICAgICBiaW5kOnZhbHVlVmFsPXtpbnB1dC52YWx1ZURlZn1cbiAgICAgICAgICB7cmVtb3ZlSW5wdXR9XG4gICAgICAgIC8+XG4gICAgICB7L2VhY2h9XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cIm1vZGFsLWFkZC1jb250YWluZXJcIj5cbiAgICAgIDxidXR0b25cbiAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgIG9uOmNsaWNrPXsoKSA9PiBhZGRJbnB1dHMoW3sgdHlwZTogXCJ0ZXh0XCIsIG5hbWU6IFwiXCIsIHZhbHVlOiBcIlwiIH1dKX1cbiAgICAgICAgY2xhc3M9XCJhLWJ0blwiXG4gICAgICAgID5BZGQ8L2J1dHRvblxuICAgICAgPlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1idXR0b24tY29udGFpbmVyXCI+XG4gICAgICA8YnV0dG9uIG9uOmNsaWNrPXtvblN1Ym1pdH0gY2xhc3M9XCJidG4tc3VibWl0XCI+U3VibWl0PC9idXR0b24+XG4gICAgPC9kaXY+XG4gIDwvZm9ybT5cbjwvZGl2PlxuXG48c3R5bGU+XG4gIC5tb2RhbC1pbnB1dHMtY29udGFpbmVyIHtcbiAgICBoZWlnaHQ6IDIwMHB4O1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIG92ZXJmbG93LXk6IHNjcm9sbDtcbiAgICBib3JkZXItcmFkaXVzOiA1cHg7XG4gICAgYm9yZGVyLXN0eWxlOiBzb2xpZDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgfVxuXG4gIC5tb2RhbC1hZGQtY29udGFpbmVyIHtcbiAgICBtYXJnaW4tdG9wOiAxMHB4O1xuICB9XG4gIC5hbGVydC1jb250YWluZXIge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIG1hcmdpbi1ib3R0b206IDEwcHg7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmVkO1xuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICB9XG4gIC5oaWRkZW4ge1xuICAgIGRpc3BsYXk6IG5vbmU7XG4gIH1cbjwvc3R5bGU+XG4iLCAiLyoqIE1vZGFsIHRvIGhvbGQgZm9ybSB0aGF0IGxldHMgdXNlciByZW1vdmUgcHJvcHMgZnJvbSBzZWxlY3Rpb24uICovXG5cbmltcG9ydCB7IE1vZGFsLCBBcHAsIE5vdGljZSB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IEFkZENvbmZpcm1Gb3JtIGZyb20gXCIuL0FkZENvbmZpcm1Gb3JtLnN2ZWx0ZVwiO1xuaW1wb3J0IHsgTmV3UHJvcERhdGEgfSBmcm9tIFwiLi9tYWluXCI7XG5cbi8qKiBMb2FkcyBhIG1vZGFsIGFuZCBoYW5kbGVzIGZvcm0gc3VibWlzc2lvbnMuICovXG5leHBvcnQgY2xhc3MgQWRkQ29uZmlybU1vZGFsIGV4dGVuZHMgTW9kYWwge1xuXHRwcm9wczogTWFwPHN0cmluZywgTmV3UHJvcERhdGE+O1xuXHRzdWJtaXNzaW9uOiAoYm9vbDogYm9vbGVhbikgPT4gUHJvbWlzZTx2b2lkPjtcblx0b3ZlcndyaXRlOiBib29sZWFuO1xuXHRjb21wb25lbnQ6IEFkZENvbmZpcm1Gb3JtO1xuXG5cdGNvbnN0cnVjdG9yKFxuXHRcdGFwcDogQXBwLFxuXHRcdHByb3BzOiBNYXA8c3RyaW5nLCBOZXdQcm9wRGF0YT4sXG5cdFx0b3ZlcndyaXRlOiBib29sZWFuLFxuXHRcdHN1Ym1pc3Npb246IChib29sOiBib29sZWFuKSA9PiBQcm9taXNlPHZvaWQ+XG5cdCkge1xuXHRcdHN1cGVyKGFwcCk7XG5cdFx0dGhpcy5wcm9wcyA9IHByb3BzO1xuXHRcdHRoaXMub3ZlcndyaXRlID0gb3ZlcndyaXRlO1xuXHRcdHRoaXMuc3VibWlzc2lvbiA9IHN1Ym1pc3Npb247XG5cdH1cblx0YXN5bmMgb25TdWJtaXQoKSB7XG5cdFx0YXdhaXQgdGhpcy5zdWJtaXNzaW9uKHRydWUpO1xuXHRcdHRoaXMuY2xvc2UoKTtcblx0fVxuXG5cdG9uQ2FuY2VsKCkge1xuXHRcdHRoaXMuc3VibWlzc2lvbihmYWxzZSk7XG5cdFx0dGhpcy5jbG9zZSgpO1xuXHR9XG5cblx0b25PcGVuKCk6IHZvaWQge1xuXHRcdHRoaXMudGl0bGVFbC5jcmVhdGVFbChcImgyXCIsIHsgdGV4dDogXCJBZGQgUHJvcGVydGllc1wiIH0pO1xuXG5cdFx0dGhpcy5jb21wb25lbnQgPSBuZXcgQWRkQ29uZmlybUZvcm0oe1xuXHRcdFx0dGFyZ2V0OiB0aGlzLmNvbnRlbnRFbCxcblx0XHRcdHByb3BzOiB7XG5cdFx0XHRcdHByb3BzOiB0aGlzLnByb3BzLFxuXHRcdFx0XHRvdmVyd3JpdGU6IHRoaXMub3ZlcndyaXRlLFxuXHRcdFx0XHRzdWJtaXNzaW9uOiB0aGlzLm9uU3VibWl0LmJpbmQodGhpcyksXG5cdFx0XHRcdGNhbmNlbDogdGhpcy5vbkNhbmNlbC5iaW5kKHRoaXMpLFxuXHRcdFx0fSxcblx0XHR9KTtcblx0fVxufVxuIiwgIjxzY3JpcHQgbGFuZz1cInRzXCI+XHJcblx0aW1wb3J0IHsgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcclxuXHRpbXBvcnQgeyBOZXdQcm9wRGF0YSB9IGZyb20gXCIuL21haW5cIjtcclxuXHJcblx0ZXhwb3J0IGxldCBwcm9wczogTWFwPHN0cmluZywgTmV3UHJvcERhdGE+O1xyXG5cdGV4cG9ydCBsZXQgb3ZlcndyaXRlOiBib29sZWFuID0gdHJ1ZTtcclxuXHRleHBvcnQgbGV0IHN1Ym1pc3Npb246ICgpID0+IHZvaWQ7XHJcblx0ZXhwb3J0IGxldCBjYW5jZWw6ICgpID0+IHZvaWQ7XHJcblxyXG5cdGxldCBidG5DYW5jZWw6IEhUTUxCdXR0b25FbGVtZW50O1xyXG5cclxuXHRjb25zdCBtc2cgPSBvdmVyd3JpdGVcclxuXHRcdD8gXCJBbnkgcHJlLWV4aXN0aW5nIHRleHQgcHJvcHMgd2lsbCBoYXZlIHRoZWlyIHZhbHVlcyBvdmVyd3JpdHRlbi5cIlxyXG5cdFx0OiBcIkFueSBwcmUtZXhpc3RpbmcgdGV4dCBwcm9wcyB3aWxsIGhhdmUgdGhlaXIgdmFsdWVzIGJlIGFwcGVuZGVkIHRvLlwiO1xyXG5cclxuXHQvL0ZvY3VzIG9uIGNhbmNlbCB0byBtYWtlIHN1cmUgdXNlciBkb2VzIG5vdCBlYXNpbHkgc3VibWl0IGNoYW5nZXMuXHJcblx0b25Nb3VudCgoKSA9PiB7XHJcblx0XHRidG5DYW5jZWwuZm9jdXMoKTtcclxuXHR9KTtcclxuPC9zY3JpcHQ+XHJcblxyXG48ZGl2PlxyXG5cdDxmb3JtIG9uOnN1Ym1pdHxwcmV2ZW50RGVmYXVsdD17c3VibWlzc2lvbn0+XHJcblx0XHQ8cCBjbGFzcz1cIm1zZ1wiPnttc2d9PC9wPlxyXG5cdFx0PHA+VGhlIGZvbGxvd2luZyBwcm9wcyB3aWxsIGJlIGFkZGVkOjwvcD5cclxuXHRcdDx1bD5cclxuXHRcdFx0eyNlYWNoIFsuLi5wcm9wc10gYXMgW3Byb3BOYW1lLCBwcm9wXX1cclxuXHRcdFx0XHQ8bGk+XHJcblx0XHRcdFx0XHR7cHJvcE5hbWV9OiB7cHJvcC5kYXRhfVxyXG5cdFx0XHRcdDwvbGk+XHJcblx0XHRcdHsvZWFjaH1cclxuXHRcdDwvdWw+XHJcblx0XHQ8cD5BcmUgeW91IHN1cmUgeW91IHdpc2ggdG8gcHJvY2VlZD88L3A+XHJcblx0XHQ8YnV0dG9uIGNsYXNzPVwibW9kLXdhcm5pbmdcIiB0eXBlPVwic3VibWl0XCI+Q29uZmlybTwvYnV0dG9uPlxyXG5cdFx0PGJ1dHRvbiBvbjpjbGljaz17Y2FuY2VsfSBiaW5kOnRoaXM9e2J0bkNhbmNlbH0+Q2FuY2VsPC9idXR0b24+XHJcblx0PC9mb3JtPlxyXG48L2Rpdj5cclxuXHJcbjxzdHlsZT5cclxuXHQubXNnIHtcclxuXHRcdGZvbnQtd2VpZ2h0OiBib2xkO1xyXG5cdFx0cGFkZGluZy1ib3R0b206IDEwcHg7XHJcblx0fVxyXG48L3N0eWxlPlxyXG4iLCAiaW1wb3J0IHsgUGx1Z2luU2V0dGluZ1RhYiwgQXBwLCBTZXR0aW5nLCBOb3RpY2UgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuXHJcbmltcG9ydCBNdWx0aVByb3BQbHVnaW4gZnJvbSBcIi4vbWFpblwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIFNldHRpbmdUYWIgZXh0ZW5kcyBQbHVnaW5TZXR0aW5nVGFiIHtcclxuICBwbHVnaW46IE11bHRpUHJvcFBsdWdpbjtcclxuXHJcbiAgY29uc3RydWN0b3IoYXBwOiBBcHAsIHBsdWdpbjogTXVsdGlQcm9wUGx1Z2luKSB7XHJcbiAgICBzdXBlcihhcHAsIHBsdWdpbik7XHJcbiAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcclxuICB9XHJcblxyXG4gIGRpc3BsYXkoKSB7XHJcbiAgICBsZXQgeyBjb250YWluZXJFbCB9ID0gdGhpcztcclxuICAgIGNvbnRhaW5lckVsLmVtcHR5KCk7XHJcblxyXG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcbiAgICAgIC5zZXROYW1lKFwiT3ZlcndyaXRlIGV4aXN0aW5nIHRleHRcIilcclxuICAgICAgLnNldERlc2MoXHJcbiAgICAgICAgXCJXaGVuIGFkZGluZyBhIHByb3BlcnR5IHdpdGggYSBuYW1lIHRoYXQgYWxyZWFkeSBleGlzdHMsIHRoZSB0ZXh0IHdpbGwgb3ZlcndyaXRlIHRoZSBwcm9wJ3MgZXhpc3RpbmcgdmFsdWUuICBJZiBsZWZ0IGRpc2FibGVkLCB0aGUgbmV3IHZhbHVlIHdpbGwgYmUgYXBwZW5kZWQgdG8gdGhlIG9sZCBhcyBhIExpc3QuXCJcclxuICAgICAgKVxyXG4gICAgICAuYWRkVG9nZ2xlKCh0b2dnbGUpID0+IHtcclxuICAgICAgICB0b2dnbGUuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3Mub3ZlcndyaXRlKTtcclxuICAgICAgICB0b2dnbGUub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5vdmVyd3JpdGUgPSB2YWx1ZTtcclxuICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgLnNldE5hbWUoXCJSZWN1cnNpdmUgSXRlcmF0aW9uXCIpXHJcbiAgICAgIC5zZXREZXNjKFxyXG4gICAgICAgIFwiV2hlbiB0b2dnbGVkIG9uLCB3aGlsZSBsb29waW5nIHRocm91Z2ggYWxsIGZpbGVzIGluIGEgZm9sZGVyLCB5b3Ugd2lsbCBhbHNvIGxvb3AgdGhyb3VnaCBhbnkgc3ViLWZvbGRlcnMuXCJcclxuICAgICAgKVxyXG4gICAgICAuYWRkVG9nZ2xlKCh0b2dnbGUpID0+IHtcclxuICAgICAgICB0b2dnbGUuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MucmVjdXJzaXZlKTtcclxuICAgICAgICB0b2dnbGUub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5yZWN1cnNpdmUgPSB2YWx1ZTtcclxuICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgLnNldE5hbWUoXCJMaXN0IERlbGltaXRlclwiKVxyXG4gICAgICAuc2V0RGVzYyhcclxuICAgICAgICBcIlNldCBkZWxpbWl0ZXIgdG8gdXNlIHdoZW4gY3JlYXRpbmcgYSBsaXN0LiAgQ29tbWFzKCwpIGFyZSB1c2VkIGJ5IGRlZmF1bHQuXCJcclxuICAgICAgKVxyXG4gICAgICAuYWRkVGV4dCgodGV4dCkgPT4ge1xyXG4gICAgICAgIHRleHQuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuZGVsaW1pdGVyKTtcclxuICAgICAgICB0ZXh0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgdGV4dC5zZXRWYWx1ZSh2YWx1ZVswXSk7XHJcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJEZWxpbWl0ZXIgbXVzdCBiZSBhIHNpbmdsZSBjaGFyYWN0ZXIuXCIpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5kZWxpbWl0ZXIgPSB2YWx1ZTtcclxuICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgLnNldE5hbWUoXCJEZWZhdWx0IFByb3BzIEZpbGVcIilcclxuICAgICAgLnNldERlc2MoXHJcbiAgICAgICAgXCJTZWxlY3QgYSBmaWxlIHdpdGggcHJvcGVydGllcyB0aGF0IHlvdSB3YW50IHRvIGxvYWQgaW50byB0aGUgTXVsdGkgUHJvcGVydGllcyBmb3JtIGJ5IGRlZmF1bHQuICBUeXBlIGluIHRoZSBmdWxsIHBhdGggb2YgdGhlIGRlc2lyZWQgZmlsZS4oZXguIFRlbXBsYXRlcy9Qcm9wRmlsZSAxKVwiXHJcbiAgICAgIClcclxuICAgICAgLmFkZFRleHQoKHRleHQpID0+IHtcclxuICAgICAgICB0ZXh0LnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmRlZmF1bHRQcm9wUGF0aCk7XHJcbiAgICAgICAgdGV4dC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmRlZmF1bHRQcm9wUGF0aCA9IHZhbHVlO1xyXG4gICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBNdWx0aVByb3BTZXR0aW5ncyB7XHJcbiAgb3ZlcndyaXRlOiBib29sZWFuO1xyXG4gIHJlY3Vyc2l2ZTogYm9vbGVhbjtcclxuICBkZWxpbWl0ZXI6IHN0cmluZztcclxuICBkZWZhdWx0UHJvcFBhdGg6IHN0cmluZztcclxufVxyXG4iLCAiLyoqIE1vZGFsIHRvIGhvbGQgZm9ybSB0aGF0IGxldHMgdXNlciByZW1vdmUgcHJvcHMgZnJvbSBzZWxlY3Rpb24uICovXG5cbmltcG9ydCB7IE1vZGFsLCBBcHAsIE5vdGljZSB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IFJlbW92ZVByb3BGb3JtIGZyb20gXCIuL1JlbW92ZVByb3BGb3JtLnN2ZWx0ZVwiO1xuaW1wb3J0IHsgUmVtb3ZlQ29uZmlybU1vZGFsIH0gZnJvbSBcIi4vUmVtb3ZlQ29uZmlybU1vZGFsXCI7XG5cbi8qKiBMb2FkcyBhIG1vZGFsIGFuZCBoYW5kbGVzIGZvcm0gc3VibWlzc2lvbnMuICovXG5leHBvcnQgY2xhc3MgUmVtb3ZlTW9kYWwgZXh0ZW5kcyBNb2RhbCB7XG4gIG5hbWVzOiBzdHJpbmdbXTtcbiAgcHJvcHM6IHN0cmluZ1tdO1xuICBzdWJtaXNzaW9uOiAoY3VzdG9tUHJvcHM6IHN0cmluZ1tdKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBjb21wb25lbnQ6IFJlbW92ZVByb3BGb3JtO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIGFwcDogQXBwLFxuICAgIG5hbWVzOiBzdHJpbmdbXSxcbiAgICBzdWJtaXNzaW9uOiAoY3VzdG9tUHJvcHM6IHN0cmluZ1tdKSA9PiBQcm9taXNlPHZvaWQ+XG4gICkge1xuICAgIGlmICghbmFtZXMgfHwgbmFtZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBuZXcgTm90aWNlKFwiTm8gcHJvcGVydGllcyB0byByZW1vdmVcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyKGFwcCk7XG4gICAgdGhpcy5uYW1lcyA9IG5hbWVzO1xuICAgIHRoaXMuc3VibWlzc2lvbiA9IHN1Ym1pc3Npb247XG4gIH1cblxuICBhc3luYyBvbkNvbmZpcm0oYm9vbDogYm9vbGVhbikge1xuICAgIGlmIChib29sKSB7XG4gICAgICBhd2FpdCB0aGlzLnN1Ym1pc3Npb24odGhpcy5wcm9wcyk7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfVxuICB9XG5cbiAgb25TdWJtaXQocHJvcHM6IHN0cmluZ1tdKSB7XG4gICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgIG5ldyBSZW1vdmVDb25maXJtTW9kYWwoXG4gICAgICB0aGlzLmFwcCxcbiAgICAgIHRoaXMucHJvcHMsXG4gICAgICB0aGlzLm9uQ29uZmlybS5iaW5kKHRoaXMpXG4gICAgKS5vcGVuKCk7XG4gIH1cblxuICBvbk9wZW4oKTogdm9pZCB7XG4gICAgdGhpcy50aXRsZUVsLmNyZWF0ZUVsKFwiaDJcIiwgeyB0ZXh0OiBcIlJlbW92ZSBQcm9wZXJ0aWVzXCIgfSk7XG5cbiAgICB0aGlzLmNvbXBvbmVudCA9IG5ldyBSZW1vdmVQcm9wRm9ybSh7XG4gICAgICB0YXJnZXQ6IHRoaXMuY29udGVudEVsLFxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgbmFtZXM6IHRoaXMubmFtZXMsXG4gICAgICAgIHN1Ym1pc3Npb246IHRoaXMub25TdWJtaXQuYmluZCh0aGlzKSxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cbn1cbiIsICI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxyXG4gIGV4cG9ydCBsZXQgbmFtZXM6IHN0cmluZ1tdID0gW107XHJcbiAgZXhwb3J0IGxldCBzdWJtaXNzaW9uOiAocHJvcHM6IHN0cmluZ1tdKSA9PiB2b2lkO1xyXG5cclxuICBsZXQgZXJyb3JFbDogSFRNTERpdkVsZW1lbnQ7XHJcbiAgbGV0IGFsZXJ0VGV4dCA9IFwiLlwiO1xyXG4gIC8vbGV0IHByb3BOYW1lczogc3RyaW5nW10gPSBbXTtcclxuXHJcbiAgbGV0IGNoZWNrQ291bnQgPSAwO1xyXG4gICQ6IGlzTWF4Q2hlY2tlZCA9IGNoZWNrQ291bnQgPj0gbmFtZXMubGVuZ3RoO1xyXG4gICQ6IGNvbnNvbGUubG9nKGlzTWF4Q2hlY2tlZCk7XHJcblxyXG4gIGxldCBpbnB1dHM6IHsgbmFtZTogc3RyaW5nOyBpc0NoZWNrZWQ6IGJvb2xlYW4gfVtdID0gW107XHJcbiAgZm9yIChsZXQgbmFtZSBvZiBuYW1lcykge1xyXG4gICAgaW5wdXRzLnB1c2goeyBuYW1lLCBpc0NoZWNrZWQ6IGZhbHNlIH0pO1xyXG4gIH1cclxuXHJcbiAgbmFtZXMuc29ydCgpO1xyXG5cclxuICAvLyBmdW5jdGlvbiBoYW5kbGVDaGVja2JveENoYW5nZShldmVudDogYW55LCBzdHJpbmc6IHN0cmluZykge1xyXG4gIC8vIFx0Y29uc3QgaXNDaGVja2VkID0gZXZlbnQudGFyZ2V0LmNoZWNrZWQ7XHJcbiAgLy8gXHRpZiAoaXNDaGVja2VkKSB7XHJcbiAgLy8gXHRcdHByb3BOYW1lcyA9IFsuLi5wcm9wTmFtZXMsIHN0cmluZ107XHJcbiAgLy8gXHR9IGVsc2Uge1xyXG4gIC8vIFx0XHRwcm9wTmFtZXMgPSBwcm9wTmFtZXMuZmlsdGVyKChzZWxlY3RlZCkgPT4gc2VsZWN0ZWQgIT09IHN0cmluZyk7XHJcbiAgLy8gXHR9XHJcbiAgLy8gfVxyXG5cclxuICBmdW5jdGlvbiBvbkNoZWNrYm94Q2hhbmdlKGV2ZW50OiBhbnkpIHtcclxuICAgIGxldCBjaGVja2VkID0gZXZlbnQudGFyZ2V0LmNoZWNrZWQ7XHJcbiAgICBjaGVja2VkID8gY2hlY2tDb3VudCsrIDogY2hlY2tDb3VudC0tO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdG9nZ2xlQWxsKCkge1xyXG4gICAgaWYgKGlzTWF4Q2hlY2tlZCkge1xyXG4gICAgICBpbnB1dHMgPSBpbnB1dHMubWFwKChpbnB1dCkgPT4gKHsgLi4uaW5wdXQsIGlzQ2hlY2tlZDogZmFsc2UgfSkpO1xyXG4gICAgICBjaGVja0NvdW50ID0gMDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlucHV0cyA9IGlucHV0cy5tYXAoKGlucHV0KSA9PiAoeyAuLi5pbnB1dCwgaXNDaGVja2VkOiB0cnVlIH0pKTtcclxuICAgICAgY2hlY2tDb3VudCA9IG5hbWVzLmxlbmd0aDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIG9uU3VibWl0KCkge1xyXG4gICAgaWYgKGNoZWNrQ291bnQgPT09IDApIHtcclxuICAgICAgYWxlcnRUZXh0ID0gXCJQbGVhc2Ugc2VsZWN0IGF0IGxlYXN0IG9uZSBwcm9wZXJ0eSB0byByZW1vdmUuXCI7XHJcbiAgICAgIGVycm9yRWwuY2xhc3NMaXN0LnJlbW92ZShcImhpZGRlblwiKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgbGV0IHByb3BOYW1lcyA9IGlucHV0c1xyXG4gICAgICAuZmlsdGVyKChpbnB1dCkgPT4gaW5wdXQuaXNDaGVja2VkKVxyXG4gICAgICAubWFwKChpbnB1dCkgPT4gaW5wdXQubmFtZSk7XHJcbiAgICBzdWJtaXNzaW9uKHByb3BOYW1lcyk7XHJcbiAgfVxyXG48L3NjcmlwdD5cclxuXHJcbjxkaXY+XHJcbiAgPGRpdiBpZD1cImFsZXJ0LWNvbnRhaW5lclwiIGNsYXNzPVwiYWxlcnQtY29udGFpbmVyIGhpZGRlblwiIGJpbmQ6dGhpcz17ZXJyb3JFbH0+XHJcbiAgICA8ZGl2PkVSUk9SPC9kaXY+XHJcbiAgICA8ZGl2IGlkPVwiYWxlcnQtdGV4dFwiPnthbGVydFRleHR9PC9kaXY+XHJcbiAgPC9kaXY+XHJcbiAgPHA+U2VsZWN0IHRoZSBwcm9wZXJ0aWVzIHlvdSB3aXNoIHRvIHJlbW92ZSBmcm9tIHRoZSBmaWxlIHNlbGVjdGlvbi48L3A+XHJcbiAgPGZvcm0gb246c3VibWl0fHByZXZlbnREZWZhdWx0PlxyXG4gICAgPGRpdiBjbGFzcz1cIm5hbWUtY29udGFpbmVyXCI+XHJcbiAgICAgIHsjZWFjaCBpbnB1dHMgYXMgaW5wdXR9XHJcbiAgICAgICAgPGxhYmVsPlxyXG4gICAgICAgICAgPGlucHV0XHJcbiAgICAgICAgICAgIHR5cGU9XCJjaGVja2JveFwiXHJcbiAgICAgICAgICAgIGJpbmQ6dmFsdWU9e2lucHV0Lm5hbWV9XHJcbiAgICAgICAgICAgIGJpbmQ6Y2hlY2tlZD17aW5wdXQuaXNDaGVja2VkfVxyXG4gICAgICAgICAgICBvbjpjaGFuZ2U9eyhldmVudCkgPT4gb25DaGVja2JveENoYW5nZShldmVudCl9XHJcbiAgICAgICAgICAvPlxyXG4gICAgICAgICAge2lucHV0Lm5hbWV9XHJcbiAgICAgICAgPC9sYWJlbD5cclxuICAgICAgey9lYWNofVxyXG4gICAgPC9kaXY+XHJcbiAgICA8ZGl2IGNsYXNzPVwiYnV0dG9uLWNvbnRhaW5lclwiPlxyXG4gICAgICA8YnV0dG9uIG9uOmNsaWNrPXtvblN1Ym1pdH0gdHlwZT1cInN1Ym1pdFwiPkNvbmZpcm08L2J1dHRvbj5cclxuICAgICAgPGJ1dHRvbiBvbjpjbGljaz17dG9nZ2xlQWxsfVxyXG4gICAgICAgID57aXNNYXhDaGVja2VkID8gXCJVbmNoZWNrIEFsbFwiIDogXCJDaGVjayBBbGxcIn08L2J1dHRvblxyXG4gICAgICA+XHJcbiAgICA8L2Rpdj5cclxuICA8L2Zvcm0+XHJcbjwvZGl2PlxyXG5cclxuPHN0eWxlPlxyXG4gIC5uYW1lLWNvbnRhaW5lciB7XHJcbiAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcclxuICAgIGdhcDogNXB4O1xyXG4gICAgbWFyZ2luLXRvcDogMTBweDtcclxuICAgIG1hcmdpbi1ib3R0b206IDIwcHg7XHJcbiAgfVxyXG4gIC5hbGVydC1jb250YWluZXIge1xyXG4gICAgZGlzcGxheTogZmxleDtcclxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XHJcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xyXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XHJcbiAgICBtYXJnaW4tYm90dG9tOiAxMHB4O1xyXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmVkO1xyXG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XHJcbiAgfVxyXG5cclxuICAuYnV0dG9uLWNvbnRhaW5lciB7XHJcbiAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcclxuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcclxuICB9XHJcbiAgLmhpZGRlbiB7XHJcbiAgICBkaXNwbGF5OiBub25lO1xyXG4gIH1cclxuPC9zdHlsZT5cclxuIiwgIi8qKiBNb2RhbCB0byBob2xkIGZvcm0gdGhhdCBsZXRzIHVzZXIgcmVtb3ZlIHByb3BzIGZyb20gc2VsZWN0aW9uLiAqL1xuXG5pbXBvcnQgeyBNb2RhbCwgQXBwLCBOb3RpY2UgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCBSZW1vdmVDb25maXJtRm9ybSBmcm9tIFwiLi9SZW1vdmVDb25maXJtRm9ybS5zdmVsdGVcIjtcbmltcG9ydCBNdWx0aVByb3BQbHVnaW4gZnJvbSBcIi4vbWFpblwiO1xuXG4vKiogTG9hZHMgYSBtb2RhbCBhbmQgaGFuZGxlcyBmb3JtIHN1Ym1pc3Npb25zLiAqL1xuZXhwb3J0IGNsYXNzIFJlbW92ZUNvbmZpcm1Nb2RhbCBleHRlbmRzIE1vZGFsIHtcbiAgbmFtZXM6IHN0cmluZ1tdO1xuICBzdWJtaXNzaW9uOiAoYm9vbDogYm9vbGVhbikgPT4gUHJvbWlzZTx2b2lkPjtcbiAgY29tcG9uZW50OiBSZW1vdmVDb25maXJtRm9ybTtcblxuICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgbmFtZXM6IHN0cmluZ1tdLCBzdWJtaXNzaW9uOiAoYm9vbDogYm9vbGVhbikgPT4gUHJvbWlzZTx2b2lkPikge1xuICAgIHN1cGVyKGFwcCk7XG4gICAgdGhpcy5uYW1lcyA9IG5hbWVzO1xuICAgIHRoaXMuc3VibWlzc2lvbiA9IHN1Ym1pc3Npb247XG4gIH1cblxuICBhc3luYyBvblN1Ym1pdCgpIHtcbiAgICBhd2FpdCB0aGlzLnN1Ym1pc3Npb24odHJ1ZSk7XG4gICAgdGhpcy5jbG9zZSgpO1xuICB9XG5cbiAgb25DYW5jZWwoKSB7XG4gICAgdGhpcy5zdWJtaXNzaW9uKGZhbHNlKTtcbiAgICB0aGlzLmNsb3NlKCk7XG4gIH1cblxuICBvbk9wZW4oKTogdm9pZCB7XG4gICAgLy9QcmV2ZW50IG1vZGFsIGZyb20gb3BlbmluZyBpZiBubyBuYW1lcyBhcmUgcGFzc2VkLlxuICAgIGlmICghdGhpcy5uYW1lcyB8fCB0aGlzLm5hbWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgbmV3IE5vdGljZShcIlBsZWFzZSBjaGVjayBhdCBsZWFzdCBvbmUgcHJvcGVydHkgdG8gcmVtb3ZlLlwiKTtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9XG4gICAgdGhpcy50aXRsZUVsLmNyZWF0ZUVsKFwiaDJcIiwgeyB0ZXh0OiBcIlJlbW92ZSBQcm9wZXJ0aWVzXCIgfSk7XG5cbiAgICB0aGlzLmNvbXBvbmVudCA9IG5ldyBSZW1vdmVDb25maXJtRm9ybSh7XG4gICAgICB0YXJnZXQ6IHRoaXMuY29udGVudEVsLFxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgbmFtZXM6IHRoaXMubmFtZXMsXG4gICAgICAgIHN1Ym1pc3Npb246IHRoaXMub25TdWJtaXQuYmluZCh0aGlzKSxcbiAgICAgICAgY2FuY2VsOiB0aGlzLm9uQ2FuY2VsLmJpbmQodGhpcyksXG4gICAgICB9LFxuICAgIH0pO1xuICB9XG59XG4iLCAiPHNjcmlwdCBsYW5nPVwidHNcIj5cclxuXHRpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xyXG5cclxuXHRleHBvcnQgbGV0IG5hbWVzOiBzdHJpbmdbXSA9IFtcInRlc3RcIiwgXCJ0ZXN0MlwiXTtcclxuXHRleHBvcnQgbGV0IHN1Ym1pc3Npb246ICgpID0+IHZvaWQ7XHJcblx0ZXhwb3J0IGxldCBjYW5jZWw6ICgpID0+IHZvaWQ7XHJcblxyXG5cdGxldCBidG5DYW5jZWw6IEhUTUxCdXR0b25FbGVtZW50O1xyXG5cclxuXHRjb25zdCB3b3JkID0gbmFtZXMubGVuZ3RoID4gMSA/IFwicHJvcGVydGllc1wiIDogXCJwcm9wZXJ0eVwiO1xyXG5cclxuXHQvL0ZvY3VzIG9uIGNhbmNlbCB0byBtYWtlIHN1cmUgdXNlciBkb2VzIG5vdCBlYXNpbHkgc3VibWl0IGNoYW5nZXMuXHJcblx0b25Nb3VudCgoKSA9PiB7XHJcblx0XHRidG5DYW5jZWwuZm9jdXMoKTtcclxuXHR9KTtcclxuPC9zY3JpcHQ+XHJcblxyXG48ZGl2PlxyXG5cdDxmb3JtIG9uOnN1Ym1pdHxwcmV2ZW50RGVmYXVsdD17c3VibWlzc2lvbn0+XHJcblx0XHQ8cD5UaGUgZm9sbG93aW5nIHt3b3JkfSB3aWxsIGJlIHJlbW92ZWQ6PC9wPlxyXG5cdFx0PHVsPlxyXG5cdFx0XHR7I2VhY2ggbmFtZXMgYXMgbmFtZX1cclxuXHRcdFx0XHQ8bGk+XHJcblx0XHRcdFx0XHR7bmFtZX1cclxuXHRcdFx0XHQ8L2xpPlxyXG5cdFx0XHR7L2VhY2h9XHJcblx0XHQ8L3VsPlxyXG5cdFx0PHA+QXJlIHlvdSBzdXJlIHlvdSB3aXNoIHRvIHByb2NlZWQ/PC9wPlxyXG5cdFx0PGJ1dHRvbiBjbGFzcz1cIm1vZC13YXJuaW5nXCIgdHlwZT1cInN1Ym1pdFwiPkRlbGV0ZTwvYnV0dG9uPlxyXG5cdFx0PGJ1dHRvbiBvbjpjbGljaz17Y2FuY2VsfSBiaW5kOnRoaXM9e2J0bkNhbmNlbH0+Q2FuY2VsPC9idXR0b24+XHJcblx0PC9mb3JtPlxyXG48L2Rpdj5cclxuIiwgImltcG9ydCB7IFRGaWxlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgeyBOZXdQcm9wRGF0YSB9IGZyb20gXCIuL21haW5cIjtcblxudHlwZSBGaWxlUHJvY2Vzc29yID0gKGZpbGU6IFRGaWxlLCBjYWxsYmFjazogKGZyb250bWF0dGVyOiBhbnkpID0+IHZvaWQpID0+IFByb21pc2U8dm9pZD4gfCB2b2lkO1xuXG4vKiogQWRkIHByb3BlcnRpZXMgZnJvbSBhIE1hcCB0byBhIG5vdGUuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhZGRQcm9wZXJ0aWVzKFxuICBmaWxlUHJvY2Vzc29yOiBGaWxlUHJvY2Vzc29yLFxuICBmaWxlOiBURmlsZSxcbiAgcHJvcHM6IE1hcDxzdHJpbmcsIE5ld1Byb3BEYXRhPixcbiAgb3ZlcndyaXRlOiBib29sZWFuLFxuICBwcm9wQ2FjaGU6IGFueVxuKSB7XG4gIGF3YWl0IGZpbGVQcm9jZXNzb3IoZmlsZSwgKGZyb250bWF0dGVyKSA9PiB7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgcHJvcHMpIHtcbiAgICAgIGlmIChrZXkgPT09IFwidGFnc1wiKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nVGFncyA9IGZyb250bWF0dGVyW2tleV0gfHwgW107XG4gICAgICAgIGNvbnN0IG5ld1RhZ3MgPSBBcnJheS5pc0FycmF5KHZhbHVlLmRhdGEpID8gdmFsdWUuZGF0YSA6IFt2YWx1ZS5kYXRhXTtcbiAgICAgICAgZnJvbnRtYXR0ZXJba2V5XSA9IFsuLi5uZXcgU2V0KFsuLi5leGlzdGluZ1RhZ3MsIC4uLm5ld1RhZ3NdKV07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWZyb250bWF0dGVyW2tleV0gfHwgb3ZlcndyaXRlKSB7XG4gICAgICAgIGZyb250bWF0dGVyW2tleV0gPSB2YWx1ZS5kYXRhO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy9Db21wYXJlIHR5cGVzIHRvIHNlZSBpZiB0aGV5IGNhbiBiZSBhcHBlbmRlZC5cbiAgICAgIGxldCB0eXBlMSA9IHZhbHVlLnR5cGU7XG4gICAgICBsZXQgdHlwZTIgPSBwcm9wQ2FjaGVba2V5LnRvTG93ZXJDYXNlKCldLnR5cGU7XG5cbiAgICAgIGlmIChjYW5CZUFwcGVuZGVkKHR5cGUxLCB0eXBlMikpIHtcbiAgICAgICAgaWYgKGZyb250bWF0dGVyW2tleV0gPT09IHZhbHVlLmRhdGEpIGNvbnRpbnVlOyAvL0xlYXZlIGlkZW50aWNhbCB2YWx1ZXMgYWxvbmUuXG4gICAgICAgIGlmICghdmFsdWUuZGF0YSkgY29udGludWU7IC8vRG8gbm90IG1lcmdlIGVtcHR5IHZhbHVlcy5cblxuICAgICAgICBsZXQgYXJyID0gbWVyZ2VJbnRvQXJyYXlzKGZyb250bWF0dGVyW2tleV0sIHZhbHVlLmRhdGEpO1xuICAgICAgICBmcm9udG1hdHRlcltrZXldID0gYXJyO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZyb250bWF0dGVyW2tleV0gPSB2YWx1ZS5kYXRhO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG4vKiogSXRlcmF0ZSB0aHJvdWdoIGFsbCBwcm9wcyBpbiBhIGxpc3QgYW5kIGFkZCB0aGVtIHRvIGFuIGV4aXN0aW5nIHNldC4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhZGRQcm9wVG9TZXQoZmlsZVByb2Nlc3NvcjogRmlsZVByb2Nlc3Nvciwgc2V0OiBTZXQ8c3RyaW5nPiwgZmlsZTogVEZpbGUpIHtcbiAgYXdhaXQgZmlsZVByb2Nlc3NvcihmaWxlLCAoZnJvbnRtYXR0ZXIpID0+IHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBmcm9udG1hdHRlcikge1xuICAgICAgY29uc29sZS5sb2coeyBrZXkgfSk7XG4gICAgICBzZXQuYWRkKGtleSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHNldDtcbn1cblxuLyoqIFJlbW92ZSBwcm9wZXJ0aWVzIGZyb20gYSBub3RlLiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlbW92ZVByb3BlcnRpZXMoZmlsZVByb2Nlc3NvcjogRmlsZVByb2Nlc3NvciwgZmlsZTogVEZpbGUsIHByb3BzOiBzdHJpbmdbXSkge1xuICBhd2FpdCBmaWxlUHJvY2Vzc29yKGZpbGUsIChmcm9udG1hdHRlcikgPT4ge1xuICAgIGZvciAoY29uc3QgcHJvcCBvZiBwcm9wcykge1xuICAgICAgLy9kZWxldGUgZnJvbnRtYXR0ZXJbcHJvcF07XG4gICAgICBmcm9udG1hdHRlcltwcm9wXSA9IHVuZGVmaW5lZDsgLy9cIkhhY2t5XCIgd29ya2Fyb3VuZCwgY29tbWVudGVkIGNvZGUgd2lsbCB3b3JrIGluIGxhdGVyIHZlcnNpb24uXCJcbiAgICB9XG4gIH0pO1xufVxuXG4vKiogQ2hlY2sgaWYgdHdvIHR5cGVzIGNhbiBiZSBhcHBlbmRlZCB0byBlYWNoIG90aGVyLiAqL1xuZnVuY3Rpb24gY2FuQmVBcHBlbmRlZChzdHIxOiBzdHJpbmcsIHN0cjI6IHN0cmluZykge1xuICBsZXQgYXJyID0gW1wibnVtYmVyXCIsIFwiZGF0ZVwiLCBcImRhdGV0aW1lXCIsIFwiY2hlY2tib3hcIl07IC8vVGhlc2UgdmFsdWVzIHNob3VsZCBub3QgYmUgYXBwZW5kZWQuXG4gIGlmIChhcnIuaW5jbHVkZXMoc3RyMSkgfHwgYXJyLmluY2x1ZGVzKHN0cjIpKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKiogQ29udmVydCBzdHJpbmdzIGFuZCBhcnJheXMgaW50byBzaW5nbGUgYXJyYXkuICovXG5mdW5jdGlvbiBtZXJnZUludG9BcnJheXMoLi4uYXJnczogKHN0cmluZyB8IHN0cmluZ1tdKVtdKTogc3RyaW5nW10ge1xuICBjb25zdCBhcnJheXMgPSBhcmdzLm1hcCgoYXJnKSA9PiAoQXJyYXkuaXNBcnJheShhcmcpID8gYXJnIDogW2FyZ10pKTtcblxuICAvLyBGbGF0dGVuIHRoZSBhcnJheVxuICBjb25zdCBmbGF0dGVuZWQgPSBhcnJheXMuZmxhdCgpO1xuXG4gIC8vIFJlbW92ZSBkdXBsaWNhdGVzIHVzaW5nIFNldCBhbmQgc3ByZWFkIGl0IGludG8gYW4gYXJyYXlcbiAgY29uc3QgdW5pcXVlID0gWy4uLm5ldyBTZXQoZmxhdHRlbmVkKV07XG5cbiAgcmV0dXJuIHVuaXF1ZTtcbn0iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQSxtQkFBNEc7OztBQ0E1RyxJQUFBQyxtQkFBMkI7OztBQ0NwQixTQUFTLE9BQU87QUFBQztBQXNDakIsU0FBUyxJQUFJLElBQUk7QUFDdkIsU0FBTyxHQUFHO0FBQ1g7QUFFTyxTQUFTLGVBQWU7QUFDOUIsU0FBTyx1QkFBTyxPQUFPLElBQUk7QUFDMUI7QUFNTyxTQUFTLFFBQVEsS0FBSztBQUM1QixNQUFJLFFBQVEsR0FBRztBQUNoQjtBQU1PLFNBQVMsWUFBWSxPQUFPO0FBQ2xDLFNBQU8sT0FBTyxVQUFVO0FBQ3pCO0FBR08sU0FBUyxlQUFlLEdBQUcsR0FBRztBQUNwQyxTQUFPLEtBQUss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QUlBLElBQU0sdUJBQXVCO0FBQUEsRUFDNUI7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFB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QWMscUNBQVU7QUFFOUIsUUFBSSxDQUFDLGFBQWE7QUFDaEIsVUFBSSx3QkFBTywrQkFBK0IsR0FBSTtBQUM5QztBQUFBLElBQ0Y7QUFFQSxVQUFNLG1CQUFtQixLQUFLLElBQUksY0FBYyxvQkFBb0I7QUFFcEUsUUFBSSxTQUE4RCxDQUFDO0FBRW5FLGFBQVMsQ0FBQyxLQUFLLEtBQUssS0FBSyxPQUFPLFFBQVEsV0FBVyxHQUFHO0FBQ3BELFlBQU0sV0FBVyxJQUFJLFlBQVk7QUFDakMsWUFBTSxNQUFNO0FBQUEsUUFDVixNQUFNO0FBQUEsUUFDTjtBQUFBLFFBQ0EsTUFBTSxpQkFBaUIsUUFBUSxFQUFFO0FBQUEsTUFDbkM7QUFFQSxhQUFPLEtBQUssR0FBRztBQUFBLElBQ2pCO0FBQ0EsV0FBTztBQUFBLEVBQ1Q7QUFBQSxFQUVBLGlCQUFpQixPQUFZO0FBQzNCLFdBQU8sT0FBTyxTQUFnQjtBQUM1QixZQUFNLGNBQWMsS0FBSyxJQUFJLFlBQVksbUJBQW1CLEtBQUssS0FBSyxJQUFJLFdBQVcsR0FBRyxNQUFNLE9BQU8sS0FBSyxTQUFTLFdBQVcsS0FBSyxJQUFJLGNBQWMsb0JBQW9CLENBQUM7QUFBQSxJQUM1SztBQUFBLEVBQ0Y7QUFBQSxFQUVBLG9CQUFvQixPQUFZO0FBQzlCLFdBQU8sT0FBTyxTQUFnQjtBQUM1QixZQUFNLGlCQUFpQixLQUFLLElBQUksWUFBWSxtQkFBbUIsS0FBSyxLQUFLLElBQUksV0FBVyxHQUFHLE1BQU0sS0FBSztBQUFBLElBQ3hHO0FBQUEsRUFDRjtBQUNGOyIsCiAgIm5hbWVzIjogWyJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImVsZW1lbnQiLCAiX2EiLCAiZWxlbWVudCIsICJ0ZXh0IiwgImVsZW1lbnQiLCAiZGV0YWNoIiwgImNyZWF0ZV9lYWNoX2Jsb2NrIiwgImluc2VydCIsICJpbnN0YW5jZSIsICJjcmVhdGVfZnJhZ21lbnQiLCAiYXBwZW5kX3N0eWxlcyIsICJhdHRyIiwgImN0eCIsICJjdHgiLCAiY3R4IiwgImltcG9ydF9vYnNpZGlhbiIsICJ0ZXh0IiwgImltcG9ydF9vYnNpZGlhbiIsICJjdHgiLCAiaW1wb3J0X29ic2lkaWFuIiwgImN0eCJdCn0K
