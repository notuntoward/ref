/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MultiPropPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian8 = require("obsidian");

// src/AddPropModal.ts
var import_obsidian2 = require("obsidian");

// node_modules/svelte/src/runtime/internal/utils.js
function noop() {
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a && typeof a === "object" || typeof a === "function";
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}

// node_modules/svelte/src/runtime/internal/globals.js
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : (
  // @ts-ignore Node typings have this
  global
);

// node_modules/svelte/src/runtime/internal/ResizeObserverSingleton.js
var ResizeObserverSingleton = class _ResizeObserverSingleton {
  /** @param {ResizeObserverOptions} options */
  constructor(options) {
    /**
     * @private
     * @readonly
     * @type {WeakMap<Element, import('./private.js').Listener>}
     */
    __publicField(this, "_listeners", "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0);
    /**
     * @private
     * @type {ResizeObserver}
     */
    __publicField(this, "_observer");
    /** @type {ResizeObserverOptions} */
    __publicField(this, "options");
    this.options = options;
  }
  /**
   * @param {Element} element
   * @param {import('./private.js').Listener} listener
   * @returns {() => void}
   */
  observe(element2, listener) {
    this._listeners.set(element2, listener);
    this._getObserver().observe(element2, this.options);
    return () => {
      this._listeners.delete(element2);
      this._observer.unobserve(element2);
    };
  }
  /**
   * @private
   */
  _getObserver() {
    var _a;
    return (_a = this._observer) != null ? _a : this._observer = new ResizeObserver((entries) => {
      var _a2;
      for (const entry of entries) {
        _ResizeObserverSingleton.entries.set(entry.target, entry);
        (_a2 = this._listeners.get(entry.target)) == null ? void 0 : _a2(entry);
      }
    });
  }
};
ResizeObserverSingleton.entries = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;

// node_modules/svelte/src/runtime/internal/dom.js
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node) return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && /** @type {ShadowRoot} */
  root.host) {
    return (
      /** @type {ShadowRoot} */
      root
    );
  }
  return node.ownerDocument;
}
function append_stylesheet(node, style) {
  append(
    /** @type {Document} */
    node.head || node,
    style
  );
  return style.sheet;
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i]) iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function prevent_default(fn) {
  return function(event) {
    event.preventDefault();
    return fn.call(this, event);
  };
}
function attr(node, attribute, value) {
  if (value == null) node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.data === data) return;
  text2.data = /** @type {string} */
  data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function select_option(select, value, mounting) {
  for (let i = 0; i < select.options.length; i += 1) {
    const option = select.options[i];
    if (option.__value === value) {
      option.selected = true;
      return;
    }
  }
  if (!mounting || value !== void 0) {
    select.selectedIndex = -1;
  }
}
function select_value(select) {
  const selected_option = select.querySelector(":checked");
  return selected_option && selected_option.__value;
}
function get_custom_elements_slots(element2) {
  const result = {};
  element2.childNodes.forEach(
    /** @param {Element} node */
    (node) => {
      result[node.slot || "default"] = true;
    }
  );
  return result;
}

// node_modules/svelte/src/runtime/internal/lifecycle.js
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component) throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function bubble(component, event) {
  const callbacks = component.$$.callbacks[event.type];
  if (callbacks) {
    callbacks.slice().forEach((fn) => fn.call(this, event));
  }
}

// node_modules/svelte/src/runtime/internal/scheduler.js
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = /* @__PURE__ */ Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function tick() {
  schedule_update();
  return resolved_promise;
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
function add_flush_callback(fn) {
  flush_callbacks.push(fn);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length) binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
  targets.forEach((c) => c());
  render_callbacks = filtered;
}

// node_modules/svelte/src/runtime/internal/transitions.js
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block)) return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2) block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}

// node_modules/svelte/src/runtime/internal/each.js
function ensure_array_like(array_like_or_iterator) {
  return (array_like_or_iterator == null ? void 0 : array_like_or_iterator.length) !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
}
function outro_and_destroy_block(block, lookup) {
  transition_out(block, 1, 1, () => {
    lookup.delete(block.key);
  });
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block6, next, get_context) {
  let o = old_blocks.length;
  let n = list.length;
  let i = o;
  const old_indexes = {};
  while (i--) old_indexes[old_blocks[i].key] = i;
  const new_blocks = [];
  const new_lookup = /* @__PURE__ */ new Map();
  const deltas = /* @__PURE__ */ new Map();
  const updates = [];
  i = n;
  while (i--) {
    const child_ctx = get_context(ctx, list, i);
    const key = get_key(child_ctx);
    let block = lookup.get(key);
    if (!block) {
      block = create_each_block6(key, child_ctx);
      block.c();
    } else if (dynamic) {
      updates.push(() => block.p(child_ctx, dirty));
    }
    new_lookup.set(key, new_blocks[i] = block);
    if (key in old_indexes) deltas.set(key, Math.abs(i - old_indexes[key]));
  }
  const will_move = /* @__PURE__ */ new Set();
  const did_move = /* @__PURE__ */ new Set();
  function insert2(block) {
    transition_in(block, 1);
    block.m(node, next);
    lookup.set(block.key, block);
    next = block.first;
    n--;
  }
  while (o && n) {
    const new_block = new_blocks[n - 1];
    const old_block = old_blocks[o - 1];
    const new_key = new_block.key;
    const old_key = old_block.key;
    if (new_block === old_block) {
      next = new_block.first;
      o--;
      n--;
    } else if (!new_lookup.has(old_key)) {
      destroy(old_block, lookup);
      o--;
    } else if (!lookup.has(new_key) || will_move.has(new_key)) {
      insert2(new_block);
    } else if (did_move.has(old_key)) {
      o--;
    } else if (deltas.get(new_key) > deltas.get(old_key)) {
      did_move.add(new_key);
      insert2(new_block);
    } else {
      will_move.add(old_key);
      o--;
    }
  }
  while (o--) {
    const old_block = old_blocks[o];
    if (!new_lookup.has(old_block.key)) destroy(old_block, lookup);
  }
  while (n) insert2(new_blocks[n - 1]);
  run_all(updates);
  return new_blocks;
}

// node_modules/svelte/src/shared/boolean_attributes.js
var _boolean_attributes = (
  /** @type {const} */
  [
    "allowfullscreen",
    "allowpaymentrequest",
    "async",
    "autofocus",
    "autoplay",
    "checked",
    "controls",
    "default",
    "defer",
    "disabled",
    "formnovalidate",
    "hidden",
    "inert",
    "ismap",
    "loop",
    "multiple",
    "muted",
    "nomodule",
    "novalidate",
    "open",
    "playsinline",
    "readonly",
    "required",
    "reversed",
    "selected"
  ]
);
var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);

// node_modules/svelte/src/runtime/internal/Component.js
function bind(component, name, callback) {
  const index = component.$$.props[name];
  if (index !== void 0) {
    component.$$.bound[index] = callback;
    callback(component.$$.ctx[index]);
  }
}
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  add_render_callback(() => {
    const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
    if (component.$$.on_destroy) {
      component.$$.on_destroy.push(...new_on_destroy);
    } else {
      run_all(new_on_destroy);
    }
    component.$$.on_mount = [];
  });
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance6, create_fragment6, not_equal, props, append_styles2 = null, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance6 ? instance6(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);
      if (ready) make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment6 ? create_fragment6($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro) transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor($$componentCtor, $$slots, use_shadow_dom) {
      super();
      /** The Svelte component constructor */
      __publicField(this, "$$ctor");
      /** Slots */
      __publicField(this, "$$s");
      /** The Svelte component instance */
      __publicField(this, "$$c");
      /** Whether or not the custom element is connected */
      __publicField(this, "$$cn", false);
      /** Component props data */
      __publicField(this, "$$d", {});
      /** `true` if currently in the process of reflecting component props back to attributes */
      __publicField(this, "$$r", false);
      /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
      __publicField(this, "$$p_d", {});
      /** @type {Record<string, Function[]>} Event listeners */
      __publicField(this, "$$l", {});
      /** @type {Map<Function, Function>} Event listener unsubscribe functions */
      __publicField(this, "$$l_u", /* @__PURE__ */ new Map());
      this.$$ctor = $$componentCtor;
      this.$$s = $$slots;
      if (use_shadow_dom) {
        this.attachShadow({ mode: "open" });
      }
    }
    addEventListener(type, listener, options) {
      this.$$l[type] = this.$$l[type] || [];
      this.$$l[type].push(listener);
      if (this.$$c) {
        const unsub = this.$$c.$on(type, listener);
        this.$$l_u.set(listener, unsub);
      }
      super.addEventListener(type, listener, options);
    }
    removeEventListener(type, listener, options) {
      super.removeEventListener(type, listener, options);
      if (this.$$c) {
        const unsub = this.$$l_u.get(listener);
        if (unsub) {
          unsub();
          this.$$l_u.delete(listener);
        }
      }
      if (this.$$l[type]) {
        const idx = this.$$l[type].indexOf(listener);
        if (idx >= 0) {
          this.$$l[type].splice(idx, 1);
        }
      }
    }
    async connectedCallback() {
      this.$$cn = true;
      if (!this.$$c) {
        let create_slot = function(name) {
          return () => {
            let node;
            const obj = {
              c: function create() {
                node = element("slot");
                if (name !== "default") {
                  attr(node, "name", name);
                }
              },
              /**
               * @param {HTMLElement} target
               * @param {HTMLElement} [anchor]
               */
              m: function mount(target, anchor) {
                insert(target, node, anchor);
              },
              d: function destroy(detaching) {
                if (detaching) {
                  detach(node);
                }
              }
            };
            return obj;
          };
        };
        await Promise.resolve();
        if (!this.$$cn || this.$$c) {
          return;
        }
        const $$slots = {};
        const existing_slots = get_custom_elements_slots(this);
        for (const name of this.$$s) {
          if (name in existing_slots) {
            $$slots[name] = [create_slot(name)];
          }
        }
        for (const attribute of this.attributes) {
          const name = this.$$g_p(attribute.name);
          if (!(name in this.$$d)) {
            this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, "toProp");
          }
        }
        for (const key in this.$$p_d) {
          if (!(key in this.$$d) && this[key] !== void 0) {
            this.$$d[key] = this[key];
            delete this[key];
          }
        }
        this.$$c = new this.$$ctor({
          target: this.shadowRoot || this,
          props: {
            ...this.$$d,
            $$slots,
            $$scope: {
              ctx: []
            }
          }
        });
        const reflect_attributes = () => {
          this.$$r = true;
          for (const key in this.$$p_d) {
            this.$$d[key] = this.$$c.$$.ctx[this.$$c.$$.props[key]];
            if (this.$$p_d[key].reflect) {
              const attribute_value = get_custom_element_value(
                key,
                this.$$d[key],
                this.$$p_d,
                "toAttribute"
              );
              if (attribute_value == null) {
                this.removeAttribute(this.$$p_d[key].attribute || key);
              } else {
                this.setAttribute(this.$$p_d[key].attribute || key, attribute_value);
              }
            }
          }
          this.$$r = false;
        };
        this.$$c.$$.after_update.push(reflect_attributes);
        reflect_attributes();
        for (const type in this.$$l) {
          for (const listener of this.$$l[type]) {
            const unsub = this.$$c.$on(type, listener);
            this.$$l_u.set(listener, unsub);
          }
        }
        this.$$l = {};
      }
    }
    // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
    // and setting attributes through setAttribute etc, this is helpful
    attributeChangedCallback(attr2, _oldValue, newValue) {
      var _a;
      if (this.$$r) return;
      attr2 = this.$$g_p(attr2);
      this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, "toProp");
      (_a = this.$$c) == null ? void 0 : _a.$set({ [attr2]: this.$$d[attr2] });
    }
    disconnectedCallback() {
      this.$$cn = false;
      Promise.resolve().then(() => {
        if (!this.$$cn && this.$$c) {
          this.$$c.$destroy();
          this.$$c = void 0;
        }
      });
    }
    $$g_p(attribute_name) {
      return Object.keys(this.$$p_d).find(
        (key) => this.$$p_d[key].attribute === attribute_name || !this.$$p_d[key].attribute && key.toLowerCase() === attribute_name
      ) || attribute_name;
    }
  };
}
function get_custom_element_value(prop, value, props_definition, transform) {
  var _a;
  const type = (_a = props_definition[prop]) == null ? void 0 : _a.type;
  value = type === "Boolean" && typeof value !== "boolean" ? value != null : value;
  if (!transform || !props_definition[prop]) {
    return value;
  } else if (transform === "toAttribute") {
    switch (type) {
      case "Object":
      case "Array":
        return value == null ? null : JSON.stringify(value);
      case "Boolean":
        return value ? "" : null;
      case "Number":
        return value == null ? null : value;
      default:
        return value;
    }
  } else {
    switch (type) {
      case "Object":
      case "Array":
        return value && JSON.parse(value);
      case "Boolean":
        return value;
      // conversion already handled above
      case "Number":
        return value != null ? +value : value;
      default:
        return value;
    }
  }
}
var SvelteComponent = class {
  constructor() {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$");
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1) callbacks.splice(index, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(props) {
    if (this.$$set && !is_empty(props)) {
      this.$$.skip_bound = true;
      this.$$set(props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/svelte/src/shared/version.js
var PUBLIC_VERSION = "4";

// node_modules/svelte/src/runtime/internal/disclose-version/index.js
if (typeof window !== "undefined")
  (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);

// node_modules/tslib/tslib.es6.js
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// src/AddPropInput.svelte
function add_css(target) {
  append_styles(target, "svelte-33qhuc", "input.svelte-33qhuc{max-height:25px;overflow-x:auto}select.svelte-33qhuc{height:21px}#name-input.svelte-33qhuc{flex-grow:0;width:auto}.modal-input-container.svelte-33qhuc{width:95%;display:flex;flex-direction:row;align-items:center;gap:10px;margin-top:10px}.btn-inactive.svelte-33qhuc{cursor:not-allowed;pointer-events:none;opacity:0.7}");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[19] = list[i];
  return child_ctx;
}
function create_each_block(ctx) {
  let option;
  let t_value = (
    /*key*/
    ctx[19] + ""
  );
  let t;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = option_value_value = /*options*/
      ctx[8][
        /*key*/
        ctx[19]
      ];
      set_input_value(option, option.__value);
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(option);
      }
    }
  };
}
function create_fragment(ctx) {
  let div;
  let button;
  let t0;
  let button_class_value;
  let button_tabindex_value;
  let t1;
  let select;
  let t2;
  let input0;
  let t3;
  let input1;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(Object.keys(
    /*options*/
    ctx[8]
  ));
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  return {
    c() {
      div = element("div");
      button = element("button");
      t0 = text("X");
      t1 = space();
      select = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t2 = space();
      input0 = element("input");
      t3 = space();
      input1 = element("input");
      attr(button, "type", "button");
      attr(button, "id", "del-btn");
      attr(button, "class", button_class_value = "btn-del " + /*isFirst*/
      (ctx[2] ? "btn-inactive" : "") + " svelte-33qhuc");
      attr(button, "tabindex", button_tabindex_value = /*isFirst*/
      ctx[2] ? -1 : 0);
      attr(select, "id", "type-input");
      attr(select, "class", "flex-obj svelte-33qhuc");
      if (
        /*optionVal*/
        ctx[7] === void 0
      ) add_render_callback(() => (
        /*select_change_handler*/
        ctx[12].call(select)
      ));
      attr(input0, "id", "name-input");
      attr(input0, "class", "name-input flex-obj svelte-33qhuc");
      attr(input0, "type", "text");
      attr(input0, "name", "name[]");
      attr(input0, "placeholder", "name");
      input0.required = true;
      attr(input1, "id", "value-input");
      attr(input1, "type", "text");
      attr(input1, "name", "value[]");
      attr(input1, "placeholder", "value");
      attr(input1, "class", "value-input flex-obj svelte-33qhuc");
      attr(div, "class", "modal-input-container svelte-33qhuc");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      append(button, t0);
      append(div, t1);
      append(div, select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select, null);
        }
      }
      select_option(
        select,
        /*optionVal*/
        ctx[7],
        true
      );
      append(div, t2);
      append(div, input0);
      ctx[14](input0);
      set_input_value(
        input0,
        /*nameVal*/
        ctx[0]
      );
      append(div, t3);
      append(div, input1);
      ctx[16](input1);
      set_input_value(
        input1,
        /*valueVal*/
        ctx[1]
      );
      if (!mounted) {
        dispose = [
          listen(
            button,
            "click",
            /*click_handler*/
            ctx[11]
          ),
          listen(
            select,
            "change",
            /*select_change_handler*/
            ctx[12]
          ),
          listen(
            select,
            "change",
            /*change_handler*/
            ctx[13]
          ),
          listen(
            input0,
            "input",
            /*input0_input_handler*/
            ctx[15]
          ),
          listen(
            input1,
            "input",
            /*input1_input_handler*/
            ctx[17]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*isFirst*/
      4 && button_class_value !== (button_class_value = "btn-del " + /*isFirst*/
      (ctx2[2] ? "btn-inactive" : "") + " svelte-33qhuc")) {
        attr(button, "class", button_class_value);
      }
      if (dirty & /*isFirst*/
      4 && button_tabindex_value !== (button_tabindex_value = /*isFirst*/
      ctx2[2] ? -1 : 0)) {
        attr(button, "tabindex", button_tabindex_value);
      }
      if (dirty & /*options, Object*/
      256) {
        each_value = ensure_array_like(Object.keys(
          /*options*/
          ctx2[8]
        ));
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*optionVal, options, Object*/
      384) {
        select_option(
          select,
          /*optionVal*/
          ctx2[7]
        );
      }
      if (dirty & /*nameVal*/
      1 && input0.value !== /*nameVal*/
      ctx2[0]) {
        set_input_value(
          input0,
          /*nameVal*/
          ctx2[0]
        );
      }
      if (dirty & /*valueVal*/
      2 && input1.value !== /*valueVal*/
      ctx2[1]) {
        set_input_value(
          input1,
          /*valueVal*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
      ctx[14](null);
      ctx[16](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let { isFirst } = $$props;
  let { removeInput } = $$props;
  let { id } = $$props;
  let { typeVal = "text" } = $$props;
  let { nameVal = "" } = $$props;
  let { valueVal = "" } = $$props;
  let inputEl;
  let valueEl;
  let optionVal;
  const options = {
    Text: "string",
    Number: "number",
    Checkbox: "checkbox",
    Date: "date",
    Datetime: "datetime-local"
  };
  const convertProps = {
    text: "Text",
    multitext: "Text",
    number: "Number",
    checkbox: "Checkbox",
    date: "Date",
    datetime: "Datetime"
  };
  onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    yield tick();
    inputEl.focus();
    inputEl.select();
    $$invalidate(7, optionVal = options[convertProps[typeVal]]);
  }));
  function changeType(type) {
    $$invalidate(6, valueEl.type = type, valueEl);
  }
  const click_handler = () => {
    if (!isFirst) {
      removeInput(id);
    }
  };
  function select_change_handler() {
    optionVal = select_value(this);
    $$invalidate(7, optionVal);
    $$invalidate(8, options);
  }
  const change_handler = () => changeType(optionVal);
  function input0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputEl = $$value;
      $$invalidate(5, inputEl);
    });
  }
  function input0_input_handler() {
    nameVal = this.value;
    $$invalidate(0, nameVal);
  }
  function input1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      valueEl = $$value;
      $$invalidate(6, valueEl);
    });
  }
  function input1_input_handler() {
    valueVal = this.value;
    $$invalidate(1, valueVal);
  }
  $$self.$$set = ($$props2) => {
    if ("isFirst" in $$props2) $$invalidate(2, isFirst = $$props2.isFirst);
    if ("removeInput" in $$props2) $$invalidate(3, removeInput = $$props2.removeInput);
    if ("id" in $$props2) $$invalidate(4, id = $$props2.id);
    if ("typeVal" in $$props2) $$invalidate(10, typeVal = $$props2.typeVal);
    if ("nameVal" in $$props2) $$invalidate(0, nameVal = $$props2.nameVal);
    if ("valueVal" in $$props2) $$invalidate(1, valueVal = $$props2.valueVal);
  };
  return [
    nameVal,
    valueVal,
    isFirst,
    removeInput,
    id,
    inputEl,
    valueEl,
    optionVal,
    options,
    changeType,
    typeVal,
    click_handler,
    select_change_handler,
    change_handler,
    input0_binding,
    input0_input_handler,
    input1_binding,
    input1_input_handler
  ];
}
var AddPropInput = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        isFirst: 2,
        removeInput: 3,
        id: 4,
        typeVal: 10,
        nameVal: 0,
        valueVal: 1
      },
      add_css
    );
  }
};
var AddPropInput_default = AddPropInput;

// src/helpers.ts
function parseValue(input, type) {
  switch (type) {
    case "number":
      return Number(input.value);
    case "checkbox":
      return Boolean(input.checked);
    default:
      return input.value;
  }
}
function removeExtraCommas(str) {
  return str.replace(/^,*(.*?),*$/g, "$1").replace(/,{2,}/g, ",");
}
function cleanTags(str) {
  let cleanStr = str;
  for (let index in KNOWN_BAD_CHARACTERS) {
    cleanStr = cleanStr.replaceAll(KNOWN_BAD_CHARACTERS[index], "");
  }
  return cleanStr;
}
var KNOWN_BAD_CHARACTERS = [
  "\u2012",
  "\u2013",
  "\u2014",
  "\u2015",
  "\u204F",
  "\u203D",
  "\u2018",
  "\u201A",
  "\u201B",
  "\u2039",
  "\u203A",
  "\u201C",
  "\u201D",
  "\u201E",
  "\u201F",
  "\u2045",
  "\u2046",
  "\u204B",
  "\u204E",
  "\u2051",
  "\u2044",
  "\u204A",
  "\u2030",
  "\u2031",
  "\u2052",
  "\u2020",
  "\u2021",
  "\u2022",
  "\u2023",
  "\u2043",
  "\u204C",
  "\u204D",
  "\u2032",
  "\u2035",
  "\u2038",
  "\u203B",
  "\u2050",
  "\u2041",
  "\u2042",
  "\u2016",
  "\u2011",
  "\u2033",
  "\u2034",
  "\u2057",
  "\u2036",
  "\u2037",
  "`",
  "^",
  "\u203E",
  "\u2017",
  "\u2053",
  ";",
  ":",
  "!",
  "\u203C",
  "\u2049",
  "?",
  "\u2048",
  "\u2047",
  ".",
  "\u2024",
  "\u2025",
  "\u2026",
  "'",
  '"',
  "(",
  ")",
  "[",
  "]",
  "{",
  "}",
  "@",
  "*",
  "&",
  "%",
  "\u2054",
  "+",
  "<",
  "=",
  ">",
  "|",
  "~",
  "$",
  "\u2055",
  "\u2056",
  "\u2058",
  "\u2059",
  "\u205A",
  "\u205B",
  "\u205C",
  "\u205D",
  "\u205E",
  "\u2E00",
  "\u2E01",
  "\u2E02",
  "\u2E03",
  "\u2E04",
  "\u2E05",
  "\u2E06",
  "\u2E07",
  "\u2E08",
  "\u2E09",
  "\u2E0A",
  "\u2E0B",
  "\u2E0C",
  "\u2E0D",
  "\u2E0E",
  "\u2E0F",
  "\u2E10",
  "\u2E11",
  "\u2E12",
  "\u2E13",
  "\u2E14",
  "\u2E15",
  "\u2E16",
  "\u2E17",
  "\u2E1C",
  "\u2E1D",
  " ",
  "#"
];

// src/AddPropForm.svelte
var { Map: Map_1 } = globals;
function add_css2(target) {
  append_styles(target, "svelte-1lpixw8", ".modal-inputs-container.svelte-1lpixw8{height:200px;width:100%;overflow-y:scroll;border-radius:5px;border-style:solid;display:flex;flex-direction:column;align-items:center}.modal-add-container.svelte-1lpixw8{margin-top:10px}.alert-container.svelte-1lpixw8{display:flex;flex-direction:column;align-items:center;justify-content:center;margin-bottom:10px;background-color:red;font-weight:bold}.hidden.svelte-1lpixw8{display:none}");
}
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i];
  child_ctx[24] = list;
  child_ctx[25] = i;
  return child_ctx;
}
function create_each_block2(key_1, ctx) {
  let first;
  let propinput;
  let updating_typeVal;
  let updating_nameVal;
  let updating_valueVal;
  let current;
  function propinput_typeVal_binding(value) {
    ctx[15](
      value,
      /*input*/
      ctx[23]
    );
  }
  function propinput_nameVal_binding(value) {
    ctx[16](
      value,
      /*input*/
      ctx[23]
    );
  }
  function propinput_valueVal_binding(value) {
    ctx[17](
      value,
      /*input*/
      ctx[23]
    );
  }
  let propinput_props = {
    isFirst: (
      /*input*/
      ctx[23].isFirst
    ),
    id: (
      /*input*/
      ctx[23].id
    ),
    removeInput: (
      /*removeInput*/
      ctx[8]
    )
  };
  if (
    /*input*/
    ctx[23].typeDef !== void 0
  ) {
    propinput_props.typeVal = /*input*/
    ctx[23].typeDef;
  }
  if (
    /*input*/
    ctx[23].nameDef !== void 0
  ) {
    propinput_props.nameVal = /*input*/
    ctx[23].nameDef;
  }
  if (
    /*input*/
    ctx[23].valueDef !== void 0
  ) {
    propinput_props.valueVal = /*input*/
    ctx[23].valueDef;
  }
  propinput = new AddPropInput_default({ props: propinput_props });
  binding_callbacks.push(() => bind(propinput, "typeVal", propinput_typeVal_binding));
  binding_callbacks.push(() => bind(propinput, "nameVal", propinput_nameVal_binding));
  binding_callbacks.push(() => bind(propinput, "valueVal", propinput_valueVal_binding));
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(propinput.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(propinput, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const propinput_changes = {};
      if (dirty & /*inputEls*/
      32) propinput_changes.isFirst = /*input*/
      ctx[23].isFirst;
      if (dirty & /*inputEls*/
      32) propinput_changes.id = /*input*/
      ctx[23].id;
      if (!updating_typeVal && dirty & /*inputEls*/
      32) {
        updating_typeVal = true;
        propinput_changes.typeVal = /*input*/
        ctx[23].typeDef;
        add_flush_callback(() => updating_typeVal = false);
      }
      if (!updating_nameVal && dirty & /*inputEls*/
      32) {
        updating_nameVal = true;
        propinput_changes.nameVal = /*input*/
        ctx[23].nameDef;
        add_flush_callback(() => updating_nameVal = false);
      }
      if (!updating_valueVal && dirty & /*inputEls*/
      32) {
        updating_valueVal = true;
        propinput_changes.valueVal = /*input*/
        ctx[23].valueDef;
        add_flush_callback(() => updating_valueVal = false);
      }
      propinput.$set(propinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(propinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(propinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(propinput, detaching);
    }
  };
}
function create_fragment2(ctx) {
  let div6;
  let div2;
  let div0;
  let t1;
  let div1;
  let t2;
  let t3;
  let p0;
  let t5;
  let p1;
  let t6;
  let t7;
  let t8;
  let t9;
  let p2;
  let t11;
  let form;
  let label;
  let input_1;
  let t12_value = "Overwrite existing properties";
  let t12;
  let t13;
  let div3;
  let each_blocks = [];
  let each_1_lookup = new Map_1();
  let t14;
  let div4;
  let button0;
  let t16;
  let div5;
  let button1;
  let current;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*inputEls*/
    ctx[5]
  );
  const get_key = (ctx2) => (
    /*input*/
    ctx2[23].id
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context2(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block2(key, child_ctx));
  }
  return {
    c() {
      div6 = element("div");
      div2 = element("div");
      div0 = element("div");
      div0.textContent = "ERROR";
      t1 = space();
      div1 = element("div");
      t2 = text(
        /*alertText*/
        ctx[4]
      );
      t3 = space();
      p0 = element("p");
      p0.textContent = "Type in a property name, then value. Use the dropbox to choose what type of\n    data you wish to store.";
      t5 = space();
      p1 = element("p");
      t6 = text('If you want to make a List property, use the Text data type and separate\n    each value with a "');
      t7 = text(
        /*delimiter*/
        ctx[1]
      );
      t8 = text('".');
      t9 = space();
      p2 = element("p");
      p2.textContent = 'If you want to add Tags, use the name "tags".';
      t11 = space();
      form = element("form");
      label = element("label");
      input_1 = element("input");
      t12 = text(t12_value);
      t13 = space();
      div3 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t14 = space();
      div4 = element("div");
      button0 = element("button");
      button0.textContent = "Add";
      t16 = space();
      div5 = element("div");
      button1 = element("button");
      button1.textContent = "Submit";
      attr(div1, "id", "alert-text");
      attr(div2, "id", "alert-container");
      attr(div2, "class", "alert-container hidden svelte-1lpixw8");
      attr(input_1, "type", "checkbox");
      input_1.checked = /*overwrite*/
      ctx[0];
      attr(div3, "class", "modal-inputs-container svelte-1lpixw8");
      attr(button0, "type", "button");
      attr(button0, "class", "a-btn");
      attr(div4, "class", "modal-add-container svelte-1lpixw8");
      attr(button1, "class", "btn-submit");
      attr(div5, "class", "modal-button-container");
      attr(div6, "id", "multi-properties-modal");
      attr(div6, "class", "modal-content");
    },
    m(target, anchor) {
      insert(target, div6, anchor);
      append(div6, div2);
      append(div2, div0);
      append(div2, t1);
      append(div2, div1);
      append(div1, t2);
      ctx[14](div2);
      append(div6, t3);
      append(div6, p0);
      append(div6, t5);
      append(div6, p1);
      append(p1, t6);
      append(p1, t7);
      append(p1, t8);
      append(div6, t9);
      append(div6, p2);
      append(div6, t11);
      append(div6, form);
      append(form, label);
      append(label, input_1);
      append(label, t12);
      append(form, t13);
      append(form, div3);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div3, null);
        }
      }
      append(form, t14);
      append(form, div4);
      append(div4, button0);
      append(form, t16);
      append(form, div5);
      append(div5, button1);
      ctx[19](form);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input_1,
            "change",
            /*onCheckboxChange*/
            ctx[6]
          ),
          listen(
            button0,
            "click",
            /*click_handler*/
            ctx[18]
          ),
          listen(
            button1,
            "click",
            /*onSubmit*/
            ctx[9]
          ),
          listen(form, "submit", prevent_default(
            /*submit_handler*/
            ctx[13]
          ))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*alertText*/
      16) set_data(
        t2,
        /*alertText*/
        ctx2[4]
      );
      if (!current || dirty & /*delimiter*/
      2) set_data(
        t7,
        /*delimiter*/
        ctx2[1]
      );
      if (!current || dirty & /*overwrite*/
      1) {
        input_1.checked = /*overwrite*/
        ctx2[0];
      }
      if (dirty & /*inputEls, removeInput*/
      288) {
        each_value = ensure_array_like(
          /*inputEls*/
          ctx2[5]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div3, outro_and_destroy_block, create_each_block2, null, get_each_context2);
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div6);
      }
      ctx[14](null);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      ctx[19](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let { submission } = $$props;
  let { overwrite } = $$props;
  let { delimiter } = $$props;
  let { defaultProps } = $$props;
  let { changeBool } = $$props;
  let countInputs = 0;
  let formEl;
  let errorEl;
  let alertText = ".";
  let inputEls = [];
  function onCheckboxChange() {
    $$invalidate(0, overwrite = !overwrite);
    changeBool(overwrite);
  }
  onMount(() => {
    defaultProps.length > 0 ? addInputs(defaultProps) : addInputs([{ type: "text", name: "", value: "" }]);
  });
  function addInputs(inputs = [{ type: "text", name: "", value: "" }]) {
    let arr = [];
    for (let input of inputs) {
      countInputs++;
      arr.push({
        id: countInputs,
        isFirst: countInputs === 1 ? true : false,
        typeDef: input.type,
        nameDef: input.name,
        valueDef: input.value
      });
    }
    $$invalidate(5, inputEls = [...inputEls, ...arr]);
  }
  function removeInput(id) {
    return __awaiter(this, void 0, void 0, function* () {
      $$invalidate(5, inputEls = inputEls.filter((input) => input.id !== id));
      yield tick();
      let inputs = formEl.querySelectorAll("input");
      if (!inputs) return;
      inputs[inputs.length - 2].focus();
    });
  }
  function checkDuplicateNames() {
    let set = /* @__PURE__ */ new Set();
    for (let input of inputEls) set.add(input.nameDef);
    if (set.size < inputEls.length) return true;
    else return false;
  }
  function runError(errorText) {
    $$invalidate(4, alertText = errorText);
    errorEl.classList.remove("hidden");
  }
  function onSubmit() {
    if (checkDuplicateNames()) {
      runError("Duplicate property names are not allowed.");
      return;
    }
    let obj = /* @__PURE__ */ new Map();
    let inputs = formEl.querySelectorAll('input[name^="name[]"]');
    inputs.forEach((input) => {
      var _a;
      if (!(input.nextElementSibling instanceof HTMLInputElement)) return;
      if (!(input.previousElementSibling instanceof HTMLSelectElement)) return;
      if (!(input.previousElementSibling.children[0] instanceof HTMLOptionElement)) return;
      let name = input.value;
      if (name === "") {
        input.reportValidity();
        return;
      }
      const selectEl = input.previousElementSibling;
      const htmlType = selectEl.value;
      const reverseOptions = {
        "string": "text",
        "number": "number",
        "checkbox": "checkbox",
        "date": "date",
        "datetime-local": "datetime"
      };
      const obsidianType = (_a = reverseOptions[htmlType]) !== null && _a !== void 0 ? _a : "text";
      let value = parseValue(input.nextElementSibling, input.nextElementSibling.type);
      if (typeof value === "string") {
        if (name === "tags") {
          value = cleanTags(value);
        }
        if (typeof value === "string" && value.includes(",")) {
          let str = removeExtraCommas(value);
          value = str.split(delimiter);
        }
      }
      if (value === "") value = null;
      let propObj = {
        type: obsidianType,
        data: value,
        overwrite: false,
        delimiter
      };
      obj.set(name, propObj);
    });
    if (obj.size < inputs.length) return;
    console.log(obj);
    submission(obj);
  }
  function submit_handler(event) {
    bubble.call(this, $$self, event);
  }
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      errorEl = $$value;
      $$invalidate(3, errorEl);
    });
  }
  function propinput_typeVal_binding(value, input) {
    if ($$self.$$.not_equal(input.typeDef, value)) {
      input.typeDef = value;
      $$invalidate(5, inputEls);
    }
  }
  function propinput_nameVal_binding(value, input) {
    if ($$self.$$.not_equal(input.nameDef, value)) {
      input.nameDef = value;
      $$invalidate(5, inputEls);
    }
  }
  function propinput_valueVal_binding(value, input) {
    if ($$self.$$.not_equal(input.valueDef, value)) {
      input.valueDef = value;
      $$invalidate(5, inputEls);
    }
  }
  const click_handler = () => addInputs([{ type: "text", name: "", value: "" }]);
  function form_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      formEl = $$value;
      $$invalidate(2, formEl);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("submission" in $$props2) $$invalidate(10, submission = $$props2.submission);
    if ("overwrite" in $$props2) $$invalidate(0, overwrite = $$props2.overwrite);
    if ("delimiter" in $$props2) $$invalidate(1, delimiter = $$props2.delimiter);
    if ("defaultProps" in $$props2) $$invalidate(11, defaultProps = $$props2.defaultProps);
    if ("changeBool" in $$props2) $$invalidate(12, changeBool = $$props2.changeBool);
  };
  return [
    overwrite,
    delimiter,
    formEl,
    errorEl,
    alertText,
    inputEls,
    onCheckboxChange,
    addInputs,
    removeInput,
    onSubmit,
    submission,
    defaultProps,
    changeBool,
    submit_handler,
    div2_binding,
    propinput_typeVal_binding,
    propinput_nameVal_binding,
    propinput_valueVal_binding,
    click_handler,
    form_binding
  ];
}
var AddPropForm = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance2,
      create_fragment2,
      safe_not_equal,
      {
        submission: 10,
        overwrite: 0,
        delimiter: 1,
        defaultProps: 11,
        changeBool: 12
      },
      add_css2
    );
  }
};
var AddPropForm_default = AddPropForm;

// src/AddConfirmModal.ts
var import_obsidian = require("obsidian");

// src/AddConfirmForm.svelte
function add_css3(target) {
  append_styles(target, "svelte-vt02cj", ".msg.svelte-vt02cj{font-weight:bold;padding-bottom:10px}");
}
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i][0];
  child_ctx[8] = list[i][1];
  return child_ctx;
}
function create_each_block3(ctx) {
  let li;
  let t0_value = (
    /*propName*/
    ctx[7] + ""
  );
  let t0;
  let t1;
  let t2_value = (
    /*prop*/
    ctx[8].data + ""
  );
  let t2;
  let t3;
  return {
    c() {
      li = element("li");
      t0 = text(t0_value);
      t1 = text(": ");
      t2 = text(t2_value);
      t3 = space();
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, t0);
      append(li, t1);
      append(li, t2);
      append(li, t3);
    },
    p(ctx2, dirty) {
      if (dirty & /*props*/
      1 && t0_value !== (t0_value = /*propName*/
      ctx2[7] + "")) set_data(t0, t0_value);
      if (dirty & /*props*/
      1 && t2_value !== (t2_value = /*prop*/
      ctx2[8].data + "")) set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
    }
  };
}
function create_fragment3(ctx) {
  let div;
  let form;
  let p0;
  let t1;
  let p1;
  let t3;
  let ul;
  let t4;
  let p2;
  let t6;
  let button0;
  let t8;
  let button1;
  let mounted;
  let dispose;
  let each_value = ensure_array_like([.../*props*/
  ctx[0]]);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  return {
    c() {
      div = element("div");
      form = element("form");
      p0 = element("p");
      p0.textContent = `${/*msg*/
      ctx[4]}`;
      t1 = space();
      p1 = element("p");
      p1.textContent = "The following props will be added:";
      t3 = space();
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t4 = space();
      p2 = element("p");
      p2.textContent = "Are you sure you wish to proceed?";
      t6 = space();
      button0 = element("button");
      button0.textContent = "Confirm";
      t8 = space();
      button1 = element("button");
      button1.textContent = "Cancel";
      attr(p0, "class", "msg svelte-vt02cj");
      attr(button0, "class", "mod-warning");
      attr(button0, "type", "submit");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, form);
      append(form, p0);
      append(form, t1);
      append(form, p1);
      append(form, t3);
      append(form, ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ul, null);
        }
      }
      append(form, t4);
      append(form, p2);
      append(form, t6);
      append(form, button0);
      append(form, t8);
      append(form, button1);
      ctx[6](button1);
      if (!mounted) {
        dispose = [
          listen(button1, "click", function() {
            if (is_function(
              /*cancel*/
              ctx[2]
            )) ctx[2].apply(this, arguments);
          }),
          listen(form, "submit", prevent_default(function() {
            if (is_function(
              /*submission*/
              ctx[1]
            )) ctx[1].apply(this, arguments);
          }))
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (dirty & /*props*/
      1) {
        each_value = ensure_array_like([.../*props*/
        ctx[0]]);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ul, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
      ctx[6](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance3($$self, $$props, $$invalidate) {
  let { props } = $$props;
  let { overwrite = true } = $$props;
  let { submission } = $$props;
  let { cancel } = $$props;
  let btnCancel;
  const msg = overwrite ? "Any pre-existing text props will have their values overwritten." : "Any pre-existing text props will have their values be appended to.";
  onMount(() => {
    btnCancel.focus();
  });
  function button1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      btnCancel = $$value;
      $$invalidate(3, btnCancel);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("props" in $$props2) $$invalidate(0, props = $$props2.props);
    if ("overwrite" in $$props2) $$invalidate(5, overwrite = $$props2.overwrite);
    if ("submission" in $$props2) $$invalidate(1, submission = $$props2.submission);
    if ("cancel" in $$props2) $$invalidate(2, cancel = $$props2.cancel);
  };
  return [props, submission, cancel, btnCancel, msg, overwrite, button1_binding];
}
var AddConfirmForm = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance3,
      create_fragment3,
      safe_not_equal,
      {
        props: 0,
        overwrite: 5,
        submission: 1,
        cancel: 2
      },
      add_css3
    );
  }
};
var AddConfirmForm_default = AddConfirmForm;

// src/AddConfirmModal.ts
var AddConfirmModal = class extends import_obsidian.Modal {
  constructor(app, props, overwrite, submission) {
    super(app);
    this.props = props;
    this.overwrite = overwrite;
    this.submission = submission;
  }
  async onSubmit() {
    await this.submission(true);
    this.close();
  }
  onCancel() {
    this.submission(false);
    this.close();
  }
  onOpen() {
    this.titleEl.createEl("h2", { text: "Add Properties" });
    this.component = new AddConfirmForm_default({
      target: this.contentEl,
      props: {
        props: this.props,
        overwrite: this.overwrite,
        submission: this.onSubmit.bind(this),
        cancel: this.onCancel.bind(this)
      }
    });
  }
};

// src/AddPropModal.ts
var PropModal = class extends import_obsidian2.Modal {
  constructor(app, submission, overwrite, delimiter, defaultProps, changeBool) {
    super(app);
    this.submission = submission;
    this.overwrite = overwrite;
    this.delimiter = delimiter;
    this.defaultProps = defaultProps;
    this.changeBool = changeBool;
  }
  //Run form submission if user clicks confirm.
  async onConfirm(bool) {
    if (bool) {
      await this.submission(this.props);
      this.close();
    }
  }
  updateBool(bool) {
    this.overwrite = bool;
    this.changeBool(bool);
  }
  //Pull up confirmation form when user submits base form.
  onSubmit(props) {
    this.props = props;
    new AddConfirmModal(
      this.app,
      this.props,
      this.overwrite,
      this.onConfirm.bind(this)
    ).open();
  }
  onOpen() {
    this.titleEl.createEl("h2", { text: "Add Properties" });
    this.component = new AddPropForm_default({
      target: this.contentEl,
      props: {
        submission: this.onSubmit.bind(this),
        overwrite: this.overwrite,
        delimiter: this.delimiter,
        defaultProps: this.defaultProps,
        changeBool: this.updateBool.bind(this)
      }
    });
  }
};

// src/MultiSelectSuggestModal.ts
var import_obsidian3 = require("obsidian");

// src/SuggestionManager.ts
var SuggestionManager = class {
  constructor(availableValues, preselected = []) {
    this.items = [];
    this.selectedItems = /* @__PURE__ */ new Set();
    this.items = availableValues.map((value) => ({
      value,
      selected: preselected.includes(value)
    }));
    preselected.forEach((item) => this.selectedItems.add(item));
  }
  toggleSelection(value) {
    const item = this.items.find((i) => i.value === value);
    if (!item) return false;
    item.selected = !item.selected;
    if (item.selected) {
      this.selectedItems.add(value);
    } else {
      this.selectedItems.delete(value);
    }
    return item.selected;
  }
  getSelectedValues() {
    return Array.from(this.selectedItems);
  }
  getSuggestions(query, allowNewValues) {
    const filtered = this.items.filter(
      (item) => item.value.toLowerCase().includes(query.toLowerCase())
    );
    if (allowNewValues && query && !this.items.some((item) => item.value.toLowerCase() === query.toLowerCase())) {
      filtered.unshift({
        value: `Create: "${query}"`,
        selected: false
      });
    }
    return filtered;
  }
  handleSubmission(evt, onSubmit) {
    if (evt.shiftKey && evt.key === "Enter") {
      onSubmit(this.getSelectedValues());
      return true;
    }
    return false;
  }
  createNewValue(value) {
    if (!this.items.some((item) => item.value === value)) {
      this.items.push({ value, selected: true });
      this.selectedItems.add(value);
    }
  }
};

// src/MultiSelectSuggestModal.ts
var MultiSelectSuggestModal = class extends import_obsidian3.SuggestModal {
  constructor(app, availableValues, preselected = [], onSubmit, allowNewValues = true) {
    super(app);
    this.onSubmit = onSubmit;
    this.allowNewValues = allowNewValues;
    this.suggestionManager = new SuggestionManager(availableValues, preselected);
    this.setPlaceholder("Type to search, Enter to select/deselect, Shift+Enter to finish");
    this.setInstructions([
      { command: "Enter", purpose: "Toggle selection" },
      { command: "Shift+Enter", purpose: "Confirm selection" },
      { command: "Escape", purpose: "Cancel" }
    ]);
  }
  getSuggestions(query) {
    return this.suggestionManager.getSuggestions(query, this.allowNewValues);
  }
  renderSuggestion(item, el) {
    const container = el.createDiv({ cls: "multi-select-suggestion" });
    const checkbox = container.createSpan({
      cls: item.selected ? "checkbox-checked" : "checkbox-unchecked",
      text: item.selected ? "\u2611\uFE0F" : "\u2610"
    });
    const text2 = container.createSpan({
      text: item.value,
      cls: item.selected ? "selected-item" : ""
    });
    if (item.selected) {
      container.addClass("is-selected");
    }
  }
  onChooseSuggestion(item, evt) {
    let valueToSubmit;
    if (item.value.startsWith('Create: "')) {
      valueToSubmit = item.value.replace('Create: "', "").replace('"', "");
    } else {
      valueToSubmit = item.value;
    }
    this.onSubmit([valueToSubmit]);
  }
  refreshSuggestions() {
    const inputEl = this.inputEl;
    const currentValue = inputEl.value;
    inputEl.value = currentValue + " ";
    inputEl.value = currentValue;
    inputEl.dispatchEvent(new Event("input"));
  }
  // Expose for testing
  getSelectedItems() {
    return this.suggestionManager.getSelectedValues();
  }
};

// src/SettingTab.ts
var import_obsidian4 = require("obsidian");
var SettingTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    let { containerEl } = this;
    containerEl.empty();
    new import_obsidian4.Setting(containerEl).setName("Overwrite existing text").setDesc(
      "When adding a property with a name that already exists, the text will overwrite the prop's existing value.  If left disabled, the new value will be appended to the old as a List."
    ).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.overwrite);
      toggle.onChange(async (value) => {
        this.plugin.settings.overwrite = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian4.Setting(containerEl).setName("Recursive Iteration").setDesc(
      "When toggled on, while looping through all files in a folder, you will also loop through any sub-folders."
    ).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.recursive);
      toggle.onChange(async (value) => {
        this.plugin.settings.recursive = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian4.Setting(containerEl).setName("List Delimiter").setDesc(
      "Set delimiter to use when creating a list.  Commas(,) are used by default."
    ).addText((text2) => {
      text2.setValue(this.plugin.settings.delimiter);
      text2.onChange(async (value) => {
        if (value.length > 1) {
          text2.setValue(value[0]);
          new import_obsidian4.Notice("Delimiter must be a single character.");
          return;
        }
        this.plugin.settings.delimiter = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian4.Setting(containerEl).setName("Default Props File").setDesc(
      "Select a file with properties that you want to load into the Multi Properties form by default.  Type in the full path of the desired file.(ex. Templates/PropFile 1)"
    ).addText((text2) => {
      text2.setValue(this.plugin.settings.defaultPropPath);
      text2.onChange(async (value) => {
        this.plugin.settings.defaultPropPath = value;
        await this.plugin.saveSettings();
      });
    });
  }
};

// src/RemoveModal.ts
var import_obsidian6 = require("obsidian");

// src/RemovePropForm.svelte
function add_css4(target) {
  append_styles(target, "svelte-zna8bm", ".name-container.svelte-zna8bm{display:flex;flex-direction:column;gap:5px;margin-top:10px;margin-bottom:20px}.alert-container.svelte-zna8bm{display:flex;flex-direction:column;align-items:center;justify-content:center;margin-bottom:10px;background-color:red;font-weight:bold}.button-container.svelte-zna8bm{display:flex;flex-direction:row;justify-content:space-between}.hidden.svelte-zna8bm{display:none}");
}
function get_each_context4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i];
  child_ctx[15] = list;
  child_ctx[16] = i;
  return child_ctx;
}
function create_each_block4(ctx) {
  let label;
  let input_1;
  let t0;
  let t1_value = (
    /*input*/
    ctx[14].name + ""
  );
  let t1;
  let t2;
  let mounted;
  let dispose;
  function input_1_change_handler() {
    ctx[12].call(
      input_1,
      /*each_value*/
      ctx[15],
      /*input_index*/
      ctx[16]
    );
  }
  return {
    c() {
      label = element("label");
      input_1 = element("input");
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      attr(input_1, "type", "checkbox");
    },
    m(target, anchor) {
      insert(target, label, anchor);
      append(label, input_1);
      set_input_value(
        input_1,
        /*input*/
        ctx[14].name
      );
      input_1.checked = /*input*/
      ctx[14].isChecked;
      append(label, t0);
      append(label, t1);
      append(label, t2);
      if (!mounted) {
        dispose = [
          listen(input_1, "change", input_1_change_handler),
          listen(
            input_1,
            "change",
            /*change_handler*/
            ctx[13]
          )
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*inputs*/
      8) {
        set_input_value(
          input_1,
          /*input*/
          ctx[14].name
        );
      }
      if (dirty & /*inputs*/
      8) {
        input_1.checked = /*input*/
        ctx[14].isChecked;
      }
      if (dirty & /*inputs*/
      8 && t1_value !== (t1_value = /*input*/
      ctx[14].name + "")) set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(label);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment4(ctx) {
  let div5;
  let div2;
  let div0;
  let t1;
  let div1;
  let t2;
  let t3;
  let p;
  let t5;
  let form;
  let div3;
  let t6;
  let div4;
  let button0;
  let t8;
  let button1;
  let t9_value = (
    /*isMaxChecked*/
    ctx[0] ? "Uncheck All" : "Check All"
  );
  let t9;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*inputs*/
    ctx[3]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block4(get_each_context4(ctx, each_value, i));
  }
  return {
    c() {
      div5 = element("div");
      div2 = element("div");
      div0 = element("div");
      div0.textContent = "ERROR";
      t1 = space();
      div1 = element("div");
      t2 = text(
        /*alertText*/
        ctx[2]
      );
      t3 = space();
      p = element("p");
      p.textContent = "Select the properties you wish to remove from the file selection.";
      t5 = space();
      form = element("form");
      div3 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t6 = space();
      div4 = element("div");
      button0 = element("button");
      button0.textContent = "Confirm";
      t8 = space();
      button1 = element("button");
      t9 = text(t9_value);
      attr(div1, "id", "alert-text");
      attr(div2, "id", "alert-container");
      attr(div2, "class", "alert-container hidden svelte-zna8bm");
      attr(div3, "class", "name-container svelte-zna8bm");
      attr(button0, "type", "submit");
      attr(div4, "class", "button-container svelte-zna8bm");
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div2);
      append(div2, div0);
      append(div2, t1);
      append(div2, div1);
      append(div1, t2);
      ctx[11](div2);
      append(div5, t3);
      append(div5, p);
      append(div5, t5);
      append(div5, form);
      append(form, div3);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div3, null);
        }
      }
      append(form, t6);
      append(form, div4);
      append(div4, button0);
      append(div4, t8);
      append(div4, button1);
      append(button1, t9);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*onSubmit*/
            ctx[6]
          ),
          listen(
            button1,
            "click",
            /*toggleAll*/
            ctx[5]
          ),
          listen(form, "submit", prevent_default(
            /*submit_handler*/
            ctx[10]
          ))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*alertText*/
      4) set_data(
        t2,
        /*alertText*/
        ctx2[2]
      );
      if (dirty & /*inputs, onCheckboxChange*/
      24) {
        each_value = ensure_array_like(
          /*inputs*/
          ctx2[3]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context4(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block4(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div3, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*isMaxChecked*/
      1 && t9_value !== (t9_value = /*isMaxChecked*/
      ctx2[0] ? "Uncheck All" : "Check All")) set_data(t9, t9_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div5);
      }
      ctx[11](null);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance4($$self, $$props, $$invalidate) {
  let isMaxChecked;
  let { names = [] } = $$props;
  let { submission } = $$props;
  let errorEl;
  let alertText = ".";
  let checkCount = 0;
  let inputs = [];
  for (let name of names) {
    inputs.push({ name, isChecked: false });
  }
  names.sort();
  function onCheckboxChange(event) {
    let checked = event.target.checked;
    checked ? $$invalidate(9, checkCount++, checkCount) : $$invalidate(9, checkCount--, checkCount);
  }
  function toggleAll() {
    if (isMaxChecked) {
      $$invalidate(3, inputs = inputs.map((input) => Object.assign(Object.assign({}, input), { isChecked: false })));
      $$invalidate(9, checkCount = 0);
    } else {
      $$invalidate(3, inputs = inputs.map((input) => Object.assign(Object.assign({}, input), { isChecked: true })));
      $$invalidate(9, checkCount = names.length);
    }
  }
  function onSubmit() {
    if (checkCount === 0) {
      $$invalidate(2, alertText = "Please select at least one property to remove.");
      errorEl.classList.remove("hidden");
      return;
    }
    let propNames = inputs.filter((input) => input.isChecked).map((input) => input.name);
    submission(propNames);
  }
  function submit_handler(event) {
    bubble.call(this, $$self, event);
  }
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      errorEl = $$value;
      $$invalidate(1, errorEl);
    });
  }
  function input_1_change_handler(each_value, input_index) {
    each_value[input_index].name = this.value;
    each_value[input_index].isChecked = this.checked;
    $$invalidate(3, inputs);
  }
  const change_handler = (event) => onCheckboxChange(event);
  $$self.$$set = ($$props2) => {
    if ("names" in $$props2) $$invalidate(7, names = $$props2.names);
    if ("submission" in $$props2) $$invalidate(8, submission = $$props2.submission);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*checkCount, names*/
    640) {
      $: $$invalidate(0, isMaxChecked = checkCount >= names.length);
    }
    if ($$self.$$.dirty & /*isMaxChecked*/
    1) {
      $: console.log(isMaxChecked);
    }
  };
  return [
    isMaxChecked,
    errorEl,
    alertText,
    inputs,
    onCheckboxChange,
    toggleAll,
    onSubmit,
    names,
    submission,
    checkCount,
    submit_handler,
    div2_binding,
    input_1_change_handler,
    change_handler
  ];
}
var RemovePropForm = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance4, create_fragment4, safe_not_equal, { names: 7, submission: 8 }, add_css4);
  }
};
var RemovePropForm_default = RemovePropForm;

// src/RemoveConfirmModal.ts
var import_obsidian5 = require("obsidian");

// src/RemoveConfirmForm.svelte
function get_each_context5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  return child_ctx;
}
function create_each_block5(ctx) {
  let li;
  let t0_value = (
    /*name*/
    ctx[6] + ""
  );
  let t0;
  let t1;
  return {
    c() {
      li = element("li");
      t0 = text(t0_value);
      t1 = space();
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, t0);
      append(li, t1);
    },
    p(ctx2, dirty) {
      if (dirty & /*names*/
      1 && t0_value !== (t0_value = /*name*/
      ctx2[6] + "")) set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
    }
  };
}
function create_fragment5(ctx) {
  let div;
  let form;
  let p0;
  let t3;
  let ul;
  let t4;
  let p1;
  let t6;
  let button0;
  let t8;
  let button1;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*names*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block5(get_each_context5(ctx, each_value, i));
  }
  return {
    c() {
      div = element("div");
      form = element("form");
      p0 = element("p");
      p0.textContent = `The following ${/*word*/
      ctx[4]} will be removed:`;
      t3 = space();
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t4 = space();
      p1 = element("p");
      p1.textContent = "Are you sure you wish to proceed?";
      t6 = space();
      button0 = element("button");
      button0.textContent = "Delete";
      t8 = space();
      button1 = element("button");
      button1.textContent = "Cancel";
      attr(button0, "class", "mod-warning");
      attr(button0, "type", "submit");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, form);
      append(form, p0);
      append(form, t3);
      append(form, ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ul, null);
        }
      }
      append(form, t4);
      append(form, p1);
      append(form, t6);
      append(form, button0);
      append(form, t8);
      append(form, button1);
      ctx[5](button1);
      if (!mounted) {
        dispose = [
          listen(button1, "click", function() {
            if (is_function(
              /*cancel*/
              ctx[2]
            )) ctx[2].apply(this, arguments);
          }),
          listen(form, "submit", prevent_default(function() {
            if (is_function(
              /*submission*/
              ctx[1]
            )) ctx[1].apply(this, arguments);
          }))
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (dirty & /*names*/
      1) {
        each_value = ensure_array_like(
          /*names*/
          ctx[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context5(ctx, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block5(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ul, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
      ctx[5](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance5($$self, $$props, $$invalidate) {
  let { names = ["test", "test2"] } = $$props;
  let { submission } = $$props;
  let { cancel } = $$props;
  let btnCancel;
  const word = names.length > 1 ? "properties" : "property";
  onMount(() => {
    btnCancel.focus();
  });
  function button1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      btnCancel = $$value;
      $$invalidate(3, btnCancel);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("names" in $$props2) $$invalidate(0, names = $$props2.names);
    if ("submission" in $$props2) $$invalidate(1, submission = $$props2.submission);
    if ("cancel" in $$props2) $$invalidate(2, cancel = $$props2.cancel);
  };
  return [names, submission, cancel, btnCancel, word, button1_binding];
}
var RemoveConfirmForm = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance5, create_fragment5, safe_not_equal, { names: 0, submission: 1, cancel: 2 });
  }
};
var RemoveConfirmForm_default = RemoveConfirmForm;

// src/RemoveConfirmModal.ts
var RemoveConfirmModal = class extends import_obsidian5.Modal {
  constructor(app, names, submission) {
    super(app);
    this.names = names;
    this.submission = submission;
  }
  async onSubmit() {
    await this.submission(true);
    this.close();
  }
  onCancel() {
    this.submission(false);
    this.close();
  }
  onOpen() {
    if (!this.names || this.names.length === 0) {
      new import_obsidian5.Notice("Please check at least one property to remove.");
      this.close();
    }
    this.titleEl.createEl("h2", { text: "Remove Properties" });
    this.component = new RemoveConfirmForm_default({
      target: this.contentEl,
      props: {
        names: this.names,
        submission: this.onSubmit.bind(this),
        cancel: this.onCancel.bind(this)
      }
    });
  }
};

// src/RemoveModal.ts
var RemoveModal = class extends import_obsidian6.Modal {
  constructor(app, names, submission) {
    if (!names || names.length === 0) {
      new import_obsidian6.Notice("No properties to remove");
      return;
    }
    super(app);
    this.names = names;
    this.submission = submission;
  }
  async onConfirm(bool) {
    if (bool) {
      await this.submission(this.props);
      this.close();
    }
  }
  onSubmit(props) {
    this.props = props;
    new RemoveConfirmModal(
      this.app,
      this.props,
      this.onConfirm.bind(this)
    ).open();
  }
  onOpen() {
    this.titleEl.createEl("h2", { text: "Remove Properties" });
    this.component = new RemovePropForm_default({
      target: this.contentEl,
      props: {
        names: this.names,
        submission: this.onSubmit.bind(this)
      }
    });
  }
};

// src/frontmatter.ts
async function addProperties(fileProcessor, file, props, overwrite, propCache) {
  await fileProcessor(file, (frontmatter) => {
    for (const [key, value] of props) {
      if (key === "tags") {
        const existingTags = frontmatter[key] || [];
        const newTags = Array.isArray(value.data) ? value.data : [value.data];
        frontmatter[key] = [.../* @__PURE__ */ new Set([...existingTags, ...newTags])];
        continue;
      }
      if (!frontmatter[key] || overwrite) {
        frontmatter[key] = value.data;
        continue;
      }
      let type1 = value.type;
      let type2 = propCache[key.toLowerCase()].type;
      if (canBeAppended(type1, type2)) {
        if (frontmatter[key] === value.data) continue;
        if (!value.data) continue;
        let arr = mergeIntoArrays(frontmatter[key], value.data);
        frontmatter[key] = arr;
        continue;
      } else {
        frontmatter[key] = value.data;
        continue;
      }
    }
  });
}
async function addPropToSet(fileProcessor, set, file) {
  await fileProcessor(file, (frontmatter) => {
    for (const key in frontmatter) {
      console.log({ key });
      set.add(key);
    }
  });
  return set;
}
async function removeProperties(fileProcessor, file, props) {
  await fileProcessor(file, (frontmatter) => {
    for (const prop of props) {
      frontmatter[prop] = void 0;
    }
  });
}
function canBeAppended(str1, str2) {
  let arr = ["number", "date", "datetime", "checkbox"];
  if (arr.includes(str1) || arr.includes(str2)) return false;
  return true;
}
function mergeIntoArrays(...args) {
  const arrays = args.map((arg) => Array.isArray(arg) ? arg : [arg]);
  const flattened = arrays.flat();
  const unique = [...new Set(flattened)];
  return unique;
}
async function addValueToProperty(fileProcessor, file, property, value) {
  await fileProcessor(file, (frontmatter) => {
    const existingValues = frontmatter[property];
    if (existingValues) {
      const currentValues = Array.isArray(existingValues) ? existingValues : [existingValues];
      const newValues = [.../* @__PURE__ */ new Set([...currentValues, value])];
      frontmatter[property] = newValues;
    } else {
      frontmatter[property] = [value];
    }
  });
}
async function removeValuesFromProperty(fileProcessor, file, property, valuesToRemove) {
  await fileProcessor(file, (frontmatter) => {
    if (frontmatter[property] && Array.isArray(frontmatter[property])) {
      frontmatter[property] = frontmatter[property].filter(
        (value) => !valuesToRemove.includes(value)
      );
    }
  });
}
async function getUniqueValues(app, files, property) {
  const values = /* @__PURE__ */ new Set();
  for (const file of files) {
    await app.fileManager.processFrontMatter(file, (frontmatter) => {
      if (frontmatter[property] && Array.isArray(frontmatter[property])) {
        for (const value of frontmatter[property]) {
          values.add(value);
        }
      }
    });
  }
  return [...values];
}

// src/SingleSelectSuggestModal.ts
var import_obsidian7 = require("obsidian");
var SingleSelectSuggestModal = class extends import_obsidian7.SuggestModal {
  constructor(app, availableValues, onSubmit) {
    super(app);
    this.availableValues = availableValues;
    this.onSubmit = onSubmit;
    this.setPlaceholder("Type to search...");
  }
  getSuggestions(query) {
    return this.availableValues.filter(
      (value) => value.toLowerCase().includes(query.toLowerCase())
    );
  }
  renderSuggestion(value, el) {
    el.textContent = value;
  }
  onChooseSuggestion(item, evt) {
    this.onSubmit(item);
  }
};

// src/main.ts
var defaultSettings = {
  overwrite: false,
  recursive: true,
  delimiter: ",",
  defaultPropPath: ""
};
var ValueSelector = class {
  constructor(app, files, plugin) {
    this.app = app;
    this.files = files;
    this.plugin = plugin;
  }
  async addValue() {
    const listProps = await this.plugin.getListProperties(this.files);
    if (listProps.length === 0) {
      new import_obsidian8.Notice("No list-type properties found in the selected files.", 4e3);
      return;
    }
    new SingleSelectSuggestModal(this.app, listProps, async (selectedProp) => {
      const allValues = await this.plugin.getAllUniqueValuesForProperty(selectedProp);
      new MultiSelectSuggestModal(this.app, allValues, [], async (selectedValues) => {
        for (const file of this.files) {
          for (const value of selectedValues) {
            await addValueToProperty(this.app.fileManager.processFrontMatter.bind(this.app.fileManager), file, selectedProp, value);
          }
        }
      }).open();
    }).open();
  }
  async removeValue() {
    const listProps = await this.plugin.getListProperties(this.files);
    if (listProps.length === 0) {
      new import_obsidian8.Notice("No list-type properties found in the selected files.", 4e3);
      return;
    }
    new MultiSelectSuggestModal(this.app, listProps, [], async (selectedProp) => {
      const uniqueValues = await getUniqueValues(this.app, this.files, selectedProp[0]);
      new MultiSelectSuggestModal(this.app, uniqueValues, [], async (selectedValues) => {
        for (const file of this.files) {
          await removeValuesFromProperty(this.app.fileManager.processFrontMatter.bind(this.app.fileManager), file, selectedProp[0], selectedValues);
        }
      }, false).open();
    }, false).open();
  }
};
var MultiPropPlugin = class extends import_obsidian8.Plugin {
  async loadSettings() {
    this.settings = Object.assign({}, defaultSettings, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async saveData(settings) {
  }
  async changeOverwrite(bool) {
    this.settings.overwrite = bool;
    await this.saveSettings();
  }
  _getFilesFromTabGroup(leaf) {
    if (!leaf) return [];
    const files = [];
    const fileSet = /* @__PURE__ */ new Set();
    const activeParent = leaf.parent;
    if (activeParent instanceof import_obsidian8.WorkspaceTabs) {
      this.app.workspace.iterateAllLeaves((l) => {
        if (l.parent === activeParent && l.view instanceof import_obsidian8.FileView) {
          const file = l.view.file;
          if (file && !fileSet.has(file.path)) {
            files.push(file);
            fileSet.add(file.path);
          }
        }
      });
    } else {
      const activeWindowRoot = leaf.getRoot();
      this.app.workspace.iterateAllLeaves((l) => {
        if (l.getRoot() === activeWindowRoot && l.view instanceof import_obsidian8.FileView) {
          const file = l.view.file;
          if (file && !fileSet.has(file.path)) {
            files.push(file);
            fileSet.add(file.path);
          }
        }
      });
    }
    return files;
  }
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new SettingTab(this.app, this));
    this.addCommand({
      id: "add-props-to-current-note",
      name: "Add props to current note",
      callback: async () => {
        const file = this.app.workspace.getActiveFile();
        if (file) await this.createPropModal([file]);
      }
    });
    this.addCommand({
      id: "remove-props-from-current-note",
      name: "Remove props from current note",
      callback: async () => {
        const file = this.app.workspace.getActiveFile();
        if (file) await this.createRemoveModal([file]);
      }
    });
    this.addCommand({
      id: "add-props-to-tab-group",
      name: "Add props to tabs in active tab group",
      callback: async () => {
        const files = this._getFilesFromTabGroup(this.app.workspace.activeLeaf);
        if (files.length > 0) await this.createPropModal(files);
      }
    });
    this.addCommand({
      id: "remove-props-from-tab-group",
      name: "Remove props from tabs in active tab group",
      callback: async () => {
        const files = this._getFilesFromTabGroup(this.app.workspace.activeLeaf);
        if (files.length > 0) await this.createRemoveModal(files);
      }
    });
    this.addCommand({
      id: "add-value-to-property",
      name: "Add value to a property on the current note",
      callback: async () => {
        const file = this.app.workspace.getActiveFile();
        if (file) new ValueSelector(this.app, [file], this).addValue();
      }
    });
    this.addCommand({
      id: "remove-value-from-property",
      name: "Remove a value from a property on the current note",
      callback: async () => {
        const file = this.app.workspace.getActiveFile();
        if (file) new ValueSelector(this.app, [file], this).removeValue();
      }
    });
    this.addCommand({
      id: "remove-value-from-property-in-tab-group",
      name: "Remove a value from a property on all notes in the active tab group",
      callback: async () => {
        const files = this._getFilesFromTabGroup(this.app.workspace.activeLeaf);
        if (files.length > 0) new ValueSelector(this.app, files, this).removeValue();
      }
    });
  }
  async getPropsFromFolder(folder, names) {
    for (let obj of folder.children) {
      if (obj instanceof import_obsidian8.TFile && obj.extension === "md") {
        names = await addPropToSet(this.app.fileManager.processFrontMatter.bind(this.app.fileManager), names, obj);
      }
      if (obj instanceof import_obsidian8.TFolder && this.settings.recursive) {
        await this.getPropsFromFolder(obj, names);
      }
    }
    return [...names].sort();
  }
  async getPropsFromFiles(files, names) {
    for (let file of files) {
      if (file instanceof import_obsidian8.TFile && file.extension === "md") {
        names = await addPropToSet(this.app.fileManager.processFrontMatter.bind(this.app.fileManager), names, file);
      }
    }
    return [...names];
  }
  async searchFolders(folder, callback) {
    for (let obj of folder.children) {
      if (obj instanceof import_obsidian8.TFolder && this.settings.recursive) {
        await this.searchFolders(obj, callback);
      }
      if (obj instanceof import_obsidian8.TFile && obj.extension === "md") {
        await callback(obj);
      }
    }
  }
  async searchFiles(files, callback) {
    for (let file of files) {
      if (file instanceof import_obsidian8.TFile && file.extension === "md") {
        await callback(file);
      }
    }
  }
  async createPropModal(iterable) {
    let iterateFunc;
    let files = [];
    if (iterable instanceof import_obsidian8.TFolder) {
      iterateFunc = async (props) => await this.searchFolders(iterable, this.addPropsCallback(props));
    } else {
      files = iterable;
      iterateFunc = async (props) => await this.searchFiles(files, this.addPropsCallback(props));
    }
    let defaultProps = [];
    if (this.settings.defaultPropPath) {
      try {
        const file = this.app.vault.getAbstractFileByPath(`${this.settings.defaultPropPath}.md`);
        if (file && file instanceof import_obsidian8.TFile) {
          let tmp = this.readYamlProperties(file);
          if (tmp) defaultProps = tmp;
        }
      } catch (e) {
        new import_obsidian8.Notice(`${e}. Check path in settings.`, 1e4);
      }
    }
    if (defaultProps.length === 0) {
      defaultProps = [{ name: "", value: "", type: "text" }];
    }
    new PropModal(this.app, iterateFunc, this.settings.overwrite, this.settings.delimiter, defaultProps, this.changeOverwrite.bind(this)).open();
  }
  async createRemoveModal(iterable) {
    let names;
    let iterateFunc;
    if (iterable instanceof import_obsidian8.TFolder) {
      names = await this.getPropsFromFolder(iterable, /* @__PURE__ */ new Set());
      iterateFunc = async (props) => await this.searchFolders(iterable, this.removePropsCallback(props));
    } else {
      names = await this.getPropsFromFiles(iterable, /* @__PURE__ */ new Set());
      iterateFunc = async (props) => await this.searchFiles(iterable, this.removePropsCallback(props));
    }
    if (names.length === 0) {
      new import_obsidian8.Notice("No properties to remove", 4e3);
      return;
    }
    const sortedNames = [...names].sort((a, b) => a.toLowerCase() > b.toLowerCase() ? 1 : -1);
    new RemoveModal(this.app, sortedNames, iterateFunc).open();
  }
  async getListProperties(files) {
    const listProps = /* @__PURE__ */ new Set();
    for (const file of files) {
      const metadata = this.app.metadataCache.getFileCache(file);
      if (metadata && metadata.frontmatter) {
        const frontmatter = metadata.frontmatter;
        for (const [key, value] of Object.entries(frontmatter)) {
          if (Array.isArray(value)) {
            listProps.add(key);
          }
        }
      }
    }
    return [...listProps].sort();
  }
  async getAllUniqueValuesForProperty(property) {
    const values = /* @__PURE__ */ new Set();
    const files = this.app.vault.getMarkdownFiles();
    for (const file of files) {
      const metadata = this.app.metadataCache.getFileCache(file);
      if (metadata && metadata.frontmatter && metadata.frontmatter[property]) {
        const frontmatter = metadata.frontmatter;
        const propValues = Array.isArray(frontmatter[property]) ? frontmatter[property] : [frontmatter[property]];
        propValues.forEach((v) => values.add(String(v)));
      }
    }
    return [...values].sort();
  }
  readYamlProperties(file) {
    var _a;
    const metadata = this.app.metadataCache.getFileCache(file);
    if (metadata && metadata.frontmatter) {
      const frontmatter = metadata.frontmatter;
      const allPropsWithType = this.app.metadataCache.getAllPropertyInfos();
      let result = [];
      for (let [key, value] of Object.entries(frontmatter)) {
        const keyLower = key.toLowerCase();
        result.push({ name: key, value, type: ((_a = allPropsWithType[keyLower]) == null ? void 0 : _a.type) || "text" });
      }
      return result;
    }
  }
  addPropsCallback(props) {
    return async (file) => {
      await addProperties(this.app.fileManager.processFrontMatter.bind(this.app.fileManager), file, props, this.settings.overwrite, this.app.metadataCache.getAllPropertyInfos());
    };
  }
  removePropsCallback(props) {
    return async (file) => {
      await removeProperties(this.app.fileManager.processFrontMatter.bind(this.app.fileManager), file, props);
    };
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsic3JjL21haW4udHMiLCAic3JjL0FkZFByb3BNb2RhbC50cyIsICJub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL2ludGVybmFsL3V0aWxzLmpzIiwgIm5vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvaW50ZXJuYWwvZ2xvYmFscy5qcyIsICJub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL2ludGVybmFsL1Jlc2l6ZU9ic2VydmVyU2luZ2xldG9uLmpzIiwgIm5vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvaW50ZXJuYWwvZG9tLmpzIiwgIm5vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvaW50ZXJuYWwvbGlmZWN5Y2xlLmpzIiwgIm5vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvaW50ZXJuYWwvc2NoZWR1bGVyLmpzIiwgIm5vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvaW50ZXJuYWwvdHJhbnNpdGlvbnMuanMiLCAibm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvcnVudGltZS9pbnRlcm5hbC9lYWNoLmpzIiwgIm5vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3NoYXJlZC9ib29sZWFuX2F0dHJpYnV0ZXMuanMiLCAibm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvcnVudGltZS9pbnRlcm5hbC9Db21wb25lbnQuanMiLCAibm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvc2hhcmVkL3ZlcnNpb24uanMiLCAibm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvcnVudGltZS9pbnRlcm5hbC9kaXNjbG9zZS12ZXJzaW9uL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanMiLCAic3JjL0FkZFByb3BJbnB1dC5zdmVsdGUiLCAic3JjL2hlbHBlcnMudHMiLCAic3JjL0FkZFByb3BGb3JtLnN2ZWx0ZSIsICJzcmMvQWRkQ29uZmlybU1vZGFsLnRzIiwgInNyYy9BZGRDb25maXJtRm9ybS5zdmVsdGUiLCAic3JjL011bHRpU2VsZWN0U3VnZ2VzdE1vZGFsLnRzIiwgInNyYy9TdWdnZXN0aW9uTWFuYWdlci50cyIsICJzcmMvU2V0dGluZ1RhYi50cyIsICJzcmMvUmVtb3ZlTW9kYWwudHMiLCAic3JjL1JlbW92ZVByb3BGb3JtLnN2ZWx0ZSIsICJzcmMvUmVtb3ZlQ29uZmlybU1vZGFsLnRzIiwgInNyYy9SZW1vdmVDb25maXJtRm9ybS5zdmVsdGUiLCAic3JjL2Zyb250bWF0dGVyLnRzIiwgInNyYy9TaW5nbGVTZWxlY3RTdWdnZXN0TW9kYWwudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbImltcG9ydCB7IE5vdGljZSwgUGx1Z2luLCBUQWJzdHJhY3RGaWxlLCBURmlsZSwgVEZvbGRlciwgRmlsZVZpZXcsIFdvcmtzcGFjZUxlYWYsIFdvcmtzcGFjZVRhYnMsIEFwcCB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHsgUHJvcE1vZGFsIH0gZnJvbSBcIi4vQWRkUHJvcE1vZGFsXCI7XG5pbXBvcnQgeyBNdWx0aVNlbGVjdFN1Z2dlc3RNb2RhbCB9IGZyb20gXCIuL011bHRpU2VsZWN0U3VnZ2VzdE1vZGFsXCI7XG5pbXBvcnQgeyBNdWx0aVByb3BTZXR0aW5ncywgU2V0dGluZ1RhYiB9IGZyb20gXCIuL1NldHRpbmdUYWJcIjtcbmltcG9ydCB7IFJlbW92ZU1vZGFsIH0gZnJvbSBcIi4vUmVtb3ZlTW9kYWxcIjtcbmltcG9ydCB7IGFkZFByb3BlcnRpZXMsIGFkZFByb3BUb1NldCwgcmVtb3ZlUHJvcGVydGllcywgYWRkVmFsdWVUb1Byb3BlcnR5LCByZW1vdmVWYWx1ZXNGcm9tUHJvcGVydHksIGdldFVuaXF1ZVZhbHVlcyB9IGZyb20gXCIuL2Zyb250bWF0dGVyXCI7XG5pbXBvcnQgeyBQcm9wZXJ0eVR5cGVzIH0gZnJvbSBcIi4vdHlwZXMvY3VzdG9tXCI7XG5cbmNvbnN0IGRlZmF1bHRTZXR0aW5nczogTXVsdGlQcm9wU2V0dGluZ3MgPSB7XG4gIG92ZXJ3cml0ZTogZmFsc2UsXG4gIHJlY3Vyc2l2ZTogdHJ1ZSxcbiAgZGVsaW1pdGVyOiBcIixcIixcbiAgZGVmYXVsdFByb3BQYXRoOiBcIlwiLFxufTtcblxuZXhwb3J0IGludGVyZmFjZSBOZXdQcm9wRGF0YSB7XG4gIHR5cGU6IHN0cmluZztcbiAgZGF0YTogc3RyaW5nIHwgc3RyaW5nW10gfCBudWxsO1xuICBvdmVyd3JpdGU6IGJvb2xlYW47XG4gIGRlbGltaXRlcjogc3RyaW5nO1xufVxuXG5pbXBvcnQgeyBTaW5nbGVTZWxlY3RTdWdnZXN0TW9kYWwgfSBmcm9tIFwiLi9TaW5nbGVTZWxlY3RTdWdnZXN0TW9kYWxcIjtcblxuY2xhc3MgVmFsdWVTZWxlY3RvciB7XG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBhcHA6IEFwcCwgcHJpdmF0ZSBmaWxlczogVEZpbGVbXSwgcHJpdmF0ZSBwbHVnaW46IE11bHRpUHJvcFBsdWdpbikge31cblxuICAgIGFzeW5jIGFkZFZhbHVlKCkge1xuICAgICAgICBjb25zdCBsaXN0UHJvcHMgPSBhd2FpdCB0aGlzLnBsdWdpbi5nZXRMaXN0UHJvcGVydGllcyh0aGlzLmZpbGVzKTtcbiAgICAgICAgaWYgKGxpc3RQcm9wcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJObyBsaXN0LXR5cGUgcHJvcGVydGllcyBmb3VuZCBpbiB0aGUgc2VsZWN0ZWQgZmlsZXMuXCIsIDQwMDApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3IFNpbmdsZVNlbGVjdFN1Z2dlc3RNb2RhbCh0aGlzLmFwcCwgbGlzdFByb3BzLCBhc3luYyAoc2VsZWN0ZWRQcm9wKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhbGxWYWx1ZXMgPSBhd2FpdCB0aGlzLnBsdWdpbi5nZXRBbGxVbmlxdWVWYWx1ZXNGb3JQcm9wZXJ0eShzZWxlY3RlZFByb3ApO1xuICAgICAgICAgICAgbmV3IE11bHRpU2VsZWN0U3VnZ2VzdE1vZGFsKHRoaXMuYXBwLCBhbGxWYWx1ZXMsIFtdLCBhc3luYyAoc2VsZWN0ZWRWYWx1ZXMpID0+IHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGZpbGUgb2YgdGhpcy5maWxlcykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHNlbGVjdGVkVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBhZGRWYWx1ZVRvUHJvcGVydHkodGhpcy5hcHAuZmlsZU1hbmFnZXIucHJvY2Vzc0Zyb250TWF0dGVyLmJpbmQodGhpcy5hcHAuZmlsZU1hbmFnZXIpLCBmaWxlLCBzZWxlY3RlZFByb3AsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLm9wZW4oKTtcbiAgICAgICAgfSkub3BlbigpO1xuICAgIH1cblxuICAgIGFzeW5jIHJlbW92ZVZhbHVlKCkge1xuICAgICAgICBjb25zdCBsaXN0UHJvcHMgPSBhd2FpdCB0aGlzLnBsdWdpbi5nZXRMaXN0UHJvcGVydGllcyh0aGlzLmZpbGVzKTtcbiAgICAgICAgaWYgKGxpc3RQcm9wcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJObyBsaXN0LXR5cGUgcHJvcGVydGllcyBmb3VuZCBpbiB0aGUgc2VsZWN0ZWQgZmlsZXMuXCIsIDQwMDApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3IE11bHRpU2VsZWN0U3VnZ2VzdE1vZGFsKHRoaXMuYXBwLCBsaXN0UHJvcHMsIFtdLCBhc3luYyAoc2VsZWN0ZWRQcm9wKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB1bmlxdWVWYWx1ZXMgPSBhd2FpdCBnZXRVbmlxdWVWYWx1ZXModGhpcy5hcHAsIHRoaXMuZmlsZXMsIHNlbGVjdGVkUHJvcFswXSk7XG4gICAgICAgICAgICBuZXcgTXVsdGlTZWxlY3RTdWdnZXN0TW9kYWwodGhpcy5hcHAsIHVuaXF1ZVZhbHVlcywgW10sIGFzeW5jIChzZWxlY3RlZFZhbHVlcykgPT4ge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZmlsZSBvZiB0aGlzLmZpbGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHJlbW92ZVZhbHVlc0Zyb21Qcm9wZXJ0eSh0aGlzLmFwcC5maWxlTWFuYWdlci5wcm9jZXNzRnJvbnRNYXR0ZXIuYmluZCh0aGlzLmFwcC5maWxlTWFuYWdlciksIGZpbGUsIHNlbGVjdGVkUHJvcFswXSwgc2VsZWN0ZWRWYWx1ZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGZhbHNlKS5vcGVuKCk7XG4gICAgICAgIH0sIGZhbHNlKS5vcGVuKCk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNdWx0aVByb3BQbHVnaW4gZXh0ZW5kcyBQbHVnaW4ge1xuICBzZXR0aW5nczogTXVsdGlQcm9wU2V0dGluZ3M7XG4gIGFzeW5jIGxvYWRTZXR0aW5ncygpIHtcbiAgICB0aGlzLnNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFNldHRpbmdzLCBhd2FpdCB0aGlzLmxvYWREYXRhKCkpO1xuICB9XG5cbiAgYXN5bmMgc2F2ZVNldHRpbmdzKCkge1xuICAgIGF3YWl0IHRoaXMuc2F2ZURhdGEodGhpcy5zZXR0aW5ncyk7XG4gIH1cblxuICBhc3luYyBzYXZlRGF0YShzZXR0aW5nczogTXVsdGlQcm9wU2V0dGluZ3MpIHtcblx0ICAvLyBNZXRob2QgaW1wbGVtZW50YXRpb25cbiAgfVxuXG4gIGFzeW5jIGNoYW5nZU92ZXJ3cml0ZShib29sOiBib29sZWFuKSB7XG4gICAgdGhpcy5zZXR0aW5ncy5vdmVyd3JpdGUgPSBib29sO1xuICAgIGF3YWl0IHRoaXMuc2F2ZVNldHRpbmdzKCk7XG4gIH1cblxuICBwcml2YXRlIF9nZXRGaWxlc0Zyb21UYWJHcm91cChsZWFmOiBXb3Jrc3BhY2VMZWFmIHwgbnVsbCk6IFRGaWxlW10ge1xuICAgIGlmICghbGVhZikgcmV0dXJuIFtdO1xuICAgIGNvbnN0IGZpbGVzOiBURmlsZVtdID0gW107XG4gICAgY29uc3QgZmlsZVNldCA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgIGNvbnN0IGFjdGl2ZVBhcmVudCA9IGxlYWYucGFyZW50O1xuXG4gICAgaWYgKGFjdGl2ZVBhcmVudCBpbnN0YW5jZW9mIFdvcmtzcGFjZVRhYnMpIHtcbiAgICAgIHRoaXMuYXBwLndvcmtzcGFjZS5pdGVyYXRlQWxsTGVhdmVzKChsOiBXb3Jrc3BhY2VMZWFmKSA9PiB7XG4gICAgICAgIGlmIChsLnBhcmVudCA9PT0gYWN0aXZlUGFyZW50ICYmIGwudmlldyBpbnN0YW5jZW9mIEZpbGVWaWV3KSB7XG4gICAgICAgICAgY29uc3QgZmlsZSA9IGwudmlldy5maWxlO1xuICAgICAgICAgIGlmIChmaWxlICYmICFmaWxlU2V0LmhhcyhmaWxlLnBhdGgpKSB7XG4gICAgICAgICAgICBmaWxlcy5wdXNoKGZpbGUpO1xuICAgICAgICAgICAgZmlsZVNldC5hZGQoZmlsZS5wYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBhY3RpdmVXaW5kb3dSb290ID0gbGVhZi5nZXRSb290KCk7XG4gICAgICB0aGlzLmFwcC53b3Jrc3BhY2UuaXRlcmF0ZUFsbExlYXZlcygobDogV29ya3NwYWNlTGVhZikgPT4ge1xuICAgICAgICBpZiAobC5nZXRSb290KCkgPT09IGFjdGl2ZVdpbmRvd1Jvb3QgJiYgbC52aWV3IGluc3RhbmNlb2YgRmlsZVZpZXcpIHtcbiAgICAgICAgICBjb25zdCBmaWxlID0gbC52aWV3LmZpbGU7XG4gICAgICAgICAgaWYgKGZpbGUgJiYgIWZpbGVTZXQuaGFzKGZpbGUucGF0aCkpIHtcbiAgICAgICAgICAgIGZpbGVzLnB1c2goZmlsZSk7XG4gICAgICAgICAgICBmaWxlU2V0LmFkZChmaWxlLnBhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBmaWxlcztcbiAgfVxuXG4gIGFzeW5jIG9ubG9hZCgpIHtcbiAgICBhd2FpdCB0aGlzLmxvYWRTZXR0aW5ncygpO1xuICAgIHRoaXMuYWRkU2V0dGluZ1RhYihuZXcgU2V0dGluZ1RhYih0aGlzLmFwcCwgdGhpcykpO1xuXG4gICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgIGlkOiBcImFkZC1wcm9wcy10by1jdXJyZW50LW5vdGVcIixcbiAgICAgIG5hbWU6IFwiQWRkIHByb3BzIHRvIGN1cnJlbnQgbm90ZVwiLFxuICAgICAgY2FsbGJhY2s6IGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgZmlsZSA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVGaWxlKCk7XG4gICAgICAgIGlmIChmaWxlKSBhd2FpdCB0aGlzLmNyZWF0ZVByb3BNb2RhbChbZmlsZV0pO1xuICAgICAgfSxcbiAgICB9KTtcblxuICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICBpZDogXCJyZW1vdmUtcHJvcHMtZnJvbS1jdXJyZW50LW5vdGVcIixcbiAgICAgIG5hbWU6IFwiUmVtb3ZlIHByb3BzIGZyb20gY3VycmVudCBub3RlXCIsXG4gICAgICBjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBmaWxlID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZUZpbGUoKTtcbiAgICAgICAgaWYgKGZpbGUpIGF3YWl0IHRoaXMuY3JlYXRlUmVtb3ZlTW9kYWwoW2ZpbGVdKTtcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgaWQ6IFwiYWRkLXByb3BzLXRvLXRhYi1ncm91cFwiLFxuICAgICAgbmFtZTogXCJBZGQgcHJvcHMgdG8gdGFicyBpbiBhY3RpdmUgdGFiIGdyb3VwXCIsXG4gICAgICBjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBmaWxlcyA9IHRoaXMuX2dldEZpbGVzRnJvbVRhYkdyb3VwKHRoaXMuYXBwLndvcmtzcGFjZS5hY3RpdmVMZWFmKTtcbiAgICAgICAgaWYgKGZpbGVzLmxlbmd0aCA+IDApIGF3YWl0IHRoaXMuY3JlYXRlUHJvcE1vZGFsKGZpbGVzKTtcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgaWQ6IFwicmVtb3ZlLXByb3BzLWZyb20tdGFiLWdyb3VwXCIsXG4gICAgICBuYW1lOiBcIlJlbW92ZSBwcm9wcyBmcm9tIHRhYnMgaW4gYWN0aXZlIHRhYiBncm91cFwiLFxuICAgICAgY2FsbGJhY2s6IGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgZmlsZXMgPSB0aGlzLl9nZXRGaWxlc0Zyb21UYWJHcm91cCh0aGlzLmFwcC53b3Jrc3BhY2UuYWN0aXZlTGVhZik7XG4gICAgICAgIGlmIChmaWxlcy5sZW5ndGggPiAwKSBhd2FpdCB0aGlzLmNyZWF0ZVJlbW92ZU1vZGFsKGZpbGVzKTtcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgaWQ6IFwiYWRkLXZhbHVlLXRvLXByb3BlcnR5XCIsXG4gICAgICBuYW1lOiBcIkFkZCB2YWx1ZSB0byBhIHByb3BlcnR5IG9uIHRoZSBjdXJyZW50IG5vdGVcIixcbiAgICAgIGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpO1xuICAgICAgICBpZiAoZmlsZSkgbmV3IFZhbHVlU2VsZWN0b3IodGhpcy5hcHAsIFtmaWxlXSwgdGhpcykuYWRkVmFsdWUoKTtcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgaWQ6IFwicmVtb3ZlLXZhbHVlLWZyb20tcHJvcGVydHlcIixcbiAgICAgIG5hbWU6IFwiUmVtb3ZlIGEgdmFsdWUgZnJvbSBhIHByb3BlcnR5IG9uIHRoZSBjdXJyZW50IG5vdGVcIixcbiAgICAgIGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpO1xuICAgICAgICBpZiAoZmlsZSkgbmV3IFZhbHVlU2VsZWN0b3IodGhpcy5hcHAsIFtmaWxlXSwgdGhpcykucmVtb3ZlVmFsdWUoKTtcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgaWQ6IFwicmVtb3ZlLXZhbHVlLWZyb20tcHJvcGVydHktaW4tdGFiLWdyb3VwXCIsXG4gICAgICBuYW1lOiBcIlJlbW92ZSBhIHZhbHVlIGZyb20gYSBwcm9wZXJ0eSBvbiBhbGwgbm90ZXMgaW4gdGhlIGFjdGl2ZSB0YWIgZ3JvdXBcIixcbiAgICAgIGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGZpbGVzID0gdGhpcy5fZ2V0RmlsZXNGcm9tVGFiR3JvdXAodGhpcy5hcHAud29ya3NwYWNlLmFjdGl2ZUxlYWYpO1xuICAgICAgICBpZiAoZmlsZXMubGVuZ3RoID4gMCkgbmV3IFZhbHVlU2VsZWN0b3IodGhpcy5hcHAsIGZpbGVzLCB0aGlzKS5yZW1vdmVWYWx1ZSgpO1xuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGdldFByb3BzRnJvbUZvbGRlcihmb2xkZXI6IFRGb2xkZXIsIG5hbWVzOiBTZXQ8c3RyaW5nPikge1xuICAgIGZvciAobGV0IG9iaiBvZiBmb2xkZXIuY2hpbGRyZW4pIHtcbiAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBURmlsZSAmJiBvYmouZXh0ZW5zaW9uID09PSBcIm1kXCIpIHtcbiAgICAgICAgbmFtZXMgPSBhd2FpdCBhZGRQcm9wVG9TZXQodGhpcy5hcHAuZmlsZU1hbmFnZXIucHJvY2Vzc0Zyb250TWF0dGVyLmJpbmQodGhpcy5hcHAuZmlsZU1hbmFnZXIpLCBuYW1lcywgb2JqKTtcbiAgICAgIH1cbiAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBURm9sZGVyICYmIHRoaXMuc2V0dGluZ3MucmVjdXJzaXZlKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZ2V0UHJvcHNGcm9tRm9sZGVyKG9iaiwgbmFtZXMpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gWy4uLm5hbWVzXS5zb3J0KCk7XG4gIH1cblxuICBhc3luYyBnZXRQcm9wc0Zyb21GaWxlcyhmaWxlczogVEFic3RyYWN0RmlsZVtdLCBuYW1lczogU2V0PHN0cmluZz4pIHtcbiAgICBmb3IgKGxldCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgICBpZiAoZmlsZSBpbnN0YW5jZW9mIFRGaWxlICYmIGZpbGUuZXh0ZW5zaW9uID09PSBcIm1kXCIpIHtcbiAgICAgICAgbmFtZXMgPSBhd2FpdCBhZGRQcm9wVG9TZXQodGhpcy5hcHAuZmlsZU1hbmFnZXIucHJvY2Vzc0Zyb250TWF0dGVyLmJpbmQodGhpcy5hcHAuZmlsZU1hbmFnZXIpLCBuYW1lcywgZmlsZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbLi4ubmFtZXNdO1xuICB9XG5cbiAgYXN5bmMgc2VhcmNoRm9sZGVycyhmb2xkZXI6IFRGb2xkZXIsIGNhbGxiYWNrOiAoZmlsZTogVEZpbGUpID0+IGFueSkge1xuICAgIGZvciAobGV0IG9iaiBvZiBmb2xkZXIuY2hpbGRyZW4pIHtcbiAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBURm9sZGVyICYmIHRoaXMuc2V0dGluZ3MucmVjdXJzaXZlKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VhcmNoRm9sZGVycyhvYmosIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBURmlsZSAmJiBvYmouZXh0ZW5zaW9uID09PSBcIm1kXCIpIHtcbiAgICAgICAgYXdhaXQgY2FsbGJhY2sob2JqKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhc3luYyBzZWFyY2hGaWxlcyhmaWxlczogVEFic3RyYWN0RmlsZVtdLCBjYWxsYmFjazogKGZpbGU6IFRGaWxlKSA9PiBhbnkpIHtcbiAgICBmb3IgKGxldCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgICBpZiAoZmlsZSBpbnN0YW5jZW9mIFRGaWxlICYmIGZpbGUuZXh0ZW5zaW9uID09PSBcIm1kXCIpIHtcbiAgICAgICAgYXdhaXQgY2FsbGJhY2soZmlsZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgY3JlYXRlUHJvcE1vZGFsKGl0ZXJhYmxlOiBURmlsZVtdIHwgVEZvbGRlcikge1xuICAgIGxldCBpdGVyYXRlRnVuYztcbiAgICBsZXQgZmlsZXM6IFRGaWxlW10gPSBbXTtcbiAgICBpZiAoaXRlcmFibGUgaW5zdGFuY2VvZiBURm9sZGVyKSB7XG4gICAgICBpdGVyYXRlRnVuYyA9IGFzeW5jIChwcm9wczogTWFwPHN0cmluZywgYW55PikgPT5cbiAgICAgICAgYXdhaXQgdGhpcy5zZWFyY2hGb2xkZXJzKGl0ZXJhYmxlLCB0aGlzLmFkZFByb3BzQ2FsbGJhY2socHJvcHMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmlsZXMgPSBpdGVyYWJsZTtcbiAgICAgIGl0ZXJhdGVGdW5jID0gYXN5bmMgKHByb3BzOiBNYXA8c3RyaW5nLCBhbnk+KSA9PlxuICAgICAgICBhd2FpdCB0aGlzLnNlYXJjaEZpbGVzKGZpbGVzLCB0aGlzLmFkZFByb3BzQ2FsbGJhY2socHJvcHMpKTtcbiAgICB9XG5cbiAgICBsZXQgZGVmYXVsdFByb3BzOiB7IG5hbWU6IHN0cmluZzsgdmFsdWU6IGFueTsgdHlwZTogUHJvcGVydHlUeXBlcyB9W10gPSBbXTtcbiAgICBpZiAodGhpcy5zZXR0aW5ncy5kZWZhdWx0UHJvcFBhdGgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoYCR7dGhpcy5zZXR0aW5ncy5kZWZhdWx0UHJvcFBhdGh9Lm1kYCk7XG4gICAgICAgICAgICBpZiAoZmlsZSAmJiBmaWxlIGluc3RhbmNlb2YgVEZpbGUpIHtcbiAgICAgICAgICAgICAgICBsZXQgdG1wID0gdGhpcy5yZWFkWWFtbFByb3BlcnRpZXMoZmlsZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRtcCkgZGVmYXVsdFByb3BzID0gdG1wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKGAke2V9LiBDaGVjayBwYXRoIGluIHNldHRpbmdzLmAsIDEwMDAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGVmYXVsdFByb3BzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBkZWZhdWx0UHJvcHMgPSBbeyBuYW1lOiBcIlwiLCB2YWx1ZTogXCJcIiwgdHlwZTogXCJ0ZXh0XCIgfV07XG4gICAgfVxuXG4gICAgbmV3IFByb3BNb2RhbCh0aGlzLmFwcCwgaXRlcmF0ZUZ1bmMsIHRoaXMuc2V0dGluZ3Mub3ZlcndyaXRlLCB0aGlzLnNldHRpbmdzLmRlbGltaXRlciwgZGVmYXVsdFByb3BzLCB0aGlzLmNoYW5nZU92ZXJ3cml0ZS5iaW5kKHRoaXMpKS5vcGVuKCk7XG4gIH1cblxuICBhc3luYyBjcmVhdGVSZW1vdmVNb2RhbChpdGVyYWJsZTogVEFic3RyYWN0RmlsZVtdIHwgVEZvbGRlcikge1xuICAgIGxldCBuYW1lcztcbiAgICBsZXQgaXRlcmF0ZUZ1bmM7XG5cbiAgICBpZiAoaXRlcmFibGUgaW5zdGFuY2VvZiBURm9sZGVyKSB7XG4gICAgICBuYW1lcyA9IGF3YWl0IHRoaXMuZ2V0UHJvcHNGcm9tRm9sZGVyKGl0ZXJhYmxlLCBuZXcgU2V0KCkpO1xuICAgICAgaXRlcmF0ZUZ1bmMgPSBhc3luYyAocHJvcHM6IHN0cmluZ1tdKSA9PlxuICAgICAgICBhd2FpdCB0aGlzLnNlYXJjaEZvbGRlcnMoaXRlcmFibGUsIHRoaXMucmVtb3ZlUHJvcHNDYWxsYmFjayhwcm9wcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lcyA9IGF3YWl0IHRoaXMuZ2V0UHJvcHNGcm9tRmlsZXMoaXRlcmFibGUsIG5ldyBTZXQoKSk7XG4gICAgICBpdGVyYXRlRnVuYyA9IGFzeW5jIChwcm9wczogc3RyaW5nW10pID0+XG4gICAgICAgIGF3YWl0IHRoaXMuc2VhcmNoRmlsZXMoaXRlcmFibGUsIHRoaXMucmVtb3ZlUHJvcHNDYWxsYmFjayhwcm9wcykpO1xuICAgIH1cbiAgICBpZiAobmFtZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBuZXcgTm90aWNlKFwiTm8gcHJvcGVydGllcyB0byByZW1vdmVcIiwgNDAwMCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc29ydGVkTmFtZXMgPSBbLi4ubmFtZXNdLnNvcnQoKGEsIGIpID0+IGEudG9Mb3dlckNhc2UoKSA+IGIudG9Mb3dlckNhc2UoKSA/IDEgOiAtMSk7XG4gICAgbmV3IFJlbW92ZU1vZGFsKHRoaXMuYXBwLCBzb3J0ZWROYW1lcywgaXRlcmF0ZUZ1bmMpLm9wZW4oKTtcbiAgfVxuXG4gIGFzeW5jIGdldExpc3RQcm9wZXJ0aWVzKGZpbGVzOiBURmlsZVtdKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIGNvbnN0IGxpc3RQcm9wcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgIGZvciAoY29uc3QgZmlsZSBvZiBmaWxlcykge1xuICAgICAgY29uc3QgbWV0YWRhdGEgPSB0aGlzLmFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKTtcbiAgICAgIGlmIChtZXRhZGF0YSAmJiBtZXRhZGF0YS5mcm9udG1hdHRlcikge1xuICAgICAgICBjb25zdCBmcm9udG1hdHRlcjoge1trZXk6IHN0cmluZ106IGFueX0gPSBtZXRhZGF0YS5mcm9udG1hdHRlcjtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZnJvbnRtYXR0ZXIpKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBsaXN0UHJvcHMuYWRkKGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbLi4ubGlzdFByb3BzXS5zb3J0KCk7XG4gIH1cblxuICBhc3luYyBnZXRBbGxVbmlxdWVWYWx1ZXNGb3JQcm9wZXJ0eShwcm9wZXJ0eTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIGNvbnN0IHZhbHVlcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgIGNvbnN0IGZpbGVzID0gdGhpcy5hcHAudmF1bHQuZ2V0TWFya2Rvd25GaWxlcygpO1xuICAgIGZvciAoY29uc3QgZmlsZSBvZiBmaWxlcykge1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGZpbGUpO1xuICAgICAgICBpZiAobWV0YWRhdGEgJiYgbWV0YWRhdGEuZnJvbnRtYXR0ZXIgJiYgbWV0YWRhdGEuZnJvbnRtYXR0ZXJbcHJvcGVydHldKSB7XG4gICAgICAgICAgICBjb25zdCBmcm9udG1hdHRlcjoge1trZXk6IHN0cmluZ106IGFueX0gPSBtZXRhZGF0YS5mcm9udG1hdHRlcjtcbiAgICAgICAgICAgIGNvbnN0IHByb3BWYWx1ZXMgPSBBcnJheS5pc0FycmF5KGZyb250bWF0dGVyW3Byb3BlcnR5XSkgPyBmcm9udG1hdHRlcltwcm9wZXJ0eV0gOiBbZnJvbnRtYXR0ZXJbcHJvcGVydHldXTtcbiAgICAgICAgICAgIHByb3BWYWx1ZXMuZm9yRWFjaCgodjogYW55KSA9PiB2YWx1ZXMuYWRkKFN0cmluZyh2KSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbLi4udmFsdWVzXS5zb3J0KCk7XG4gIH1cblxuICByZWFkWWFtbFByb3BlcnRpZXMoZmlsZTogVEZpbGUpIHtcbiAgICBjb25zdCBtZXRhZGF0YSA9IHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGZpbGUpO1xuICAgIGlmIChtZXRhZGF0YSAmJiBtZXRhZGF0YS5mcm9udG1hdHRlcikge1xuICAgICAgY29uc3QgZnJvbnRtYXR0ZXI6IHtba2V5OiBzdHJpbmddOiBhbnl9ID0gbWV0YWRhdGEuZnJvbnRtYXR0ZXI7XG4gICAgICBjb25zdCBhbGxQcm9wc1dpdGhUeXBlOiB7W2tleTogc3RyaW5nXTogYW55fSA9IHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0QWxsUHJvcGVydHlJbmZvcygpO1xuICAgICAgbGV0IHJlc3VsdDogeyBuYW1lOiBzdHJpbmc7IHZhbHVlOiBhbnk7IHR5cGU6IFByb3BlcnR5VHlwZXMgfVtdID0gW107XG4gICAgICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZnJvbnRtYXR0ZXIpKSB7XG4gICAgICAgIGNvbnN0IGtleUxvd2VyID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJlc3VsdC5wdXNoKHsgbmFtZToga2V5LCB2YWx1ZTogdmFsdWUsIHR5cGU6IGFsbFByb3BzV2l0aFR5cGVba2V5TG93ZXJdPy50eXBlIHx8ICd0ZXh0JyB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG5cbiAgYWRkUHJvcHNDYWxsYmFjayhwcm9wczogYW55KSB7XG4gICAgcmV0dXJuIGFzeW5jIChmaWxlOiBURmlsZSkgPT4ge1xuICAgICAgYXdhaXQgYWRkUHJvcGVydGllcyh0aGlzLmFwcC5maWxlTWFuYWdlci5wcm9jZXNzRnJvbnRNYXR0ZXIuYmluZCh0aGlzLmFwcC5maWxlTWFuYWdlciksIGZpbGUsIHByb3BzLCB0aGlzLnNldHRpbmdzLm92ZXJ3cml0ZSwgdGhpcy5hcHAubWV0YWRhdGFDYWNoZS5nZXRBbGxQcm9wZXJ0eUluZm9zKCkpO1xuICAgIH07XG4gIH1cblxuICByZW1vdmVQcm9wc0NhbGxiYWNrKHByb3BzOiBhbnkpIHtcbiAgICByZXR1cm4gYXN5bmMgKGZpbGU6IFRGaWxlKSA9PiB7XG4gICAgICBhd2FpdCByZW1vdmVQcm9wZXJ0aWVzKHRoaXMuYXBwLmZpbGVNYW5hZ2VyLnByb2Nlc3NGcm9udE1hdHRlci5iaW5kKHRoaXMuYXBwLmZpbGVNYW5hZ2VyKSwgZmlsZSwgcHJvcHMpO1xuICAgIH07XG4gIH1cbn0iLCAiaW1wb3J0IHsgTW9kYWwsIEFwcCB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IFByb3BGb3JtIGZyb20gXCIuL0FkZFByb3BGb3JtLnN2ZWx0ZVwiO1xuaW1wb3J0IHsgTmV3UHJvcERhdGEgfSBmcm9tIFwiLi9tYWluXCI7XG5pbXBvcnQgeyBBZGRDb25maXJtTW9kYWwgfSBmcm9tIFwiLi9BZGRDb25maXJtTW9kYWxcIjtcbmltcG9ydCB7IFByb3BlcnR5VHlwZXMgfSBmcm9tIFwiLi90eXBlcy9jdXN0b21cIjtcblxuLyoqIExvYWRzIGEgbW9kYWwgYW5kIGhhbmRsZXMgZm9ybSBzdWJtaXNzaW9ucy4gKi9cbmV4cG9ydCBjbGFzcyBQcm9wTW9kYWwgZXh0ZW5kcyBNb2RhbCB7XG4gIHN1Ym1pc3Npb246IChjdXN0b21Qcm9wczogTWFwPHN0cmluZywgYW55PikgPT4gUHJvbWlzZTx2b2lkPjtcbiAgcHJvcHM6IE1hcDxzdHJpbmcsIE5ld1Byb3BEYXRhPjtcbiAgb3ZlcndyaXRlOiBib29sZWFuO1xuICBkZWxpbWl0ZXI6IHN0cmluZztcbiAgZGVmYXVsdFByb3BzOiB7IG5hbWU6IHN0cmluZzsgdmFsdWU6IGFueTsgdHlwZTogUHJvcGVydHlUeXBlczsgfVtdO1xuICBjaGFuZ2VCb29sOiAoYm9vbDogYm9vbGVhbikgPT4gdm9pZDtcbiAgY29tcG9uZW50OiBQcm9wRm9ybTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBhcHA6IEFwcCxcbiAgICBzdWJtaXNzaW9uOiAoY3VzdG9tUHJvcHM6IE1hcDxzdHJpbmcsIGFueT4pID0+IFByb21pc2U8dm9pZD4sXG4gICAgb3ZlcndyaXRlOiBib29sZWFuLFxuICAgIGRlbGltaXRlcjogc3RyaW5nLFxuICAgIGRlZmF1bHRQcm9wczogYW55LFxuICAgIGNoYW5nZUJvb2w6IChib29sOiBib29sZWFuKSA9PiB2b2lkXG4gICkge1xuICAgIHN1cGVyKGFwcCk7XG4gICAgdGhpcy5zdWJtaXNzaW9uID0gc3VibWlzc2lvbjtcbiAgICB0aGlzLm92ZXJ3cml0ZSA9IG92ZXJ3cml0ZTtcbiAgICB0aGlzLmRlbGltaXRlciA9IGRlbGltaXRlcjtcbiAgICB0aGlzLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbiAgICB0aGlzLmNoYW5nZUJvb2wgPSBjaGFuZ2VCb29sO1xuICB9XG5cbiAgLy9SdW4gZm9ybSBzdWJtaXNzaW9uIGlmIHVzZXIgY2xpY2tzIGNvbmZpcm0uXG4gIGFzeW5jIG9uQ29uZmlybShib29sOiBib29sZWFuKSB7XG4gICAgaWYgKGJvb2wpIHtcbiAgICAgIGF3YWl0IHRoaXMuc3VibWlzc2lvbih0aGlzLnByb3BzKTtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVCb29sKGJvb2w6IGJvb2xlYW4pIHtcbiAgICB0aGlzLm92ZXJ3cml0ZSA9IGJvb2w7XG4gICAgdGhpcy5jaGFuZ2VCb29sKGJvb2wpO1xuICB9XG5cbiAgLy9QdWxsIHVwIGNvbmZpcm1hdGlvbiBmb3JtIHdoZW4gdXNlciBzdWJtaXRzIGJhc2UgZm9ybS5cbiAgb25TdWJtaXQocHJvcHM6IE1hcDxzdHJpbmcsIE5ld1Byb3BEYXRhPikge1xuICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICBuZXcgQWRkQ29uZmlybU1vZGFsKFxuICAgICAgdGhpcy5hcHAsXG4gICAgICB0aGlzLnByb3BzLFxuICAgICAgdGhpcy5vdmVyd3JpdGUsXG4gICAgICB0aGlzLm9uQ29uZmlybS5iaW5kKHRoaXMpXG4gICAgKS5vcGVuKCk7XG4gIH1cblxuICBvbk9wZW4oKTogdm9pZCB7XG4gICAgdGhpcy50aXRsZUVsLmNyZWF0ZUVsKFwiaDJcIiwgeyB0ZXh0OiBcIkFkZCBQcm9wZXJ0aWVzXCIgfSk7XG5cbiAgICB0aGlzLmNvbXBvbmVudCA9IG5ldyBQcm9wRm9ybSh7XG4gICAgICB0YXJnZXQ6IHRoaXMuY29udGVudEVsLFxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgc3VibWlzc2lvbjogdGhpcy5vblN1Ym1pdC5iaW5kKHRoaXMpLFxuICAgICAgICBvdmVyd3JpdGU6IHRoaXMub3ZlcndyaXRlLFxuICAgICAgICBkZWxpbWl0ZXI6IHRoaXMuZGVsaW1pdGVyLFxuICAgICAgICBkZWZhdWx0UHJvcHM6IHRoaXMuZGVmYXVsdFByb3BzLFxuICAgICAgICBjaGFuZ2VCb29sOiB0aGlzLnVwZGF0ZUJvb2wuYmluZCh0aGlzKSxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cbn1cbiIsICIvKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmV4cG9ydCBjb25zdCBpZGVudGl0eSA9ICh4KSA9PiB4O1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAdGVtcGxhdGUgU1xuICogQHBhcmFtIHtUfSB0YXJcbiAqIEBwYXJhbSB7U30gc3JjXG4gKiBAcmV0dXJucyB7VCAmIFN9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ24odGFyLCBzcmMpIHtcblx0Ly8gQHRzLWlnbm9yZVxuXHRmb3IgKGNvbnN0IGsgaW4gc3JjKSB0YXJba10gPSBzcmNba107XG5cdHJldHVybiAvKiogQHR5cGUge1QgJiBTfSAqLyAodGFyKTtcbn1cblxuLy8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS90aGVuL2lzLXByb21pc2UvYmxvYi9tYXN0ZXIvaW5kZXguanNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIE1JVCBMaWNlbnNlIGh0dHBzOi8vZ2l0aHViLmNvbS90aGVuL2lzLXByb21pc2UvYmxvYi9tYXN0ZXIvTElDRU5TRVxuLyoqXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEByZXR1cm5zIHt2YWx1ZSBpcyBQcm9taXNlTGlrZTxhbnk+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNfcHJvbWlzZSh2YWx1ZSkge1xuXHRyZXR1cm4gKFxuXHRcdCEhdmFsdWUgJiZcblx0XHQodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpICYmXG5cdFx0dHlwZW9mICgvKiogQHR5cGUge2FueX0gKi8gKHZhbHVlKS50aGVuKSA9PT0gJ2Z1bmN0aW9uJ1xuXHQpO1xufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gYWRkX2xvY2F0aW9uKGVsZW1lbnQsIGZpbGUsIGxpbmUsIGNvbHVtbiwgY2hhcikge1xuXHRlbGVtZW50Ll9fc3ZlbHRlX21ldGEgPSB7XG5cdFx0bG9jOiB7IGZpbGUsIGxpbmUsIGNvbHVtbiwgY2hhciB9XG5cdH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBydW4oZm4pIHtcblx0cmV0dXJuIGZuKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBibGFua19vYmplY3QoKSB7XG5cdHJldHVybiBPYmplY3QuY3JlYXRlKG51bGwpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RnVuY3Rpb25bXX0gZm5zXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJ1bl9hbGwoZm5zKSB7XG5cdGZucy5mb3JFYWNoKHJ1bik7XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHRoaW5nXG4gKiBAcmV0dXJucyB7dGhpbmcgaXMgRnVuY3Rpb259XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19mdW5jdGlvbih0aGluZykge1xuXHRyZXR1cm4gdHlwZW9mIHRoaW5nID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKiogQHJldHVybnMge2Jvb2xlYW59ICovXG5leHBvcnQgZnVuY3Rpb24gc2FmZV9ub3RfZXF1YWwoYSwgYikge1xuXHRyZXR1cm4gYSAhPSBhID8gYiA9PSBiIDogYSAhPT0gYiB8fCAoYSAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcpIHx8IHR5cGVvZiBhID09PSAnZnVuY3Rpb24nO1xufVxuXG5sZXQgc3JjX3VybF9lcXVhbF9hbmNob3I7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGVsZW1lbnRfc3JjXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNyY191cmxfZXF1YWwoZWxlbWVudF9zcmMsIHVybCkge1xuXHRpZiAoZWxlbWVudF9zcmMgPT09IHVybCkgcmV0dXJuIHRydWU7XG5cdGlmICghc3JjX3VybF9lcXVhbF9hbmNob3IpIHtcblx0XHRzcmNfdXJsX2VxdWFsX2FuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcblx0fVxuXHQvLyBUaGlzIGlzIGFjdHVhbGx5IGZhc3RlciB0aGFuIGRvaW5nIFVSTCguLikuaHJlZlxuXHRzcmNfdXJsX2VxdWFsX2FuY2hvci5ocmVmID0gdXJsO1xuXHRyZXR1cm4gZWxlbWVudF9zcmMgPT09IHNyY191cmxfZXF1YWxfYW5jaG9yLmhyZWY7XG59XG5cbi8qKiBAcGFyYW0ge3N0cmluZ30gc3Jjc2V0ICovXG5mdW5jdGlvbiBzcGxpdF9zcmNzZXQoc3Jjc2V0KSB7XG5cdHJldHVybiBzcmNzZXQuc3BsaXQoJywnKS5tYXAoKHNyYykgPT4gc3JjLnRyaW0oKS5zcGxpdCgnICcpLmZpbHRlcihCb29sZWFuKSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MU291cmNlRWxlbWVudCB8IEhUTUxJbWFnZUVsZW1lbnR9IGVsZW1lbnRfc3Jjc2V0XG4gKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZCB8IG51bGx9IHNyY3NldFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcmNzZXRfdXJsX2VxdWFsKGVsZW1lbnRfc3Jjc2V0LCBzcmNzZXQpIHtcblx0Y29uc3QgZWxlbWVudF91cmxzID0gc3BsaXRfc3Jjc2V0KGVsZW1lbnRfc3Jjc2V0LnNyY3NldCk7XG5cdGNvbnN0IHVybHMgPSBzcGxpdF9zcmNzZXQoc3Jjc2V0IHx8ICcnKTtcblxuXHRyZXR1cm4gKFxuXHRcdHVybHMubGVuZ3RoID09PSBlbGVtZW50X3VybHMubGVuZ3RoICYmXG5cdFx0dXJscy5ldmVyeShcblx0XHRcdChbdXJsLCB3aWR0aF0sIGkpID0+XG5cdFx0XHRcdHdpZHRoID09PSBlbGVtZW50X3VybHNbaV1bMV0gJiZcblx0XHRcdFx0Ly8gV2UgbmVlZCB0byB0ZXN0IGJvdGggd2F5cyBiZWNhdXNlIFZpdGUgd2lsbCBjcmVhdGUgYW4gYSBmdWxsIFVSTCB3aXRoXG5cdFx0XHRcdC8vIGBuZXcgVVJMKGFzc2V0LCBpbXBvcnQubWV0YS51cmwpLmhyZWZgIGZvciB0aGUgY2xpZW50IHdoZW4gYGJhc2U6ICcuLydgLCBhbmQgdGhlXG5cdFx0XHRcdC8vIHJlbGF0aXZlIFVSTHMgaW5zaWRlIHNyY3NldCBhcmUgbm90IGF1dG9tYXRpY2FsbHkgcmVzb2x2ZWQgdG8gYWJzb2x1dGUgVVJMcyBieVxuXHRcdFx0XHQvLyBicm93c2VycyAoaW4gY29udHJhc3QgdG8gaW1nLnNyYykuIFRoaXMgbWVhbnMgYm90aCBTU1IgYW5kIERPTSBjb2RlIGNvdWxkXG5cdFx0XHRcdC8vIGNvbnRhaW4gcmVsYXRpdmUgb3IgYWJzb2x1dGUgVVJMcy5cblx0XHRcdFx0KHNyY191cmxfZXF1YWwoZWxlbWVudF91cmxzW2ldWzBdLCB1cmwpIHx8IHNyY191cmxfZXF1YWwodXJsLCBlbGVtZW50X3VybHNbaV1bMF0pKVxuXHRcdClcblx0KTtcbn1cblxuLyoqIEByZXR1cm5zIHtib29sZWFufSAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vdF9lcXVhbChhLCBiKSB7XG5cdHJldHVybiBhICE9IGEgPyBiID09IGIgOiBhICE9PSBiO1xufVxuXG4vKiogQHJldHVybnMge2Jvb2xlYW59ICovXG5leHBvcnQgZnVuY3Rpb24gaXNfZW1wdHkob2JqKSB7XG5cdHJldHVybiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA9PT0gMDtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlX3N0b3JlKHN0b3JlLCBuYW1lKSB7XG5cdGlmIChzdG9yZSAhPSBudWxsICYmIHR5cGVvZiBzdG9yZS5zdWJzY3JpYmUgIT09ICdmdW5jdGlvbicpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYCcke25hbWV9JyBpcyBub3QgYSBzdG9yZSB3aXRoIGEgJ3N1YnNjcmliZScgbWV0aG9kYCk7XG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN1YnNjcmliZShzdG9yZSwgLi4uY2FsbGJhY2tzKSB7XG5cdGlmIChzdG9yZSA9PSBudWxsKSB7XG5cdFx0Zm9yIChjb25zdCBjYWxsYmFjayBvZiBjYWxsYmFja3MpIHtcblx0XHRcdGNhbGxiYWNrKHVuZGVmaW5lZCk7XG5cdFx0fVxuXHRcdHJldHVybiBub29wO1xuXHR9XG5cdGNvbnN0IHVuc3ViID0gc3RvcmUuc3Vic2NyaWJlKC4uLmNhbGxiYWNrcyk7XG5cdHJldHVybiB1bnN1Yi51bnN1YnNjcmliZSA/ICgpID0+IHVuc3ViLnVuc3Vic2NyaWJlKCkgOiB1bnN1Yjtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgdmFsdWUgZnJvbSBhIHN0b3JlIGJ5IHN1YnNjcmliaW5nIGFuZCBpbW1lZGlhdGVseSB1bnN1YnNjcmliaW5nLlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS1zdG9yZSNnZXRcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vc3RvcmUvcHVibGljLmpzJykuUmVhZGFibGU8VD59IHN0b3JlXG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldF9zdG9yZV92YWx1ZShzdG9yZSkge1xuXHRsZXQgdmFsdWU7XG5cdHN1YnNjcmliZShzdG9yZSwgKF8pID0+ICh2YWx1ZSA9IF8pKSgpO1xuXHRyZXR1cm4gdmFsdWU7XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wb25lbnRfc3Vic2NyaWJlKGNvbXBvbmVudCwgc3RvcmUsIGNhbGxiYWNrKSB7XG5cdGNvbXBvbmVudC4kJC5vbl9kZXN0cm95LnB1c2goc3Vic2NyaWJlKHN0b3JlLCBjYWxsYmFjaykpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlX3Nsb3QoZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBmbikge1xuXHRpZiAoZGVmaW5pdGlvbikge1xuXHRcdGNvbnN0IHNsb3RfY3R4ID0gZ2V0X3Nsb3RfY29udGV4dChkZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGZuKTtcblx0XHRyZXR1cm4gZGVmaW5pdGlvblswXShzbG90X2N0eCk7XG5cdH1cbn1cblxuZnVuY3Rpb24gZ2V0X3Nsb3RfY29udGV4dChkZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGZuKSB7XG5cdHJldHVybiBkZWZpbml0aW9uWzFdICYmIGZuID8gYXNzaWduKCQkc2NvcGUuY3R4LnNsaWNlKCksIGRlZmluaXRpb25bMV0oZm4oY3R4KSkpIDogJCRzY29wZS5jdHg7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRfc2xvdF9jaGFuZ2VzKGRlZmluaXRpb24sICQkc2NvcGUsIGRpcnR5LCBmbikge1xuXHRpZiAoZGVmaW5pdGlvblsyXSAmJiBmbikge1xuXHRcdGNvbnN0IGxldHMgPSBkZWZpbml0aW9uWzJdKGZuKGRpcnR5KSk7XG5cdFx0aWYgKCQkc2NvcGUuZGlydHkgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIGxldHM7XG5cdFx0fVxuXHRcdGlmICh0eXBlb2YgbGV0cyA9PT0gJ29iamVjdCcpIHtcblx0XHRcdGNvbnN0IG1lcmdlZCA9IFtdO1xuXHRcdFx0Y29uc3QgbGVuID0gTWF0aC5tYXgoJCRzY29wZS5kaXJ0eS5sZW5ndGgsIGxldHMubGVuZ3RoKTtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcblx0XHRcdFx0bWVyZ2VkW2ldID0gJCRzY29wZS5kaXJ0eVtpXSB8IGxldHNbaV07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWVyZ2VkO1xuXHRcdH1cblx0XHRyZXR1cm4gJCRzY29wZS5kaXJ0eSB8IGxldHM7XG5cdH1cblx0cmV0dXJuICQkc2NvcGUuZGlydHk7XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVfc2xvdF9iYXNlKFxuXHRzbG90LFxuXHRzbG90X2RlZmluaXRpb24sXG5cdGN0eCxcblx0JCRzY29wZSxcblx0c2xvdF9jaGFuZ2VzLFxuXHRnZXRfc2xvdF9jb250ZXh0X2ZuXG4pIHtcblx0aWYgKHNsb3RfY2hhbmdlcykge1xuXHRcdGNvbnN0IHNsb3RfY29udGV4dCA9IGdldF9zbG90X2NvbnRleHQoc2xvdF9kZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGdldF9zbG90X2NvbnRleHRfZm4pO1xuXHRcdHNsb3QucChzbG90X2NvbnRleHQsIHNsb3RfY2hhbmdlcyk7XG5cdH1cbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZV9zbG90KFxuXHRzbG90LFxuXHRzbG90X2RlZmluaXRpb24sXG5cdGN0eCxcblx0JCRzY29wZSxcblx0ZGlydHksXG5cdGdldF9zbG90X2NoYW5nZXNfZm4sXG5cdGdldF9zbG90X2NvbnRleHRfZm5cbikge1xuXHRjb25zdCBzbG90X2NoYW5nZXMgPSBnZXRfc2xvdF9jaGFuZ2VzKHNsb3RfZGVmaW5pdGlvbiwgJCRzY29wZSwgZGlydHksIGdldF9zbG90X2NoYW5nZXNfZm4pO1xuXHR1cGRhdGVfc2xvdF9iYXNlKHNsb3QsIHNsb3RfZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBzbG90X2NoYW5nZXMsIGdldF9zbG90X2NvbnRleHRfZm4pO1xufVxuXG4vKiogQHJldHVybnMge2FueVtdIHwgLTF9ICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0X2FsbF9kaXJ0eV9mcm9tX3Njb3BlKCQkc2NvcGUpIHtcblx0aWYgKCQkc2NvcGUuY3R4Lmxlbmd0aCA+IDMyKSB7XG5cdFx0Y29uc3QgZGlydHkgPSBbXTtcblx0XHRjb25zdCBsZW5ndGggPSAkJHNjb3BlLmN0eC5sZW5ndGggLyAzMjtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRkaXJ0eVtpXSA9IC0xO1xuXHRcdH1cblx0XHRyZXR1cm4gZGlydHk7XG5cdH1cblx0cmV0dXJuIC0xO1xufVxuXG4vKiogQHJldHVybnMge3t9fSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4Y2x1ZGVfaW50ZXJuYWxfcHJvcHMocHJvcHMpIHtcblx0Y29uc3QgcmVzdWx0ID0ge307XG5cdGZvciAoY29uc3QgayBpbiBwcm9wcykgaWYgKGtbMF0gIT09ICckJykgcmVzdWx0W2tdID0gcHJvcHNba107XG5cdHJldHVybiByZXN1bHQ7XG59XG5cbi8qKiBAcmV0dXJucyB7e319ICovXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZV9yZXN0X3Byb3BzKHByb3BzLCBrZXlzKSB7XG5cdGNvbnN0IHJlc3QgPSB7fTtcblx0a2V5cyA9IG5ldyBTZXQoa2V5cyk7XG5cdGZvciAoY29uc3QgayBpbiBwcm9wcykgaWYgKCFrZXlzLmhhcyhrKSAmJiBrWzBdICE9PSAnJCcpIHJlc3Rba10gPSBwcm9wc1trXTtcblx0cmV0dXJuIHJlc3Q7XG59XG5cbi8qKiBAcmV0dXJucyB7e319ICovXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZV9zbG90cyhzbG90cykge1xuXHRjb25zdCByZXN1bHQgPSB7fTtcblx0Zm9yIChjb25zdCBrZXkgaW4gc2xvdHMpIHtcblx0XHRyZXN1bHRba2V5XSA9IHRydWU7XG5cdH1cblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqIEByZXR1cm5zIHsodGhpczogYW55LCAuLi5hcmdzOiBhbnlbXSkgPT4gdm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBvbmNlKGZuKSB7XG5cdGxldCByYW4gPSBmYWxzZTtcblx0cmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cdFx0aWYgKHJhbikgcmV0dXJuO1xuXHRcdHJhbiA9IHRydWU7XG5cdFx0Zm4uY2FsbCh0aGlzLCAuLi5hcmdzKTtcblx0fTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG51bGxfdG9fZW1wdHkodmFsdWUpIHtcblx0cmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0X3N0b3JlX3ZhbHVlKHN0b3JlLCByZXQsIHZhbHVlKSB7XG5cdHN0b3JlLnNldCh2YWx1ZSk7XG5cdHJldHVybiByZXQ7XG59XG5cbmV4cG9ydCBjb25zdCBoYXNfcHJvcCA9IChvYmosIHByb3ApID0+IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xuXG5leHBvcnQgZnVuY3Rpb24gYWN0aW9uX2Rlc3Ryb3llcihhY3Rpb25fcmVzdWx0KSB7XG5cdHJldHVybiBhY3Rpb25fcmVzdWx0ICYmIGlzX2Z1bmN0aW9uKGFjdGlvbl9yZXN1bHQuZGVzdHJveSkgPyBhY3Rpb25fcmVzdWx0LmRlc3Ryb3kgOiBub29wO1xufVxuXG4vKiogQHBhcmFtIHtudW1iZXIgfCBzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJucyB7W251bWJlciwgc3RyaW5nXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0X2Nzc191bml0KHZhbHVlKSB7XG5cdGNvbnN0IHNwbGl0ID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5tYXRjaCgvXlxccyooLT9bXFxkLl0rKShbXlxcc10qKVxccyokLyk7XG5cdHJldHVybiBzcGxpdCA/IFtwYXJzZUZsb2F0KHNwbGl0WzFdKSwgc3BsaXRbMl0gfHwgJ3B4J10gOiBbLyoqIEB0eXBlIHtudW1iZXJ9ICovICh2YWx1ZSksICdweCddO1xufVxuXG5leHBvcnQgY29uc3QgY29udGVudGVkaXRhYmxlX3RydXRoeV92YWx1ZXMgPSBbJycsIHRydWUsIDEsICd0cnVlJywgJ2NvbnRlbnRlZGl0YWJsZSddO1xuIiwgIi8qKiBAdHlwZSB7dHlwZW9mIGdsb2JhbFRoaXN9ICovXG5leHBvcnQgY29uc3QgZ2xvYmFscyA9XG5cdHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG5cdFx0PyB3aW5kb3dcblx0XHQ6IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJ1xuXHRcdD8gZ2xvYmFsVGhpc1xuXHRcdDogLy8gQHRzLWlnbm9yZSBOb2RlIHR5cGluZ3MgaGF2ZSB0aGlzXG5cdFx0ICBnbG9iYWw7XG4iLCAiaW1wb3J0IHsgZ2xvYmFscyB9IGZyb20gJy4vZ2xvYmFscy5qcyc7XG5cbi8qKlxuICogUmVzaXplIG9ic2VydmVyIHNpbmdsZXRvbi5cbiAqIE9uZSBsaXN0ZW5lciBwZXIgZWxlbWVudCBvbmx5IVxuICogaHR0cHM6Ly9ncm91cHMuZ29vZ2xlLmNvbS9hL2Nocm9taXVtLm9yZy9nL2JsaW5rLWRldi9jL3o2aWVuT05VYjVBL20vRjUtVmNVWnRCQUFKXG4gKi9cbmV4cG9ydCBjbGFzcyBSZXNpemVPYnNlcnZlclNpbmdsZXRvbiB7XG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcmVhZG9ubHlcblx0ICogQHR5cGUge1dlYWtNYXA8RWxlbWVudCwgaW1wb3J0KCcuL3ByaXZhdGUuanMnKS5MaXN0ZW5lcj59XG5cdCAqL1xuXHRfbGlzdGVuZXJzID0gJ1dlYWtNYXAnIGluIGdsb2JhbHMgPyBuZXcgV2Vha01hcCgpIDogdW5kZWZpbmVkO1xuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAdHlwZSB7UmVzaXplT2JzZXJ2ZXJ9XG5cdCAqL1xuXHRfb2JzZXJ2ZXIgPSB1bmRlZmluZWQ7XG5cblx0LyoqIEB0eXBlIHtSZXNpemVPYnNlcnZlck9wdGlvbnN9ICovXG5cdG9wdGlvbnM7XG5cblx0LyoqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJPcHRpb25zfSBvcHRpb25zICovXG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuXHQgKiBAcGFyYW0ge2ltcG9ydCgnLi9wcml2YXRlLmpzJykuTGlzdGVuZXJ9IGxpc3RlbmVyXG5cdCAqIEByZXR1cm5zIHsoKSA9PiB2b2lkfVxuXHQgKi9cblx0b2JzZXJ2ZShlbGVtZW50LCBsaXN0ZW5lcikge1xuXHRcdHRoaXMuX2xpc3RlbmVycy5zZXQoZWxlbWVudCwgbGlzdGVuZXIpO1xuXHRcdHRoaXMuX2dldE9ic2VydmVyKCkub2JzZXJ2ZShlbGVtZW50LCB0aGlzLm9wdGlvbnMpO1xuXHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHR0aGlzLl9saXN0ZW5lcnMuZGVsZXRlKGVsZW1lbnQpO1xuXHRcdFx0dGhpcy5fb2JzZXJ2ZXIudW5vYnNlcnZlKGVsZW1lbnQpOyAvLyB0aGlzIGxpbmUgY2FuIHByb2JhYmx5IGJlIHJlbW92ZWRcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZ2V0T2JzZXJ2ZXIoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdHRoaXMuX29ic2VydmVyID8/XG5cdFx0XHQodGhpcy5fb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKGVudHJpZXMpID0+IHtcblx0XHRcdFx0Zm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG5cdFx0XHRcdFx0UmVzaXplT2JzZXJ2ZXJTaW5nbGV0b24uZW50cmllcy5zZXQoZW50cnkudGFyZ2V0LCBlbnRyeSk7XG5cdFx0XHRcdFx0dGhpcy5fbGlzdGVuZXJzLmdldChlbnRyeS50YXJnZXQpPy4oZW50cnkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KSlcblx0XHQpO1xuXHR9XG59XG5cbi8vIE5lZWRzIHRvIGJlIHdyaXR0ZW4gbGlrZSB0aGlzIHRvIHBhc3MgdGhlIHRyZWUtc2hha2UtdGVzdFxuUmVzaXplT2JzZXJ2ZXJTaW5nbGV0b24uZW50cmllcyA9ICdXZWFrTWFwJyBpbiBnbG9iYWxzID8gbmV3IFdlYWtNYXAoKSA6IHVuZGVmaW5lZDtcbiIsICJpbXBvcnQgeyBjb250ZW50ZWRpdGFibGVfdHJ1dGh5X3ZhbHVlcywgaGFzX3Byb3AgfSBmcm9tICcuL3V0aWxzLmpzJztcblxuaW1wb3J0IHsgUmVzaXplT2JzZXJ2ZXJTaW5nbGV0b24gfSBmcm9tICcuL1Jlc2l6ZU9ic2VydmVyU2luZ2xldG9uLmpzJztcblxuLy8gVHJhY2sgd2hpY2ggbm9kZXMgYXJlIGNsYWltZWQgZHVyaW5nIGh5ZHJhdGlvbi4gVW5jbGFpbWVkIG5vZGVzIGNhbiB0aGVuIGJlIHJlbW92ZWQgZnJvbSB0aGUgRE9NXG4vLyBhdCB0aGUgZW5kIG9mIGh5ZHJhdGlvbiB3aXRob3V0IHRvdWNoaW5nIHRoZSByZW1haW5pbmcgbm9kZXMuXG5sZXQgaXNfaHlkcmF0aW5nID0gZmFsc2U7XG5cbi8qKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGFydF9oeWRyYXRpbmcoKSB7XG5cdGlzX2h5ZHJhdGluZyA9IHRydWU7XG59XG5cbi8qKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmRfaHlkcmF0aW5nKCkge1xuXHRpc19oeWRyYXRpbmcgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gbG93XG4gKiBAcGFyYW0ge251bWJlcn0gaGlnaFxuICogQHBhcmFtIHsoaW5kZXg6IG51bWJlcikgPT4gbnVtYmVyfSBrZXlcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gdXBwZXJfYm91bmQobG93LCBoaWdoLCBrZXksIHZhbHVlKSB7XG5cdC8vIFJldHVybiBmaXJzdCBpbmRleCBvZiB2YWx1ZSBsYXJnZXIgdGhhbiBpbnB1dCB2YWx1ZSBpbiB0aGUgcmFuZ2UgW2xvdywgaGlnaClcblx0d2hpbGUgKGxvdyA8IGhpZ2gpIHtcblx0XHRjb25zdCBtaWQgPSBsb3cgKyAoKGhpZ2ggLSBsb3cpID4+IDEpO1xuXHRcdGlmIChrZXkobWlkKSA8PSB2YWx1ZSkge1xuXHRcdFx0bG93ID0gbWlkICsgMTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aGlnaCA9IG1pZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGxvdztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGVFeH0gdGFyZ2V0XG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gaW5pdF9oeWRyYXRlKHRhcmdldCkge1xuXHRpZiAodGFyZ2V0Lmh5ZHJhdGVfaW5pdCkgcmV0dXJuO1xuXHR0YXJnZXQuaHlkcmF0ZV9pbml0ID0gdHJ1ZTtcblx0Ly8gV2Uga25vdyB0aGF0IGFsbCBjaGlsZHJlbiBoYXZlIGNsYWltX29yZGVyIHZhbHVlcyBzaW5jZSB0aGUgdW5jbGFpbWVkIGhhdmUgYmVlbiBkZXRhY2hlZCBpZiB0YXJnZXQgaXMgbm90IDxoZWFkPlxuXG5cdGxldCBjaGlsZHJlbiA9IC8qKiBAdHlwZSB7QXJyYXlMaWtlPE5vZGVFeDI+fSAqLyAodGFyZ2V0LmNoaWxkTm9kZXMpO1xuXHQvLyBJZiB0YXJnZXQgaXMgPGhlYWQ+LCB0aGVyZSBtYXkgYmUgY2hpbGRyZW4gd2l0aG91dCBjbGFpbV9vcmRlclxuXHRpZiAodGFyZ2V0Lm5vZGVOYW1lID09PSAnSEVBRCcpIHtcblx0XHRjb25zdCBteV9jaGlsZHJlbiA9IFtdO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IG5vZGUgPSBjaGlsZHJlbltpXTtcblx0XHRcdGlmIChub2RlLmNsYWltX29yZGVyICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0bXlfY2hpbGRyZW4ucHVzaChub2RlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Y2hpbGRyZW4gPSBteV9jaGlsZHJlbjtcblx0fVxuXHQvKlxuXHQgKiBSZW9yZGVyIGNsYWltZWQgY2hpbGRyZW4gb3B0aW1hbGx5LlxuXHQgKiBXZSBjYW4gcmVvcmRlciBjbGFpbWVkIGNoaWxkcmVuIG9wdGltYWxseSBieSBmaW5kaW5nIHRoZSBsb25nZXN0IHN1YnNlcXVlbmNlIG9mXG5cdCAqIG5vZGVzIHRoYXQgYXJlIGFscmVhZHkgY2xhaW1lZCBpbiBvcmRlciBhbmQgb25seSBtb3ZpbmcgdGhlIHJlc3QuIFRoZSBsb25nZXN0XG5cdCAqIHN1YnNlcXVlbmNlIG9mIG5vZGVzIHRoYXQgYXJlIGNsYWltZWQgaW4gb3JkZXIgY2FuIGJlIGZvdW5kIGJ5XG5cdCAqIGNvbXB1dGluZyB0aGUgbG9uZ2VzdCBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlIG9mIC5jbGFpbV9vcmRlciB2YWx1ZXMuXG5cdCAqXG5cdCAqIFRoaXMgYWxnb3JpdGhtIGlzIG9wdGltYWwgaW4gZ2VuZXJhdGluZyB0aGUgbGVhc3QgYW1vdW50IG9mIHJlb3JkZXIgb3BlcmF0aW9uc1xuXHQgKiBwb3NzaWJsZS5cblx0ICpcblx0ICogUHJvb2Y6XG5cdCAqIFdlIGtub3cgdGhhdCwgZ2l2ZW4gYSBzZXQgb2YgcmVvcmRlcmluZyBvcGVyYXRpb25zLCB0aGUgbm9kZXMgdGhhdCBkbyBub3QgbW92ZVxuXHQgKiBhbHdheXMgZm9ybSBhbiBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlLCBzaW5jZSB0aGV5IGRvIG5vdCBtb3ZlIGFtb25nIGVhY2ggb3RoZXJcblx0ICogbWVhbmluZyB0aGF0IHRoZXkgbXVzdCBiZSBhbHJlYWR5IG9yZGVyZWQgYW1vbmcgZWFjaCBvdGhlci4gVGh1cywgdGhlIG1heGltYWxcblx0ICogc2V0IG9mIG5vZGVzIHRoYXQgZG8gbm90IG1vdmUgZm9ybSBhIGxvbmdlc3QgaW5jcmVhc2luZyBzdWJzZXF1ZW5jZS5cblx0ICovXG5cdC8vIENvbXB1dGUgbG9uZ2VzdCBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlXG5cdC8vIG06IHN1YnNlcXVlbmNlIGxlbmd0aCBqID0+IGluZGV4IGsgb2Ygc21hbGxlc3QgdmFsdWUgdGhhdCBlbmRzIGFuIGluY3JlYXNpbmcgc3Vic2VxdWVuY2Ugb2YgbGVuZ3RoIGpcblx0Y29uc3QgbSA9IG5ldyBJbnQzMkFycmF5KGNoaWxkcmVuLmxlbmd0aCArIDEpO1xuXHQvLyBQcmVkZWNlc3NvciBpbmRpY2VzICsgMVxuXHRjb25zdCBwID0gbmV3IEludDMyQXJyYXkoY2hpbGRyZW4ubGVuZ3RoKTtcblx0bVswXSA9IC0xO1xuXHRsZXQgbG9uZ2VzdCA9IDA7XG5cdGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRjb25zdCBjdXJyZW50ID0gY2hpbGRyZW5baV0uY2xhaW1fb3JkZXI7XG5cdFx0Ly8gRmluZCB0aGUgbGFyZ2VzdCBzdWJzZXF1ZW5jZSBsZW5ndGggc3VjaCB0aGF0IGl0IGVuZHMgaW4gYSB2YWx1ZSBsZXNzIHRoYW4gb3VyIGN1cnJlbnQgdmFsdWVcblx0XHQvLyB1cHBlcl9ib3VuZCByZXR1cm5zIGZpcnN0IGdyZWF0ZXIgdmFsdWUsIHNvIHdlIHN1YnRyYWN0IG9uZVxuXHRcdC8vIHdpdGggZmFzdCBwYXRoIGZvciB3aGVuIHdlIGFyZSBvbiB0aGUgY3VycmVudCBsb25nZXN0IHN1YnNlcXVlbmNlXG5cdFx0Y29uc3Qgc2VxX2xlbiA9XG5cdFx0XHQobG9uZ2VzdCA+IDAgJiYgY2hpbGRyZW5bbVtsb25nZXN0XV0uY2xhaW1fb3JkZXIgPD0gY3VycmVudFxuXHRcdFx0XHQ/IGxvbmdlc3QgKyAxXG5cdFx0XHRcdDogdXBwZXJfYm91bmQoMSwgbG9uZ2VzdCwgKGlkeCkgPT4gY2hpbGRyZW5bbVtpZHhdXS5jbGFpbV9vcmRlciwgY3VycmVudCkpIC0gMTtcblx0XHRwW2ldID0gbVtzZXFfbGVuXSArIDE7XG5cdFx0Y29uc3QgbmV3X2xlbiA9IHNlcV9sZW4gKyAxO1xuXHRcdC8vIFdlIGNhbiBndWFyYW50ZWUgdGhhdCBjdXJyZW50IGlzIHRoZSBzbWFsbGVzdCB2YWx1ZS4gT3RoZXJ3aXNlLCB3ZSB3b3VsZCBoYXZlIGdlbmVyYXRlZCBhIGxvbmdlciBzZXF1ZW5jZS5cblx0XHRtW25ld19sZW5dID0gaTtcblx0XHRsb25nZXN0ID0gTWF0aC5tYXgobmV3X2xlbiwgbG9uZ2VzdCk7XG5cdH1cblx0Ly8gVGhlIGxvbmdlc3QgaW5jcmVhc2luZyBzdWJzZXF1ZW5jZSBvZiBub2RlcyAoaW5pdGlhbGx5IHJldmVyc2VkKVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7Tm9kZUV4MltdfVxuXHQgKi9cblx0Y29uc3QgbGlzID0gW107XG5cdC8vIFRoZSByZXN0IG9mIHRoZSBub2Rlcywgbm9kZXMgdGhhdCB3aWxsIGJlIG1vdmVkXG5cblx0LyoqXG5cdCAqIEB0eXBlIHtOb2RlRXgyW119XG5cdCAqL1xuXHRjb25zdCB0b19tb3ZlID0gW107XG5cdGxldCBsYXN0ID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTtcblx0Zm9yIChsZXQgY3VyID0gbVtsb25nZXN0XSArIDE7IGN1ciAhPSAwOyBjdXIgPSBwW2N1ciAtIDFdKSB7XG5cdFx0bGlzLnB1c2goY2hpbGRyZW5bY3VyIC0gMV0pO1xuXHRcdGZvciAoOyBsYXN0ID49IGN1cjsgbGFzdC0tKSB7XG5cdFx0XHR0b19tb3ZlLnB1c2goY2hpbGRyZW5bbGFzdF0pO1xuXHRcdH1cblx0XHRsYXN0LS07XG5cdH1cblx0Zm9yICg7IGxhc3QgPj0gMDsgbGFzdC0tKSB7XG5cdFx0dG9fbW92ZS5wdXNoKGNoaWxkcmVuW2xhc3RdKTtcblx0fVxuXHRsaXMucmV2ZXJzZSgpO1xuXHQvLyBXZSBzb3J0IHRoZSBub2RlcyBiZWluZyBtb3ZlZCB0byBndWFyYW50ZWUgdGhhdCB0aGVpciBpbnNlcnRpb24gb3JkZXIgbWF0Y2hlcyB0aGUgY2xhaW0gb3JkZXJcblx0dG9fbW92ZS5zb3J0KChhLCBiKSA9PiBhLmNsYWltX29yZGVyIC0gYi5jbGFpbV9vcmRlcik7XG5cdC8vIEZpbmFsbHksIHdlIG1vdmUgdGhlIG5vZGVzXG5cdGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IHRvX21vdmUubGVuZ3RoOyBpKyspIHtcblx0XHR3aGlsZSAoaiA8IGxpcy5sZW5ndGggJiYgdG9fbW92ZVtpXS5jbGFpbV9vcmRlciA+PSBsaXNbal0uY2xhaW1fb3JkZXIpIHtcblx0XHRcdGorKztcblx0XHR9XG5cdFx0Y29uc3QgYW5jaG9yID0gaiA8IGxpcy5sZW5ndGggPyBsaXNbal0gOiBudWxsO1xuXHRcdHRhcmdldC5pbnNlcnRCZWZvcmUodG9fbW92ZVtpXSwgYW5jaG9yKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0XG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kKHRhcmdldCwgbm9kZSkge1xuXHR0YXJnZXQuYXBwZW5kQ2hpbGQobm9kZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZV9zaGVldF9pZFxuICogQHBhcmFtIHtzdHJpbmd9IHN0eWxlc1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRfc3R5bGVzKHRhcmdldCwgc3R5bGVfc2hlZXRfaWQsIHN0eWxlcykge1xuXHRjb25zdCBhcHBlbmRfc3R5bGVzX3RvID0gZ2V0X3Jvb3RfZm9yX3N0eWxlKHRhcmdldCk7XG5cdGlmICghYXBwZW5kX3N0eWxlc190by5nZXRFbGVtZW50QnlJZChzdHlsZV9zaGVldF9pZCkpIHtcblx0XHRjb25zdCBzdHlsZSA9IGVsZW1lbnQoJ3N0eWxlJyk7XG5cdFx0c3R5bGUuaWQgPSBzdHlsZV9zaGVldF9pZDtcblx0XHRzdHlsZS50ZXh0Q29udGVudCA9IHN0eWxlcztcblx0XHRhcHBlbmRfc3R5bGVzaGVldChhcHBlbmRfc3R5bGVzX3RvLCBzdHlsZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEByZXR1cm5zIHtTaGFkb3dSb290IHwgRG9jdW1lbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRfcm9vdF9mb3Jfc3R5bGUobm9kZSkge1xuXHRpZiAoIW5vZGUpIHJldHVybiBkb2N1bWVudDtcblx0Y29uc3Qgcm9vdCA9IG5vZGUuZ2V0Um9vdE5vZGUgPyBub2RlLmdldFJvb3ROb2RlKCkgOiBub2RlLm93bmVyRG9jdW1lbnQ7XG5cdGlmIChyb290ICYmIC8qKiBAdHlwZSB7U2hhZG93Um9vdH0gKi8gKHJvb3QpLmhvc3QpIHtcblx0XHRyZXR1cm4gLyoqIEB0eXBlIHtTaGFkb3dSb290fSAqLyAocm9vdCk7XG5cdH1cblx0cmV0dXJuIG5vZGUub3duZXJEb2N1bWVudDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEByZXR1cm5zIHtDU1NTdHlsZVNoZWV0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kX2VtcHR5X3N0eWxlc2hlZXQobm9kZSkge1xuXHRjb25zdCBzdHlsZV9lbGVtZW50ID0gZWxlbWVudCgnc3R5bGUnKTtcblx0Ly8gRm9yIHRyYW5zaXRpb25zIHRvIHdvcmsgd2l0aG91dCAnc3R5bGUtc3JjOiB1bnNhZmUtaW5saW5lJyBDb250ZW50IFNlY3VyaXR5IFBvbGljeSxcblx0Ly8gdGhlc2UgZW1wdHkgdGFncyBuZWVkIHRvIGJlIGFsbG93ZWQgd2l0aCBhIGhhc2ggYXMgYSB3b3JrYXJvdW5kIHVudGlsIHdlIG1vdmUgdG8gdGhlIFdlYiBBbmltYXRpb25zIEFQSS5cblx0Ly8gVXNpbmcgdGhlIGhhc2ggZm9yIHRoZSBlbXB0eSBzdHJpbmcgKGZvciBhbiBlbXB0eSB0YWcpIHdvcmtzIGluIGFsbCBicm93c2VycyBleGNlcHQgU2FmYXJpLlxuXHQvLyBTbyBhcyBhIHdvcmthcm91bmQgZm9yIHRoZSB3b3JrYXJvdW5kLCB3aGVuIHdlIGFwcGVuZCBlbXB0eSBzdHlsZSB0YWdzIHdlIHNldCB0aGVpciBjb250ZW50IHRvIC8qIGVtcHR5ICovLlxuXHQvLyBUaGUgaGFzaCAnc2hhMjU2LTlPbE5PMERORWVhVnpITDRSWndDTHNCSEE4V0JROHRvQnAvNEY1WFYybmM9JyB3aWxsIHRoZW4gd29yayBldmVuIGluIFNhZmFyaS5cblx0c3R5bGVfZWxlbWVudC50ZXh0Q29udGVudCA9ICcvKiBlbXB0eSAqLyc7XG5cdGFwcGVuZF9zdHlsZXNoZWV0KGdldF9yb290X2Zvcl9zdHlsZShub2RlKSwgc3R5bGVfZWxlbWVudCk7XG5cdHJldHVybiBzdHlsZV9lbGVtZW50LnNoZWV0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U2hhZG93Um9vdCB8IERvY3VtZW50fSBub2RlXG4gKiBAcGFyYW0ge0hUTUxTdHlsZUVsZW1lbnR9IHN0eWxlXG4gKiBAcmV0dXJucyB7Q1NTU3R5bGVTaGVldH1cbiAqL1xuZnVuY3Rpb24gYXBwZW5kX3N0eWxlc2hlZXQobm9kZSwgc3R5bGUpIHtcblx0YXBwZW5kKC8qKiBAdHlwZSB7RG9jdW1lbnR9ICovIChub2RlKS5oZWFkIHx8IG5vZGUsIHN0eWxlKTtcblx0cmV0dXJuIHN0eWxlLnNoZWV0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZUV4fSB0YXJnZXRcbiAqIEBwYXJhbSB7Tm9kZUV4fSBub2RlXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGVuZF9oeWRyYXRpb24odGFyZ2V0LCBub2RlKSB7XG5cdGlmIChpc19oeWRyYXRpbmcpIHtcblx0XHRpbml0X2h5ZHJhdGUodGFyZ2V0KTtcblx0XHRpZiAoXG5cdFx0XHR0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHQodGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQgIT09IG51bGwgJiYgdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQucGFyZW50Tm9kZSAhPT0gdGFyZ2V0KVxuXHRcdCkge1xuXHRcdFx0dGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQgPSB0YXJnZXQuZmlyc3RDaGlsZDtcblx0XHR9XG5cdFx0Ly8gU2tpcCBub2RlcyBvZiB1bmRlZmluZWQgb3JkZXJpbmdcblx0XHR3aGlsZSAodGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQgIT09IG51bGwgJiYgdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQuY2xhaW1fb3JkZXIgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQgPSB0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZC5uZXh0U2libGluZztcblx0XHR9XG5cdFx0aWYgKG5vZGUgIT09IHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkKSB7XG5cdFx0XHQvLyBXZSBvbmx5IGluc2VydCBpZiB0aGUgb3JkZXJpbmcgb2YgdGhpcyBub2RlIHNob3VsZCBiZSBtb2RpZmllZCBvciB0aGUgcGFyZW50IG5vZGUgaXMgbm90IHRhcmdldFxuXHRcdFx0aWYgKG5vZGUuY2xhaW1fb3JkZXIgIT09IHVuZGVmaW5lZCB8fCBub2RlLnBhcmVudE5vZGUgIT09IHRhcmdldCkge1xuXHRcdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKG5vZGUsIHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQgPSBub2RlLm5leHRTaWJsaW5nO1xuXHRcdH1cblx0fSBlbHNlIGlmIChub2RlLnBhcmVudE5vZGUgIT09IHRhcmdldCB8fCBub2RlLm5leHRTaWJsaW5nICE9PSBudWxsKSB7XG5cdFx0dGFyZ2V0LmFwcGVuZENoaWxkKG5vZGUpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtOb2RlfSBbYW5jaG9yXVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnNlcnQodGFyZ2V0LCBub2RlLCBhbmNob3IpIHtcblx0dGFyZ2V0Lmluc2VydEJlZm9yZShub2RlLCBhbmNob3IgfHwgbnVsbCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlRXh9IHRhcmdldFxuICogQHBhcmFtIHtOb2RlRXh9IG5vZGVcbiAqIEBwYXJhbSB7Tm9kZUV4fSBbYW5jaG9yXVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnNlcnRfaHlkcmF0aW9uKHRhcmdldCwgbm9kZSwgYW5jaG9yKSB7XG5cdGlmIChpc19oeWRyYXRpbmcgJiYgIWFuY2hvcikge1xuXHRcdGFwcGVuZF9oeWRyYXRpb24odGFyZ2V0LCBub2RlKTtcblx0fSBlbHNlIGlmIChub2RlLnBhcmVudE5vZGUgIT09IHRhcmdldCB8fCBub2RlLm5leHRTaWJsaW5nICE9IGFuY2hvcikge1xuXHRcdHRhcmdldC5pbnNlcnRCZWZvcmUobm9kZSwgYW5jaG9yIHx8IG51bGwpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRldGFjaChub2RlKSB7XG5cdGlmIChub2RlLnBhcmVudE5vZGUpIHtcblx0XHRub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXN0cm95X2VhY2goaXRlcmF0aW9ucywgZGV0YWNoaW5nKSB7XG5cdGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcmF0aW9ucy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdGlmIChpdGVyYXRpb25zW2ldKSBpdGVyYXRpb25zW2ldLmQoZGV0YWNoaW5nKTtcblx0fVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7a2V5b2YgSFRNTEVsZW1lbnRUYWdOYW1lTWFwfSBLXG4gKiBAcGFyYW0ge0t9IG5hbWVcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudFRhZ05hbWVNYXBbS119XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbGVtZW50KG5hbWUpIHtcblx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobmFtZSk7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIHtrZXlvZiBIVE1MRWxlbWVudFRhZ05hbWVNYXB9IEtcbiAqIEBwYXJhbSB7S30gbmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IGlzXG4gKiBAcmV0dXJucyB7SFRNTEVsZW1lbnRUYWdOYW1lTWFwW0tdfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWxlbWVudF9pcyhuYW1lLCBpcykge1xuXHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lLCB7IGlzIH0pO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAdGVtcGxhdGUge2tleW9mIFR9IEtcbiAqIEBwYXJhbSB7VH0gb2JqXG4gKiBAcGFyYW0ge0tbXX0gZXhjbHVkZVxuICogQHJldHVybnMge1BpY2s8VCwgRXhjbHVkZTxrZXlvZiBULCBLPj59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzKG9iaiwgZXhjbHVkZSkge1xuXHRjb25zdCB0YXJnZXQgPSAvKiogQHR5cGUge1BpY2s8VCwgRXhjbHVkZTxrZXlvZiBULCBLPj59ICovICh7fSk7XG5cdGZvciAoY29uc3QgayBpbiBvYmopIHtcblx0XHRpZiAoXG5cdFx0XHRoYXNfcHJvcChvYmosIGspICYmXG5cdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRleGNsdWRlLmluZGV4T2YoaykgPT09IC0xXG5cdFx0KSB7XG5cdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHR0YXJnZXRba10gPSBvYmpba107XG5cdFx0fVxuXHR9XG5cdHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIHtrZXlvZiBTVkdFbGVtZW50VGFnTmFtZU1hcH0gS1xuICogQHBhcmFtIHtLfSBuYW1lXG4gKiBAcmV0dXJucyB7U1ZHRWxlbWVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN2Z19lbGVtZW50KG5hbWUpIHtcblx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCBuYW1lKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YVxuICogQHJldHVybnMge1RleHR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0ZXh0KGRhdGEpIHtcblx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGRhdGEpO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHtUZXh0fSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNwYWNlKCkge1xuXHRyZXR1cm4gdGV4dCgnICcpO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHtUZXh0fSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVtcHR5KCkge1xuXHRyZXR1cm4gdGV4dCgnJyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRcbiAqIEByZXR1cm5zIHtDb21tZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tbWVudChjb250ZW50KSB7XG5cdHJldHVybiBkb2N1bWVudC5jcmVhdGVDb21tZW50KGNvbnRlbnQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtFdmVudExpc3RlbmVyT3JFdmVudExpc3RlbmVyT2JqZWN0fSBoYW5kbGVyXG4gKiBAcGFyYW0ge2Jvb2xlYW4gfCBBZGRFdmVudExpc3RlbmVyT3B0aW9ucyB8IEV2ZW50TGlzdGVuZXJPcHRpb25zfSBbb3B0aW9uc11cbiAqIEByZXR1cm5zIHsoKSA9PiB2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gbGlzdGVuKG5vZGUsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKSB7XG5cdG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG5cdHJldHVybiAoKSA9PiBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHsoZXZlbnQ6IGFueSkgPT4gYW55fSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByZXZlbnRfZGVmYXVsdChmbikge1xuXHRyZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0cmV0dXJuIGZuLmNhbGwodGhpcywgZXZlbnQpO1xuXHR9O1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHsoZXZlbnQ6IGFueSkgPT4gYW55fSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0b3BfcHJvcGFnYXRpb24oZm4pIHtcblx0cmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuXHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRyZXR1cm4gZm4uY2FsbCh0aGlzLCBldmVudCk7XG5cdH07XG59XG5cbi8qKlxuICogQHJldHVybnMgeyhldmVudDogYW55KSA9PiBhbnl9ICovXG5leHBvcnQgZnVuY3Rpb24gc3RvcF9pbW1lZGlhdGVfcHJvcGFnYXRpb24oZm4pIHtcblx0cmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuXHRcdGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRyZXR1cm4gZm4uY2FsbCh0aGlzLCBldmVudCk7XG5cdH07XG59XG5cbi8qKlxuICogQHJldHVybnMgeyhldmVudDogYW55KSA9PiB2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlbGYoZm4pIHtcblx0cmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzKSBmbi5jYWxsKHRoaXMsIGV2ZW50KTtcblx0fTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7KGV2ZW50OiBhbnkpID0+IHZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gdHJ1c3RlZChmbikge1xuXHRyZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdGlmIChldmVudC5pc1RydXN0ZWQpIGZuLmNhbGwodGhpcywgZXZlbnQpO1xuXHR9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogQHBhcmFtIHtzdHJpbmd9IFt2YWx1ZV1cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXR0cihub2RlLCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG5cdGlmICh2YWx1ZSA9PSBudWxsKSBub2RlLnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuXHRlbHNlIGlmIChub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpICE9PSB2YWx1ZSkgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlLCB2YWx1ZSk7XG59XG4vKipcbiAqIExpc3Qgb2YgYXR0cmlidXRlcyB0aGF0IHNob3VsZCBhbHdheXMgYmUgc2V0IHRocm91Z2ggdGhlIGF0dHIgbWV0aG9kLFxuICogYmVjYXVzZSB1cGRhdGluZyB0aGVtIHRocm91Z2ggdGhlIHByb3BlcnR5IHNldHRlciBkb2Vzbid0IHdvcmsgcmVsaWFibHkuXG4gKiBJbiB0aGUgZXhhbXBsZSBvZiBgd2lkdGhgL2BoZWlnaHRgLCB0aGUgcHJvYmxlbSBpcyB0aGF0IHRoZSBzZXR0ZXIgb25seVxuICogYWNjZXB0cyBudW1lcmljIHZhbHVlcywgYnV0IHRoZSBhdHRyaWJ1dGUgY2FuIGFsc28gYmUgc2V0IHRvIGEgc3RyaW5nIGxpa2UgYDUwJWAuXG4gKiBJZiB0aGlzIGxpc3QgYmVjb21lcyB0b28gYmlnLCByZXRoaW5rIHRoaXMgYXBwcm9hY2guXG4gKi9cbmNvbnN0IGFsd2F5c19zZXRfdGhyb3VnaF9zZXRfYXR0cmlidXRlID0gWyd3aWR0aCcsICdoZWlnaHQnXTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnQgJiBFbGVtZW50Q1NTSW5saW5lU3R5bGV9IG5vZGVcbiAqIEBwYXJhbSB7eyBbeDogc3RyaW5nXTogc3RyaW5nIH19IGF0dHJpYnV0ZXNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2F0dHJpYnV0ZXMobm9kZSwgYXR0cmlidXRlcykge1xuXHQvLyBAdHMtaWdub3JlXG5cdGNvbnN0IGRlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMobm9kZS5fX3Byb3RvX18pO1xuXHRmb3IgKGNvbnN0IGtleSBpbiBhdHRyaWJ1dGVzKSB7XG5cdFx0aWYgKGF0dHJpYnV0ZXNba2V5XSA9PSBudWxsKSB7XG5cdFx0XHRub2RlLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuXHRcdH0gZWxzZSBpZiAoa2V5ID09PSAnc3R5bGUnKSB7XG5cdFx0XHRub2RlLnN0eWxlLmNzc1RleHQgPSBhdHRyaWJ1dGVzW2tleV07XG5cdFx0fSBlbHNlIGlmIChrZXkgPT09ICdfX3ZhbHVlJykge1xuXHRcdFx0LyoqIEB0eXBlIHthbnl9ICovIChub2RlKS52YWx1ZSA9IG5vZGVba2V5XSA9IGF0dHJpYnV0ZXNba2V5XTtcblx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0ZGVzY3JpcHRvcnNba2V5XSAmJlxuXHRcdFx0ZGVzY3JpcHRvcnNba2V5XS5zZXQgJiZcblx0XHRcdGFsd2F5c19zZXRfdGhyb3VnaF9zZXRfYXR0cmlidXRlLmluZGV4T2Yoa2V5KSA9PT0gLTFcblx0XHQpIHtcblx0XHRcdG5vZGVba2V5XSA9IGF0dHJpYnV0ZXNba2V5XTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0YXR0cihub2RlLCBrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50ICYgRWxlbWVudENTU0lubGluZVN0eWxlfSBub2RlXG4gKiBAcGFyYW0ge3sgW3g6IHN0cmluZ106IHN0cmluZyB9fSBhdHRyaWJ1dGVzXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9zdmdfYXR0cmlidXRlcyhub2RlLCBhdHRyaWJ1dGVzKSB7XG5cdGZvciAoY29uc3Qga2V5IGluIGF0dHJpYnV0ZXMpIHtcblx0XHRhdHRyKG5vZGUsIGtleSwgYXR0cmlidXRlc1trZXldKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59IGRhdGFfbWFwXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9jdXN0b21fZWxlbWVudF9kYXRhX21hcChub2RlLCBkYXRhX21hcCkge1xuXHRPYmplY3Qua2V5cyhkYXRhX21hcCkuZm9yRWFjaCgoa2V5KSA9PiB7XG5cdFx0c2V0X2N1c3RvbV9lbGVtZW50X2RhdGEobm9kZSwga2V5LCBkYXRhX21hcFtrZXldKTtcblx0fSk7XG59XG5cbi8qKlxuICogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2N1c3RvbV9lbGVtZW50X2RhdGEobm9kZSwgcHJvcCwgdmFsdWUpIHtcblx0Y29uc3QgbG93ZXIgPSBwcm9wLnRvTG93ZXJDYXNlKCk7IC8vIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIGV4aXN0aW5nIGJlaGF2aW9yIHdlIGRvIGxvd2VyY2FzZSBmaXJzdFxuXHRpZiAobG93ZXIgaW4gbm9kZSkge1xuXHRcdG5vZGVbbG93ZXJdID0gdHlwZW9mIG5vZGVbbG93ZXJdID09PSAnYm9vbGVhbicgJiYgdmFsdWUgPT09ICcnID8gdHJ1ZSA6IHZhbHVlO1xuXHR9IGVsc2UgaWYgKHByb3AgaW4gbm9kZSkge1xuXHRcdG5vZGVbcHJvcF0gPSB0eXBlb2Ygbm9kZVtwcm9wXSA9PT0gJ2Jvb2xlYW4nICYmIHZhbHVlID09PSAnJyA/IHRydWUgOiB2YWx1ZTtcblx0fSBlbHNlIHtcblx0XHRhdHRyKG5vZGUsIHByb3AsIHZhbHVlKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9keW5hbWljX2VsZW1lbnRfZGF0YSh0YWcpIHtcblx0cmV0dXJuIC8tLy50ZXN0KHRhZykgPyBzZXRfY3VzdG9tX2VsZW1lbnRfZGF0YV9tYXAgOiBzZXRfYXR0cmlidXRlcztcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHhsaW5rX2F0dHIobm9kZSwgYXR0cmlidXRlLCB2YWx1ZSkge1xuXHRub2RlLnNldEF0dHJpYnV0ZU5TKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywgYXR0cmlidXRlLCB2YWx1ZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldF9zdmVsdGVfZGF0YXNldChub2RlKSB7XG5cdHJldHVybiBub2RlLmRhdGFzZXQuc3ZlbHRlSDtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7dW5rbm93bltdfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldF9iaW5kaW5nX2dyb3VwX3ZhbHVlKGdyb3VwLCBfX3ZhbHVlLCBjaGVja2VkKSB7XG5cdGNvbnN0IHZhbHVlID0gbmV3IFNldCgpO1xuXHRmb3IgKGxldCBpID0gMDsgaSA8IGdyb3VwLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0aWYgKGdyb3VwW2ldLmNoZWNrZWQpIHZhbHVlLmFkZChncm91cFtpXS5fX3ZhbHVlKTtcblx0fVxuXHRpZiAoIWNoZWNrZWQpIHtcblx0XHR2YWx1ZS5kZWxldGUoX192YWx1ZSk7XG5cdH1cblx0cmV0dXJuIEFycmF5LmZyb20odmFsdWUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudFtdfSBncm91cFxuICogQHJldHVybnMge3sgcCguLi5pbnB1dHM6IEhUTUxJbnB1dEVsZW1lbnRbXSk6IHZvaWQ7IHIoKTogdm9pZDsgfX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluaXRfYmluZGluZ19ncm91cChncm91cCkge1xuXHQvKipcblx0ICogQHR5cGUge0hUTUxJbnB1dEVsZW1lbnRbXX0gKi9cblx0bGV0IF9pbnB1dHM7XG5cdHJldHVybiB7XG5cdFx0LyogcHVzaCAqLyBwKC4uLmlucHV0cykge1xuXHRcdFx0X2lucHV0cyA9IGlucHV0cztcblx0XHRcdF9pbnB1dHMuZm9yRWFjaCgoaW5wdXQpID0+IGdyb3VwLnB1c2goaW5wdXQpKTtcblx0XHR9LFxuXHRcdC8qIHJlbW92ZSAqLyByKCkge1xuXHRcdFx0X2lucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4gZ3JvdXAuc3BsaWNlKGdyb3VwLmluZGV4T2YoaW5wdXQpLCAxKSk7XG5cdFx0fVxuXHR9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyW119IGluZGV4ZXNcbiAqIEByZXR1cm5zIHt7IHUobmV3X2luZGV4ZXM6IG51bWJlcltdKTogdm9pZDsgcCguLi5pbnB1dHM6IEhUTUxJbnB1dEVsZW1lbnRbXSk6IHZvaWQ7IHI6ICgpID0+IHZvaWQ7IH19XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbml0X2JpbmRpbmdfZ3JvdXBfZHluYW1pYyhncm91cCwgaW5kZXhlcykge1xuXHQvKipcblx0ICogQHR5cGUge0hUTUxJbnB1dEVsZW1lbnRbXX0gKi9cblx0bGV0IF9ncm91cCA9IGdldF9iaW5kaW5nX2dyb3VwKGdyb3VwKTtcblxuXHQvKipcblx0ICogQHR5cGUge0hUTUxJbnB1dEVsZW1lbnRbXX0gKi9cblx0bGV0IF9pbnB1dHM7XG5cblx0ZnVuY3Rpb24gZ2V0X2JpbmRpbmdfZ3JvdXAoZ3JvdXApIHtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGluZGV4ZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGdyb3VwID0gZ3JvdXBbaW5kZXhlc1tpXV0gPSBncm91cFtpbmRleGVzW2ldXSB8fCBbXTtcblx0XHR9XG5cdFx0cmV0dXJuIGdyb3VwO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHt2b2lkfSAqL1xuXHRmdW5jdGlvbiBwdXNoKCkge1xuXHRcdF9pbnB1dHMuZm9yRWFjaCgoaW5wdXQpID0+IF9ncm91cC5wdXNoKGlucHV0KSk7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge3ZvaWR9ICovXG5cdGZ1bmN0aW9uIHJlbW92ZSgpIHtcblx0XHRfaW5wdXRzLmZvckVhY2goKGlucHV0KSA9PiBfZ3JvdXAuc3BsaWNlKF9ncm91cC5pbmRleE9mKGlucHV0KSwgMSkpO1xuXHR9XG5cdHJldHVybiB7XG5cdFx0LyogdXBkYXRlICovIHUobmV3X2luZGV4ZXMpIHtcblx0XHRcdGluZGV4ZXMgPSBuZXdfaW5kZXhlcztcblx0XHRcdGNvbnN0IG5ld19ncm91cCA9IGdldF9iaW5kaW5nX2dyb3VwKGdyb3VwKTtcblx0XHRcdGlmIChuZXdfZ3JvdXAgIT09IF9ncm91cCkge1xuXHRcdFx0XHRyZW1vdmUoKTtcblx0XHRcdFx0X2dyb3VwID0gbmV3X2dyb3VwO1xuXHRcdFx0XHRwdXNoKCk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQvKiBwdXNoICovIHAoLi4uaW5wdXRzKSB7XG5cdFx0XHRfaW5wdXRzID0gaW5wdXRzO1xuXHRcdFx0cHVzaCgpO1xuXHRcdH0sXG5cdFx0LyogcmVtb3ZlICovIHI6IHJlbW92ZVxuXHR9O1xufVxuXG4vKiogQHJldHVybnMge251bWJlcn0gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b19udW1iZXIodmFsdWUpIHtcblx0cmV0dXJuIHZhbHVlID09PSAnJyA/IG51bGwgOiArdmFsdWU7XG59XG5cbi8qKiBAcmV0dXJucyB7YW55W119ICovXG5leHBvcnQgZnVuY3Rpb24gdGltZV9yYW5nZXNfdG9fYXJyYXkocmFuZ2VzKSB7XG5cdGNvbnN0IGFycmF5ID0gW107XG5cdGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0YXJyYXkucHVzaCh7IHN0YXJ0OiByYW5nZXMuc3RhcnQoaSksIGVuZDogcmFuZ2VzLmVuZChpKSB9KTtcblx0fVxuXHRyZXR1cm4gYXJyYXk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7Q2hpbGROb2RlW119XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaGlsZHJlbihlbGVtZW50KSB7XG5cdHJldHVybiBBcnJheS5mcm9tKGVsZW1lbnQuY2hpbGROb2Rlcyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtDaGlsZE5vZGVBcnJheX0gbm9kZXNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBpbml0X2NsYWltX2luZm8obm9kZXMpIHtcblx0aWYgKG5vZGVzLmNsYWltX2luZm8gPT09IHVuZGVmaW5lZCkge1xuXHRcdG5vZGVzLmNsYWltX2luZm8gPSB7IGxhc3RfaW5kZXg6IDAsIHRvdGFsX2NsYWltZWQ6IDAgfTtcblx0fVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7Q2hpbGROb2RlRXh9IFJcbiAqIEBwYXJhbSB7Q2hpbGROb2RlQXJyYXl9IG5vZGVzXG4gKiBAcGFyYW0geyhub2RlOiBDaGlsZE5vZGVFeCkgPT4gbm9kZSBpcyBSfSBwcmVkaWNhdGVcbiAqIEBwYXJhbSB7KG5vZGU6IENoaWxkTm9kZUV4KSA9PiBDaGlsZE5vZGVFeCB8IHVuZGVmaW5lZH0gcHJvY2Vzc19ub2RlXG4gKiBAcGFyYW0geygpID0+IFJ9IGNyZWF0ZV9ub2RlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGRvbnRfdXBkYXRlX2xhc3RfaW5kZXhcbiAqIEByZXR1cm5zIHtSfVxuICovXG5mdW5jdGlvbiBjbGFpbV9ub2RlKG5vZGVzLCBwcmVkaWNhdGUsIHByb2Nlc3Nfbm9kZSwgY3JlYXRlX25vZGUsIGRvbnRfdXBkYXRlX2xhc3RfaW5kZXggPSBmYWxzZSkge1xuXHQvLyBUcnkgdG8gZmluZCBub2RlcyBpbiBhbiBvcmRlciBzdWNoIHRoYXQgd2UgbGVuZ3RoZW4gdGhlIGxvbmdlc3QgaW5jcmVhc2luZyBzdWJzZXF1ZW5jZVxuXHRpbml0X2NsYWltX2luZm8obm9kZXMpO1xuXHRjb25zdCByZXN1bHRfbm9kZSA9ICgoKSA9PiB7XG5cdFx0Ly8gV2UgZmlyc3QgdHJ5IHRvIGZpbmQgYW4gZWxlbWVudCBhZnRlciB0aGUgcHJldmlvdXMgb25lXG5cdFx0Zm9yIChsZXQgaSA9IG5vZGVzLmNsYWltX2luZm8ubGFzdF9pbmRleDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCBub2RlID0gbm9kZXNbaV07XG5cdFx0XHRpZiAocHJlZGljYXRlKG5vZGUpKSB7XG5cdFx0XHRcdGNvbnN0IHJlcGxhY2VtZW50ID0gcHJvY2Vzc19ub2RlKG5vZGUpO1xuXHRcdFx0XHRpZiAocmVwbGFjZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdG5vZGVzLnNwbGljZShpLCAxKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRub2Rlc1tpXSA9IHJlcGxhY2VtZW50O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghZG9udF91cGRhdGVfbGFzdF9pbmRleCkge1xuXHRcdFx0XHRcdG5vZGVzLmNsYWltX2luZm8ubGFzdF9pbmRleCA9IGk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG5vZGU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIE90aGVyd2lzZSwgd2UgdHJ5IHRvIGZpbmQgb25lIGJlZm9yZVxuXHRcdC8vIFdlIGl0ZXJhdGUgaW4gcmV2ZXJzZSBzbyB0aGF0IHdlIGRvbid0IGdvIHRvbyBmYXIgYmFja1xuXHRcdGZvciAobGV0IGkgPSBub2Rlcy5jbGFpbV9pbmZvLmxhc3RfaW5kZXggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0Y29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuXHRcdFx0aWYgKHByZWRpY2F0ZShub2RlKSkge1xuXHRcdFx0XHRjb25zdCByZXBsYWNlbWVudCA9IHByb2Nlc3Nfbm9kZShub2RlKTtcblx0XHRcdFx0aWYgKHJlcGxhY2VtZW50ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRub2Rlcy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bm9kZXNbaV0gPSByZXBsYWNlbWVudDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIWRvbnRfdXBkYXRlX2xhc3RfaW5kZXgpIHtcblx0XHRcdFx0XHRub2Rlcy5jbGFpbV9pbmZvLmxhc3RfaW5kZXggPSBpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHJlcGxhY2VtZW50ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHQvLyBTaW5jZSB3ZSBzcGxpY2VkIGJlZm9yZSB0aGUgbGFzdF9pbmRleCwgd2UgZGVjcmVhc2UgaXRcblx0XHRcdFx0XHRub2Rlcy5jbGFpbV9pbmZvLmxhc3RfaW5kZXgtLTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbm9kZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gSWYgd2UgY2FuJ3QgZmluZCBhbnkgbWF0Y2hpbmcgbm9kZSwgd2UgY3JlYXRlIGEgbmV3IG9uZVxuXHRcdHJldHVybiBjcmVhdGVfbm9kZSgpO1xuXHR9KSgpO1xuXHRyZXN1bHRfbm9kZS5jbGFpbV9vcmRlciA9IG5vZGVzLmNsYWltX2luZm8udG90YWxfY2xhaW1lZDtcblx0bm9kZXMuY2xhaW1faW5mby50b3RhbF9jbGFpbWVkICs9IDE7XG5cdHJldHVybiByZXN1bHRfbm9kZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NoaWxkTm9kZUFycmF5fSBub2Rlc1xuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7eyBba2V5OiBzdHJpbmddOiBib29sZWFuIH19IGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7KG5hbWU6IHN0cmluZykgPT4gRWxlbWVudCB8IFNWR0VsZW1lbnR9IGNyZWF0ZV9lbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudCB8IFNWR0VsZW1lbnR9XG4gKi9cbmZ1bmN0aW9uIGNsYWltX2VsZW1lbnRfYmFzZShub2RlcywgbmFtZSwgYXR0cmlidXRlcywgY3JlYXRlX2VsZW1lbnQpIHtcblx0cmV0dXJuIGNsYWltX25vZGUoXG5cdFx0bm9kZXMsXG5cdFx0LyoqIEByZXR1cm5zIHtub2RlIGlzIEVsZW1lbnQgfCBTVkdFbGVtZW50fSAqL1xuXHRcdChub2RlKSA9PiBub2RlLm5vZGVOYW1lID09PSBuYW1lLFxuXHRcdC8qKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgKi9cblx0XHQobm9kZSkgPT4ge1xuXHRcdFx0Y29uc3QgcmVtb3ZlID0gW107XG5cdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IG5vZGUuYXR0cmlidXRlcy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBub2RlLmF0dHJpYnV0ZXNbal07XG5cdFx0XHRcdGlmICghYXR0cmlidXRlc1thdHRyaWJ1dGUubmFtZV0pIHtcblx0XHRcdFx0XHRyZW1vdmUucHVzaChhdHRyaWJ1dGUubmFtZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJlbW92ZS5mb3JFYWNoKCh2KSA9PiBub2RlLnJlbW92ZUF0dHJpYnV0ZSh2KSk7XG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdH0sXG5cdFx0KCkgPT4gY3JlYXRlX2VsZW1lbnQobmFtZSlcblx0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NoaWxkTm9kZUFycmF5fSBub2Rlc1xuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7eyBba2V5OiBzdHJpbmddOiBib29sZWFuIH19IGF0dHJpYnV0ZXNcbiAqIEByZXR1cm5zIHtFbGVtZW50IHwgU1ZHRWxlbWVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsYWltX2VsZW1lbnQobm9kZXMsIG5hbWUsIGF0dHJpYnV0ZXMpIHtcblx0cmV0dXJuIGNsYWltX2VsZW1lbnRfYmFzZShub2RlcywgbmFtZSwgYXR0cmlidXRlcywgZWxlbWVudCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtDaGlsZE5vZGVBcnJheX0gbm9kZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge3sgW2tleTogc3RyaW5nXTogYm9vbGVhbiB9fSBhdHRyaWJ1dGVzXG4gKiBAcmV0dXJucyB7RWxlbWVudCB8IFNWR0VsZW1lbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGFpbV9zdmdfZWxlbWVudChub2RlcywgbmFtZSwgYXR0cmlidXRlcykge1xuXHRyZXR1cm4gY2xhaW1fZWxlbWVudF9iYXNlKG5vZGVzLCBuYW1lLCBhdHRyaWJ1dGVzLCBzdmdfZWxlbWVudCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtDaGlsZE5vZGVBcnJheX0gbm9kZXNcbiAqIEByZXR1cm5zIHtUZXh0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xhaW1fdGV4dChub2RlcywgZGF0YSkge1xuXHRyZXR1cm4gY2xhaW1fbm9kZShcblx0XHRub2Rlcyxcblx0XHQvKiogQHJldHVybnMge25vZGUgaXMgVGV4dH0gKi9cblx0XHQobm9kZSkgPT4gbm9kZS5ub2RlVHlwZSA9PT0gMyxcblx0XHQvKiogQHBhcmFtIHtUZXh0fSBub2RlICovXG5cdFx0KG5vZGUpID0+IHtcblx0XHRcdGNvbnN0IGRhdGFfc3RyID0gJycgKyBkYXRhO1xuXHRcdFx0aWYgKG5vZGUuZGF0YS5zdGFydHNXaXRoKGRhdGFfc3RyKSkge1xuXHRcdFx0XHRpZiAobm9kZS5kYXRhLmxlbmd0aCAhPT0gZGF0YV9zdHIubGVuZ3RoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5vZGUuc3BsaXRUZXh0KGRhdGFfc3RyLmxlbmd0aCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5vZGUuZGF0YSA9IGRhdGFfc3RyO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0KCkgPT4gdGV4dChkYXRhKSxcblx0XHR0cnVlIC8vIFRleHQgbm9kZXMgc2hvdWxkIG5vdCB1cGRhdGUgbGFzdCBpbmRleCBzaW5jZSBpdCBpcyBsaWtlbHkgbm90IHdvcnRoIGl0IHRvIGVsaW1pbmF0ZSBhbiBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlIG9mIGFjdHVhbCBlbGVtZW50c1xuXHQpO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHtUZXh0fSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsYWltX3NwYWNlKG5vZGVzKSB7XG5cdHJldHVybiBjbGFpbV90ZXh0KG5vZGVzLCAnICcpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Q2hpbGROb2RlQXJyYXl9IG5vZGVzXG4gKiBAcmV0dXJucyB7Q29tbWVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsYWltX2NvbW1lbnQobm9kZXMsIGRhdGEpIHtcblx0cmV0dXJuIGNsYWltX25vZGUoXG5cdFx0bm9kZXMsXG5cdFx0LyoqIEByZXR1cm5zIHtub2RlIGlzIENvbW1lbnR9ICovXG5cdFx0KG5vZGUpID0+IG5vZGUubm9kZVR5cGUgPT09IDgsXG5cdFx0LyoqIEBwYXJhbSB7Q29tbWVudH0gbm9kZSAqL1xuXHRcdChub2RlKSA9PiB7XG5cdFx0XHRub2RlLmRhdGEgPSAnJyArIGRhdGE7XG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdH0sXG5cdFx0KCkgPT4gY29tbWVudChkYXRhKSxcblx0XHR0cnVlXG5cdCk7XG59XG5cbmZ1bmN0aW9uIGdldF9jb21tZW50X2lkeChub2RlcywgdGV4dCwgc3RhcnQpIHtcblx0Zm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgbm9kZXMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRjb25zdCBub2RlID0gbm9kZXNbaV07XG5cdFx0aWYgKG5vZGUubm9kZVR5cGUgPT09IDggLyogY29tbWVudCBub2RlICovICYmIG5vZGUudGV4dENvbnRlbnQudHJpbSgpID09PSB0ZXh0KSB7XG5cdFx0XHRyZXR1cm4gaTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNfc3ZnXG4gKiBAcmV0dXJucyB7SHRtbFRhZ0h5ZHJhdGlvbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsYWltX2h0bWxfdGFnKG5vZGVzLCBpc19zdmcpIHtcblx0Ly8gZmluZCBodG1sIG9wZW5pbmcgdGFnXG5cdGNvbnN0IHN0YXJ0X2luZGV4ID0gZ2V0X2NvbW1lbnRfaWR4KG5vZGVzLCAnSFRNTF9UQUdfU1RBUlQnLCAwKTtcblx0Y29uc3QgZW5kX2luZGV4ID0gZ2V0X2NvbW1lbnRfaWR4KG5vZGVzLCAnSFRNTF9UQUdfRU5EJywgc3RhcnRfaW5kZXggKyAxKTtcblx0aWYgKHN0YXJ0X2luZGV4ID09PSAtMSB8fCBlbmRfaW5kZXggPT09IC0xKSB7XG5cdFx0cmV0dXJuIG5ldyBIdG1sVGFnSHlkcmF0aW9uKGlzX3N2Zyk7XG5cdH1cblxuXHRpbml0X2NsYWltX2luZm8obm9kZXMpO1xuXHRjb25zdCBodG1sX3RhZ19ub2RlcyA9IG5vZGVzLnNwbGljZShzdGFydF9pbmRleCwgZW5kX2luZGV4IC0gc3RhcnRfaW5kZXggKyAxKTtcblx0ZGV0YWNoKGh0bWxfdGFnX25vZGVzWzBdKTtcblx0ZGV0YWNoKGh0bWxfdGFnX25vZGVzW2h0bWxfdGFnX25vZGVzLmxlbmd0aCAtIDFdKTtcblx0Y29uc3QgY2xhaW1lZF9ub2RlcyA9IGh0bWxfdGFnX25vZGVzLnNsaWNlKDEsIGh0bWxfdGFnX25vZGVzLmxlbmd0aCAtIDEpO1xuXHRpZiAoY2xhaW1lZF9ub2Rlcy5sZW5ndGggPT09IDApIHtcblx0XHRyZXR1cm4gbmV3IEh0bWxUYWdIeWRyYXRpb24oaXNfc3ZnKTtcblx0fVxuXHRmb3IgKGNvbnN0IG4gb2YgY2xhaW1lZF9ub2Rlcykge1xuXHRcdG4uY2xhaW1fb3JkZXIgPSBub2Rlcy5jbGFpbV9pbmZvLnRvdGFsX2NsYWltZWQ7XG5cdFx0bm9kZXMuY2xhaW1faW5mby50b3RhbF9jbGFpbWVkICs9IDE7XG5cdH1cblx0cmV0dXJuIG5ldyBIdG1sVGFnSHlkcmF0aW9uKGlzX3N2ZywgY2xhaW1lZF9ub2Rlcyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtUZXh0fSB0ZXh0XG4gKiBAcGFyYW0ge3Vua25vd259IGRhdGFcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2RhdGEodGV4dCwgZGF0YSkge1xuXHRkYXRhID0gJycgKyBkYXRhO1xuXHRpZiAodGV4dC5kYXRhID09PSBkYXRhKSByZXR1cm47XG5cdHRleHQuZGF0YSA9IC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAoZGF0YSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtUZXh0fSB0ZXh0XG4gKiBAcGFyYW0ge3Vua25vd259IGRhdGFcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2RhdGFfY29udGVudGVkaXRhYmxlKHRleHQsIGRhdGEpIHtcblx0ZGF0YSA9ICcnICsgZGF0YTtcblx0aWYgKHRleHQud2hvbGVUZXh0ID09PSBkYXRhKSByZXR1cm47XG5cdHRleHQuZGF0YSA9IC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAoZGF0YSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtUZXh0fSB0ZXh0XG4gKiBAcGFyYW0ge3Vua25vd259IGRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyX3ZhbHVlXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9kYXRhX21heWJlX2NvbnRlbnRlZGl0YWJsZSh0ZXh0LCBkYXRhLCBhdHRyX3ZhbHVlKSB7XG5cdGlmICh+Y29udGVudGVkaXRhYmxlX3RydXRoeV92YWx1ZXMuaW5kZXhPZihhdHRyX3ZhbHVlKSkge1xuXHRcdHNldF9kYXRhX2NvbnRlbnRlZGl0YWJsZSh0ZXh0LCBkYXRhKTtcblx0fSBlbHNlIHtcblx0XHRzZXRfZGF0YSh0ZXh0LCBkYXRhKTtcblx0fVxufVxuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9pbnB1dF92YWx1ZShpbnB1dCwgdmFsdWUpIHtcblx0aW5wdXQudmFsdWUgPSB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfaW5wdXRfdHlwZShpbnB1dCwgdHlwZSkge1xuXHR0cnkge1xuXHRcdGlucHV0LnR5cGUgPSB0eXBlO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0Ly8gZG8gbm90aGluZ1xuXHR9XG59XG5cbi8qKlxuICogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X3N0eWxlKG5vZGUsIGtleSwgdmFsdWUsIGltcG9ydGFudCkge1xuXHRpZiAodmFsdWUgPT0gbnVsbCkge1xuXHRcdG5vZGUuc3R5bGUucmVtb3ZlUHJvcGVydHkoa2V5KTtcblx0fSBlbHNlIHtcblx0XHRub2RlLnN0eWxlLnNldFByb3BlcnR5KGtleSwgdmFsdWUsIGltcG9ydGFudCA/ICdpbXBvcnRhbnQnIDogJycpO1xuXHR9XG59XG5cbi8qKlxuICogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gc2VsZWN0X29wdGlvbihzZWxlY3QsIHZhbHVlLCBtb3VudGluZykge1xuXHRmb3IgKGxldCBpID0gMDsgaSA8IHNlbGVjdC5vcHRpb25zLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0Y29uc3Qgb3B0aW9uID0gc2VsZWN0Lm9wdGlvbnNbaV07XG5cdFx0aWYgKG9wdGlvbi5fX3ZhbHVlID09PSB2YWx1ZSkge1xuXHRcdFx0b3B0aW9uLnNlbGVjdGVkID0gdHJ1ZTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdH1cblx0aWYgKCFtb3VudGluZyB8fCB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0c2VsZWN0LnNlbGVjdGVkSW5kZXggPSAtMTsgLy8gbm8gb3B0aW9uIHNob3VsZCBiZSBzZWxlY3RlZFxuXHR9XG59XG5cbi8qKlxuICogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gc2VsZWN0X29wdGlvbnMoc2VsZWN0LCB2YWx1ZSkge1xuXHRmb3IgKGxldCBpID0gMDsgaSA8IHNlbGVjdC5vcHRpb25zLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0Y29uc3Qgb3B0aW9uID0gc2VsZWN0Lm9wdGlvbnNbaV07XG5cdFx0b3B0aW9uLnNlbGVjdGVkID0gfnZhbHVlLmluZGV4T2Yob3B0aW9uLl9fdmFsdWUpO1xuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZWxlY3RfdmFsdWUoc2VsZWN0KSB7XG5cdGNvbnN0IHNlbGVjdGVkX29wdGlvbiA9IHNlbGVjdC5xdWVyeVNlbGVjdG9yKCc6Y2hlY2tlZCcpO1xuXHRyZXR1cm4gc2VsZWN0ZWRfb3B0aW9uICYmIHNlbGVjdGVkX29wdGlvbi5fX3ZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2VsZWN0X211bHRpcGxlX3ZhbHVlKHNlbGVjdCkge1xuXHRyZXR1cm4gW10ubWFwLmNhbGwoc2VsZWN0LnF1ZXJ5U2VsZWN0b3JBbGwoJzpjaGVja2VkJyksIChvcHRpb24pID0+IG9wdGlvbi5fX3ZhbHVlKTtcbn1cbi8vIHVuZm9ydHVuYXRlbHkgdGhpcyBjYW4ndCBiZSBhIGNvbnN0YW50IGFzIHRoYXQgd291bGRuJ3QgYmUgdHJlZS1zaGFrZWFibGVcbi8vIHNvIHdlIGNhY2hlIHRoZSByZXN1bHQgaW5zdGVhZFxuXG4vKipcbiAqIEB0eXBlIHtib29sZWFufSAqL1xubGV0IGNyb3Nzb3JpZ2luO1xuXG4vKipcbiAqIEByZXR1cm5zIHtib29sZWFufSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX2Nyb3Nzb3JpZ2luKCkge1xuXHRpZiAoY3Jvc3NvcmlnaW4gPT09IHVuZGVmaW5lZCkge1xuXHRcdGNyb3Nzb3JpZ2luID0gZmFsc2U7XG5cdFx0dHJ5IHtcblx0XHRcdGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucGFyZW50KSB7XG5cdFx0XHRcdHZvaWQgd2luZG93LnBhcmVudC5kb2N1bWVudDtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y3Jvc3NvcmlnaW4gPSB0cnVlO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gY3Jvc3NvcmlnaW47XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBmblxuICogQHJldHVybnMgeygpID0+IHZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRfaWZyYW1lX3Jlc2l6ZV9saXN0ZW5lcihub2RlLCBmbikge1xuXHRjb25zdCBjb21wdXRlZF9zdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG5cdGlmIChjb21wdXRlZF9zdHlsZS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcblx0XHRub2RlLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcblx0fVxuXHRjb25zdCBpZnJhbWUgPSBlbGVtZW50KCdpZnJhbWUnKTtcblx0aWZyYW1lLnNldEF0dHJpYnV0ZShcblx0XHQnc3R5bGUnLFxuXHRcdCdkaXNwbGF5OiBibG9jazsgcG9zaXRpb246IGFic29sdXRlOyB0b3A6IDA7IGxlZnQ6IDA7IHdpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7ICcgK1xuXHRcdFx0J292ZXJmbG93OiBoaWRkZW47IGJvcmRlcjogMDsgb3BhY2l0eTogMDsgcG9pbnRlci1ldmVudHM6IG5vbmU7IHotaW5kZXg6IC0xOydcblx0KTtcblx0aWZyYW1lLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuXHRpZnJhbWUudGFiSW5kZXggPSAtMTtcblx0Y29uc3QgY3Jvc3NvcmlnaW4gPSBpc19jcm9zc29yaWdpbigpO1xuXG5cdC8qKlxuXHQgKiBAdHlwZSB7KCkgPT4gdm9pZH1cblx0ICovXG5cdGxldCB1bnN1YnNjcmliZTtcblx0aWYgKGNyb3Nzb3JpZ2luKSB7XG5cdFx0aWZyYW1lLnNyYyA9IFwiZGF0YTp0ZXh0L2h0bWwsPHNjcmlwdD5vbnJlc2l6ZT1mdW5jdGlvbigpe3BhcmVudC5wb3N0TWVzc2FnZSgwLCcqJyl9PC9zY3JpcHQ+XCI7XG5cdFx0dW5zdWJzY3JpYmUgPSBsaXN0ZW4oXG5cdFx0XHR3aW5kb3csXG5cdFx0XHQnbWVzc2FnZScsXG5cdFx0XHQvKiogQHBhcmFtIHtNZXNzYWdlRXZlbnR9IGV2ZW50ICovIChldmVudCkgPT4ge1xuXHRcdFx0XHRpZiAoZXZlbnQuc291cmNlID09PSBpZnJhbWUuY29udGVudFdpbmRvdykgZm4oKTtcblx0XHRcdH1cblx0XHQpO1xuXHR9IGVsc2Uge1xuXHRcdGlmcmFtZS5zcmMgPSAnYWJvdXQ6YmxhbmsnO1xuXHRcdGlmcmFtZS5vbmxvYWQgPSAoKSA9PiB7XG5cdFx0XHR1bnN1YnNjcmliZSA9IGxpc3RlbihpZnJhbWUuY29udGVudFdpbmRvdywgJ3Jlc2l6ZScsIGZuKTtcblx0XHRcdC8vIG1ha2Ugc3VyZSBhbiBpbml0aWFsIHJlc2l6ZSBldmVudCBpcyBmaXJlZCBfYWZ0ZXJfIHRoZSBpZnJhbWUgaXMgbG9hZGVkICh3aGljaCBpcyBhc3luY2hyb25vdXMpXG5cdFx0XHQvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3N2ZWx0ZWpzL3N2ZWx0ZS9pc3N1ZXMvNDIzM1xuXHRcdFx0Zm4oKTtcblx0XHR9O1xuXHR9XG5cdGFwcGVuZChub2RlLCBpZnJhbWUpO1xuXHRyZXR1cm4gKCkgPT4ge1xuXHRcdGlmIChjcm9zc29yaWdpbikge1xuXHRcdFx0dW5zdWJzY3JpYmUoKTtcblx0XHR9IGVsc2UgaWYgKHVuc3Vic2NyaWJlICYmIGlmcmFtZS5jb250ZW50V2luZG93KSB7XG5cdFx0XHR1bnN1YnNjcmliZSgpO1xuXHRcdH1cblx0XHRkZXRhY2goaWZyYW1lKTtcblx0fTtcbn1cbmV4cG9ydCBjb25zdCByZXNpemVfb2JzZXJ2ZXJfY29udGVudF9ib3ggPSAvKiBAX19QVVJFX18gKi8gbmV3IFJlc2l6ZU9ic2VydmVyU2luZ2xldG9uKHtcblx0Ym94OiAnY29udGVudC1ib3gnXG59KTtcbmV4cG9ydCBjb25zdCByZXNpemVfb2JzZXJ2ZXJfYm9yZGVyX2JveCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgUmVzaXplT2JzZXJ2ZXJTaW5nbGV0b24oe1xuXHRib3g6ICdib3JkZXItYm94J1xufSk7XG5leHBvcnQgY29uc3QgcmVzaXplX29ic2VydmVyX2RldmljZV9waXhlbF9jb250ZW50X2JveCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgUmVzaXplT2JzZXJ2ZXJTaW5nbGV0b24oXG5cdHsgYm94OiAnZGV2aWNlLXBpeGVsLWNvbnRlbnQtYm94JyB9XG4pO1xuZXhwb3J0IHsgUmVzaXplT2JzZXJ2ZXJTaW5nbGV0b24gfTtcblxuLyoqXG4gKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b2dnbGVfY2xhc3MoZWxlbWVudCwgbmFtZSwgdG9nZ2xlKSB7XG5cdC8vIFRoZSBgISFgIGlzIHJlcXVpcmVkIGJlY2F1c2UgYW4gYHVuZGVmaW5lZGAgZmxhZyBtZWFucyBmbGlwcGluZyB0aGUgY3VycmVudCBzdGF0ZS5cblx0ZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKG5hbWUsICEhdG9nZ2xlKTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7VH0gW2RldGFpbF1cbiAqIEBwYXJhbSB7eyBidWJibGVzPzogYm9vbGVhbiwgY2FuY2VsYWJsZT86IGJvb2xlYW4gfX0gW29wdGlvbnNdXG4gKiBAcmV0dXJucyB7Q3VzdG9tRXZlbnQ8VD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjdXN0b21fZXZlbnQodHlwZSwgZGV0YWlsLCB7IGJ1YmJsZXMgPSBmYWxzZSwgY2FuY2VsYWJsZSA9IGZhbHNlIH0gPSB7fSkge1xuXHRyZXR1cm4gbmV3IEN1c3RvbUV2ZW50KHR5cGUsIHsgZGV0YWlsLCBidWJibGVzLCBjYW5jZWxhYmxlIH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50XG4gKiBAcmV0dXJucyB7Q2hpbGROb2RlQXJyYXl9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWVyeV9zZWxlY3Rvcl9hbGwoc2VsZWN0b3IsIHBhcmVudCA9IGRvY3VtZW50LmJvZHkpIHtcblx0cmV0dXJuIEFycmF5LmZyb20ocGFyZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbm9kZUlkXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBoZWFkXG4gKiBAcmV0dXJucyB7YW55W119XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZWFkX3NlbGVjdG9yKG5vZGVJZCwgaGVhZCkge1xuXHRjb25zdCByZXN1bHQgPSBbXTtcblx0bGV0IHN0YXJ0ZWQgPSAwO1xuXHRmb3IgKGNvbnN0IG5vZGUgb2YgaGVhZC5jaGlsZE5vZGVzKSB7XG5cdFx0aWYgKG5vZGUubm9kZVR5cGUgPT09IDggLyogY29tbWVudCBub2RlICovKSB7XG5cdFx0XHRjb25zdCBjb21tZW50ID0gbm9kZS50ZXh0Q29udGVudC50cmltKCk7XG5cdFx0XHRpZiAoY29tbWVudCA9PT0gYEhFQURfJHtub2RlSWR9X0VORGApIHtcblx0XHRcdFx0c3RhcnRlZCAtPSAxO1xuXHRcdFx0XHRyZXN1bHQucHVzaChub2RlKTtcblx0XHRcdH0gZWxzZSBpZiAoY29tbWVudCA9PT0gYEhFQURfJHtub2RlSWR9X1NUQVJUYCkge1xuXHRcdFx0XHRzdGFydGVkICs9IDE7XG5cdFx0XHRcdHJlc3VsdC5wdXNoKG5vZGUpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoc3RhcnRlZCA+IDApIHtcblx0XHRcdHJlc3VsdC5wdXNoKG5vZGUpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufVxuLyoqICovXG5leHBvcnQgY2xhc3MgSHRtbFRhZyB7XG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAZGVmYXVsdCBmYWxzZVxuXHQgKi9cblx0aXNfc3ZnID0gZmFsc2U7XG5cdC8qKiBwYXJlbnQgZm9yIGNyZWF0aW5nIG5vZGUgKi9cblx0ZSA9IHVuZGVmaW5lZDtcblx0LyoqIGh0bWwgdGFnIG5vZGVzICovXG5cdG4gPSB1bmRlZmluZWQ7XG5cdC8qKiB0YXJnZXQgKi9cblx0dCA9IHVuZGVmaW5lZDtcblx0LyoqIGFuY2hvciAqL1xuXHRhID0gdW5kZWZpbmVkO1xuXHRjb25zdHJ1Y3Rvcihpc19zdmcgPSBmYWxzZSkge1xuXHRcdHRoaXMuaXNfc3ZnID0gaXNfc3ZnO1xuXHRcdHRoaXMuZSA9IHRoaXMubiA9IG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRjKGh0bWwpIHtcblx0XHR0aGlzLmgoaHRtbCk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnR9IHRhcmdldFxuXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50IHwgU1ZHRWxlbWVudH0gYW5jaG9yXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0bShodG1sLCB0YXJnZXQsIGFuY2hvciA9IG51bGwpIHtcblx0XHRpZiAoIXRoaXMuZSkge1xuXHRcdFx0aWYgKHRoaXMuaXNfc3ZnKVxuXHRcdFx0XHR0aGlzLmUgPSBzdmdfZWxlbWVudCgvKiogQHR5cGUge2tleW9mIFNWR0VsZW1lbnRUYWdOYW1lTWFwfSAqLyAodGFyZ2V0Lm5vZGVOYW1lKSk7XG5cdFx0XHQvKiogIzczNjQgIHRhcmdldCBmb3IgPHRlbXBsYXRlPiBtYXkgYmUgcHJvdmlkZWQgYXMgI2RvY3VtZW50LWZyYWdtZW50KDExKSAqLyBlbHNlXG5cdFx0XHRcdHRoaXMuZSA9IGVsZW1lbnQoXG5cdFx0XHRcdFx0LyoqIEB0eXBlIHtrZXlvZiBIVE1MRWxlbWVudFRhZ05hbWVNYXB9ICovIChcblx0XHRcdFx0XHRcdHRhcmdldC5ub2RlVHlwZSA9PT0gMTEgPyAnVEVNUExBVEUnIDogdGFyZ2V0Lm5vZGVOYW1lXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHQpO1xuXHRcdFx0dGhpcy50ID1cblx0XHRcdFx0dGFyZ2V0LnRhZ05hbWUgIT09ICdURU1QTEFURSdcblx0XHRcdFx0XHQ/IHRhcmdldFxuXHRcdFx0XHRcdDogLyoqIEB0eXBlIHtIVE1MVGVtcGxhdGVFbGVtZW50fSAqLyAodGFyZ2V0KS5jb250ZW50O1xuXHRcdFx0dGhpcy5jKGh0bWwpO1xuXHRcdH1cblx0XHR0aGlzLmkoYW5jaG9yKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdGgoaHRtbCkge1xuXHRcdHRoaXMuZS5pbm5lckhUTUwgPSBodG1sO1xuXHRcdHRoaXMubiA9IEFycmF5LmZyb20oXG5cdFx0XHR0aGlzLmUubm9kZU5hbWUgPT09ICdURU1QTEFURScgPyB0aGlzLmUuY29udGVudC5jaGlsZE5vZGVzIDogdGhpcy5lLmNoaWxkTm9kZXNcblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHt2b2lkfSAqL1xuXHRpKGFuY2hvcikge1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5uLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0XHRpbnNlcnQodGhpcy50LCB0aGlzLm5baV0sIGFuY2hvcik7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0cChodG1sKSB7XG5cdFx0dGhpcy5kKCk7XG5cdFx0dGhpcy5oKGh0bWwpO1xuXHRcdHRoaXMuaSh0aGlzLmEpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHt2b2lkfSAqL1xuXHRkKCkge1xuXHRcdHRoaXMubi5mb3JFYWNoKGRldGFjaCk7XG5cdH1cbn1cblxuZXhwb3J0IGNsYXNzIEh0bWxUYWdIeWRyYXRpb24gZXh0ZW5kcyBIdG1sVGFnIHtcblx0LyoqIEB0eXBlIHtFbGVtZW50W119IGh5ZHJhdGlvbiBjbGFpbWVkIG5vZGVzICovXG5cdGwgPSB1bmRlZmluZWQ7XG5cblx0Y29uc3RydWN0b3IoaXNfc3ZnID0gZmFsc2UsIGNsYWltZWRfbm9kZXMpIHtcblx0XHRzdXBlcihpc19zdmcpO1xuXHRcdHRoaXMuZSA9IHRoaXMubiA9IG51bGw7XG5cdFx0dGhpcy5sID0gY2xhaW1lZF9ub2Rlcztcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdGMoaHRtbCkge1xuXHRcdGlmICh0aGlzLmwpIHtcblx0XHRcdHRoaXMubiA9IHRoaXMubDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3VwZXIuYyhodG1sKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge3ZvaWR9ICovXG5cdGkoYW5jaG9yKSB7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm4ubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRcdGluc2VydF9oeWRyYXRpb24odGhpcy50LCB0aGlzLm5baV0sIGFuY2hvcik7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtOYW1lZE5vZGVNYXB9IGF0dHJpYnV0ZXNcbiAqIEByZXR1cm5zIHt7fX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGF0dHJpYnV0ZV90b19vYmplY3QoYXR0cmlidXRlcykge1xuXHRjb25zdCByZXN1bHQgPSB7fTtcblx0Zm9yIChjb25zdCBhdHRyaWJ1dGUgb2YgYXR0cmlidXRlcykge1xuXHRcdHJlc3VsdFthdHRyaWJ1dGUubmFtZV0gPSBhdHRyaWJ1dGUudmFsdWU7XG5cdH1cblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuY29uc3QgZXNjYXBlZCA9IHtcblx0J1wiJzogJyZxdW90OycsXG5cdCcmJzogJyZhbXA7Jyxcblx0JzwnOiAnJmx0Oydcbn07XG5cbmNvbnN0IHJlZ2V4X2F0dHJpYnV0ZV9jaGFyYWN0ZXJzX3RvX2VzY2FwZSA9IC9bXCImPF0vZztcblxuLyoqXG4gKiBOb3RlIHRoYXQgdGhlIGF0dHJpYnV0ZSBpdHNlbGYgc2hvdWxkIGJlIHN1cnJvdW5kZWQgaW4gZG91YmxlIHF1b3Rlc1xuICogQHBhcmFtIHthbnl9IGF0dHJpYnV0ZVxuICovXG5mdW5jdGlvbiBlc2NhcGVfYXR0cmlidXRlKGF0dHJpYnV0ZSkge1xuXHRyZXR1cm4gU3RyaW5nKGF0dHJpYnV0ZSkucmVwbGFjZShyZWdleF9hdHRyaWJ1dGVfY2hhcmFjdGVyc190b19lc2NhcGUsIChtYXRjaCkgPT4gZXNjYXBlZFttYXRjaF0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn0gYXR0cmlidXRlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5naWZ5X3NwcmVhZChhdHRyaWJ1dGVzKSB7XG5cdGxldCBzdHIgPSAnICc7XG5cdGZvciAoY29uc3Qga2V5IGluIGF0dHJpYnV0ZXMpIHtcblx0XHRpZiAoYXR0cmlidXRlc1trZXldICE9IG51bGwpIHtcblx0XHRcdHN0ciArPSBgJHtrZXl9PVwiJHtlc2NhcGVfYXR0cmlidXRlKGF0dHJpYnV0ZXNba2V5XSl9XCIgYDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gc3RyO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHt7fX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldF9jdXN0b21fZWxlbWVudHNfc2xvdHMoZWxlbWVudCkge1xuXHRjb25zdCByZXN1bHQgPSB7fTtcblx0ZWxlbWVudC5jaGlsZE5vZGVzLmZvckVhY2goXG5cdFx0LyoqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSAqLyAobm9kZSkgPT4ge1xuXHRcdFx0cmVzdWx0W25vZGUuc2xvdCB8fCAnZGVmYXVsdCddID0gdHJ1ZTtcblx0XHR9XG5cdCk7XG5cdHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb25zdHJ1Y3Rfc3ZlbHRlX2NvbXBvbmVudChjb21wb25lbnQsIHByb3BzKSB7XG5cdHJldHVybiBuZXcgY29tcG9uZW50KHByb3BzKTtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7Tm9kZSAmIHtcbiAqIFx0Y2xhaW1fb3JkZXI/OiBudW1iZXI7XG4gKiBcdGh5ZHJhdGVfaW5pdD86IHRydWU7XG4gKiBcdGFjdHVhbF9lbmRfY2hpbGQ/OiBOb2RlRXg7XG4gKiBcdGNoaWxkTm9kZXM6IE5vZGVMaXN0T2Y8Tm9kZUV4PjtcbiAqIH19IE5vZGVFeFxuICovXG5cbi8qKiBAdHlwZWRlZiB7Q2hpbGROb2RlICYgTm9kZUV4fSBDaGlsZE5vZGVFeCAqL1xuXG4vKiogQHR5cGVkZWYge05vZGVFeCAmIHsgY2xhaW1fb3JkZXI6IG51bWJlciB9fSBOb2RlRXgyICovXG5cbi8qKlxuICogQHR5cGVkZWYge0NoaWxkTm9kZUV4W10gJiB7XG4gKiBcdGNsYWltX2luZm8/OiB7XG4gKiBcdFx0bGFzdF9pbmRleDogbnVtYmVyO1xuICogXHRcdHRvdGFsX2NsYWltZWQ6IG51bWJlcjtcbiAqIFx0fTtcbiAqIH19IENoaWxkTm9kZUFycmF5XG4gKi9cbiIsICJpbXBvcnQgeyBjdXN0b21fZXZlbnQgfSBmcm9tICcuL2RvbS5qcyc7XG5cbmV4cG9ydCBsZXQgY3VycmVudF9jb21wb25lbnQ7XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfY3VycmVudF9jb21wb25lbnQoY29tcG9uZW50KSB7XG5cdGN1cnJlbnRfY29tcG9uZW50ID0gY29tcG9uZW50O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkge1xuXHRpZiAoIWN1cnJlbnRfY29tcG9uZW50KSB0aHJvdyBuZXcgRXJyb3IoJ0Z1bmN0aW9uIGNhbGxlZCBvdXRzaWRlIGNvbXBvbmVudCBpbml0aWFsaXphdGlvbicpO1xuXHRyZXR1cm4gY3VycmVudF9jb21wb25lbnQ7XG59XG5cbi8qKlxuICogU2NoZWR1bGVzIGEgY2FsbGJhY2sgdG8gcnVuIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIHVwZGF0ZWQgYWZ0ZXIgYW55IHN0YXRlIGNoYW5nZS5cbiAqXG4gKiBUaGUgZmlyc3QgdGltZSB0aGUgY2FsbGJhY2sgcnVucyB3aWxsIGJlIGJlZm9yZSB0aGUgaW5pdGlhbCBgb25Nb3VudGBcbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUjYmVmb3JldXBkYXRlXG4gKiBAcGFyYW0geygpID0+IGFueX0gZm5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmVmb3JlVXBkYXRlKGZuKSB7XG5cdGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmJlZm9yZV91cGRhdGUucHVzaChmbik7XG59XG5cbi8qKlxuICogVGhlIGBvbk1vdW50YCBmdW5jdGlvbiBzY2hlZHVsZXMgYSBjYWxsYmFjayB0byBydW4gYXMgc29vbiBhcyB0aGUgY29tcG9uZW50IGhhcyBiZWVuIG1vdW50ZWQgdG8gdGhlIERPTS5cbiAqIEl0IG11c3QgYmUgY2FsbGVkIGR1cmluZyB0aGUgY29tcG9uZW50J3MgaW5pdGlhbGlzYXRpb24gKGJ1dCBkb2Vzbid0IG5lZWQgdG8gbGl2ZSAqaW5zaWRlKiB0aGUgY29tcG9uZW50O1xuICogaXQgY2FuIGJlIGNhbGxlZCBmcm9tIGFuIGV4dGVybmFsIG1vZHVsZSkuXG4gKlxuICogSWYgYSBmdW5jdGlvbiBpcyByZXR1cm5lZCBfc3luY2hyb25vdXNseV8gZnJvbSBgb25Nb3VudGAsIGl0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQuXG4gKlxuICogYG9uTW91bnRgIGRvZXMgbm90IHJ1biBpbnNpZGUgYSBbc2VydmVyLXNpZGUgY29tcG9uZW50XShodHRwczovL3N2ZWx0ZS5kZXYvZG9jcyNydW4tdGltZS1zZXJ2ZXItc2lkZS1jb21wb25lbnQtYXBpKS5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUjb25tb3VudFxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7KCkgPT4gaW1wb3J0KCcuL3ByaXZhdGUuanMnKS5Ob3RGdW5jdGlvbjxUPiB8IFByb21pc2U8aW1wb3J0KCcuL3ByaXZhdGUuanMnKS5Ob3RGdW5jdGlvbjxUPj4gfCAoKCkgPT4gYW55KX0gZm5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gb25Nb3VudChmbikge1xuXHRnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5vbl9tb3VudC5wdXNoKGZuKTtcbn1cblxuLyoqXG4gKiBTY2hlZHVsZXMgYSBjYWxsYmFjayB0byBydW4gaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGNvbXBvbmVudCBoYXMgYmVlbiB1cGRhdGVkLlxuICpcbiAqIFRoZSBmaXJzdCB0aW1lIHRoZSBjYWxsYmFjayBydW5zIHdpbGwgYmUgYWZ0ZXIgdGhlIGluaXRpYWwgYG9uTW91bnRgXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlI2FmdGVydXBkYXRlXG4gKiBAcGFyYW0geygpID0+IGFueX0gZm5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWZ0ZXJVcGRhdGUoZm4pIHtcblx0Z2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuYWZ0ZXJfdXBkYXRlLnB1c2goZm4pO1xufVxuXG4vKipcbiAqIFNjaGVkdWxlcyBhIGNhbGxiYWNrIHRvIHJ1biBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQuXG4gKlxuICogT3V0IG9mIGBvbk1vdW50YCwgYGJlZm9yZVVwZGF0ZWAsIGBhZnRlclVwZGF0ZWAgYW5kIGBvbkRlc3Ryb3lgLCB0aGlzIGlzIHRoZVxuICogb25seSBvbmUgdGhhdCBydW5zIGluc2lkZSBhIHNlcnZlci1zaWRlIGNvbXBvbmVudC5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUjb25kZXN0cm95XG4gKiBAcGFyYW0geygpID0+IGFueX0gZm5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gb25EZXN0cm95KGZuKSB7XG5cdGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLm9uX2Rlc3Ryb3kucHVzaChmbik7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBldmVudCBkaXNwYXRjaGVyIHRoYXQgY2FuIGJlIHVzZWQgdG8gZGlzcGF0Y2ggW2NvbXBvbmVudCBldmVudHNdKGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzI3RlbXBsYXRlLXN5bnRheC1jb21wb25lbnQtZGlyZWN0aXZlcy1vbi1ldmVudG5hbWUpLlxuICogRXZlbnQgZGlzcGF0Y2hlcnMgYXJlIGZ1bmN0aW9ucyB0aGF0IGNhbiB0YWtlIHR3byBhcmd1bWVudHM6IGBuYW1lYCBhbmQgYGRldGFpbGAuXG4gKlxuICogQ29tcG9uZW50IGV2ZW50cyBjcmVhdGVkIHdpdGggYGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcmAgY3JlYXRlIGFcbiAqIFtDdXN0b21FdmVudF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0N1c3RvbUV2ZW50KS5cbiAqIFRoZXNlIGV2ZW50cyBkbyBub3QgW2J1YmJsZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9MZWFybi9KYXZhU2NyaXB0L0J1aWxkaW5nX2Jsb2Nrcy9FdmVudHMjRXZlbnRfYnViYmxpbmdfYW5kX2NhcHR1cmUpLlxuICogVGhlIGBkZXRhaWxgIGFyZ3VtZW50IGNvcnJlc3BvbmRzIHRvIHRoZSBbQ3VzdG9tRXZlbnQuZGV0YWlsXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3VzdG9tRXZlbnQvZGV0YWlsKVxuICogcHJvcGVydHkgYW5kIGNhbiBjb250YWluIGFueSB0eXBlIG9mIGRhdGEuXG4gKlxuICogVGhlIGV2ZW50IGRpc3BhdGNoZXIgY2FuIGJlIHR5cGVkIHRvIG5hcnJvdyB0aGUgYWxsb3dlZCBldmVudCBuYW1lcyBhbmQgdGhlIHR5cGUgb2YgdGhlIGBkZXRhaWxgIGFyZ3VtZW50OlxuICogYGBgdHNcbiAqIGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyPHtcbiAqICBsb2FkZWQ6IG5ldmVyOyAvLyBkb2VzIG5vdCB0YWtlIGEgZGV0YWlsIGFyZ3VtZW50XG4gKiAgY2hhbmdlOiBzdHJpbmc7IC8vIHRha2VzIGEgZGV0YWlsIGFyZ3VtZW50IG9mIHR5cGUgc3RyaW5nLCB3aGljaCBpcyByZXF1aXJlZFxuICogIG9wdGlvbmFsOiBudW1iZXIgfCBudWxsOyAvLyB0YWtlcyBhbiBvcHRpb25hbCBkZXRhaWwgYXJndW1lbnQgb2YgdHlwZSBudW1iZXJcbiAqIH0+KCk7XG4gKiBgYGBcbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUjY3JlYXRlZXZlbnRkaXNwYXRjaGVyXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsIGFueT59IFtFdmVudE1hcD1hbnldXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL3B1YmxpYy5qcycpLkV2ZW50RGlzcGF0Y2hlcjxFdmVudE1hcD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFdmVudERpc3BhdGNoZXIoKSB7XG5cdGNvbnN0IGNvbXBvbmVudCA9IGdldF9jdXJyZW50X2NvbXBvbmVudCgpO1xuXHRyZXR1cm4gKHR5cGUsIGRldGFpbCwgeyBjYW5jZWxhYmxlID0gZmFsc2UgfSA9IHt9KSA9PiB7XG5cdFx0Y29uc3QgY2FsbGJhY2tzID0gY29tcG9uZW50LiQkLmNhbGxiYWNrc1t0eXBlXTtcblx0XHRpZiAoY2FsbGJhY2tzKSB7XG5cdFx0XHQvLyBUT0RPIGFyZSB0aGVyZSBzaXR1YXRpb25zIHdoZXJlIGV2ZW50cyBjb3VsZCBiZSBkaXNwYXRjaGVkXG5cdFx0XHQvLyBpbiBhIHNlcnZlciAobm9uLURPTSkgZW52aXJvbm1lbnQ/XG5cdFx0XHRjb25zdCBldmVudCA9IGN1c3RvbV9ldmVudCgvKiogQHR5cGUge3N0cmluZ30gKi8gKHR5cGUpLCBkZXRhaWwsIHsgY2FuY2VsYWJsZSB9KTtcblx0XHRcdGNhbGxiYWNrcy5zbGljZSgpLmZvckVhY2goKGZuKSA9PiB7XG5cdFx0XHRcdGZuLmNhbGwoY29tcG9uZW50LCBldmVudCk7XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiAhZXZlbnQuZGVmYXVsdFByZXZlbnRlZDtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG59XG5cbi8qKlxuICogQXNzb2NpYXRlcyBhbiBhcmJpdHJhcnkgYGNvbnRleHRgIG9iamVjdCB3aXRoIHRoZSBjdXJyZW50IGNvbXBvbmVudCBhbmQgdGhlIHNwZWNpZmllZCBga2V5YFxuICogYW5kIHJldHVybnMgdGhhdCBvYmplY3QuIFRoZSBjb250ZXh0IGlzIHRoZW4gYXZhaWxhYmxlIHRvIGNoaWxkcmVuIG9mIHRoZSBjb21wb25lbnRcbiAqIChpbmNsdWRpbmcgc2xvdHRlZCBjb250ZW50KSB3aXRoIGBnZXRDb250ZXh0YC5cbiAqXG4gKiBMaWtlIGxpZmVjeWNsZSBmdW5jdGlvbnMsIHRoaXMgbXVzdCBiZSBjYWxsZWQgZHVyaW5nIGNvbXBvbmVudCBpbml0aWFsaXNhdGlvbi5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUjc2V0Y29udGV4dFxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7YW55fSBrZXlcbiAqIEBwYXJhbSB7VH0gY29udGV4dFxuICogQHJldHVybnMge1R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRDb250ZXh0KGtleSwgY29udGV4dCkge1xuXHRnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5jb250ZXh0LnNldChrZXksIGNvbnRleHQpO1xuXHRyZXR1cm4gY29udGV4dDtcbn1cblxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIGNvbnRleHQgdGhhdCBiZWxvbmdzIHRvIHRoZSBjbG9zZXN0IHBhcmVudCBjb21wb25lbnQgd2l0aCB0aGUgc3BlY2lmaWVkIGBrZXlgLlxuICogTXVzdCBiZSBjYWxsZWQgZHVyaW5nIGNvbXBvbmVudCBpbml0aWFsaXNhdGlvbi5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUjZ2V0Y29udGV4dFxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7YW55fSBrZXlcbiAqIEByZXR1cm5zIHtUfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29udGV4dChrZXkpIHtcblx0cmV0dXJuIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmNvbnRleHQuZ2V0KGtleSk7XG59XG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSB3aG9sZSBjb250ZXh0IG1hcCB0aGF0IGJlbG9uZ3MgdG8gdGhlIGNsb3Nlc3QgcGFyZW50IGNvbXBvbmVudC5cbiAqIE11c3QgYmUgY2FsbGVkIGR1cmluZyBjb21wb25lbnQgaW5pdGlhbGlzYXRpb24uIFVzZWZ1bCwgZm9yIGV4YW1wbGUsIGlmIHlvdVxuICogcHJvZ3JhbW1hdGljYWxseSBjcmVhdGUgYSBjb21wb25lbnQgYW5kIHdhbnQgdG8gcGFzcyB0aGUgZXhpc3RpbmcgY29udGV4dCB0byBpdC5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUjZ2V0YWxsY29udGV4dHNcbiAqIEB0ZW1wbGF0ZSB7TWFwPGFueSwgYW55Pn0gW1Q9TWFwPGFueSwgYW55Pl1cbiAqIEByZXR1cm5zIHtUfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWxsQ29udGV4dHMoKSB7XG5cdHJldHVybiBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5jb250ZXh0O1xufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgZ2l2ZW4gYGtleWAgaGFzIGJlZW4gc2V0IGluIHRoZSBjb250ZXh0IG9mIGEgcGFyZW50IGNvbXBvbmVudC5cbiAqIE11c3QgYmUgY2FsbGVkIGR1cmluZyBjb21wb25lbnQgaW5pdGlhbGlzYXRpb24uXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlI2hhc2NvbnRleHRcbiAqIEBwYXJhbSB7YW55fSBrZXlcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzQ29udGV4dChrZXkpIHtcblx0cmV0dXJuIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmNvbnRleHQuaGFzKGtleSk7XG59XG5cbi8vIFRPRE8gZmlndXJlIG91dCBpZiB3ZSBzdGlsbCB3YW50IHRvIHN1cHBvcnRcbi8vIHNob3J0aGFuZCBldmVudHMsIG9yIGlmIHdlIHdhbnQgdG8gaW1wbGVtZW50XG4vLyBhIHJlYWwgYnViYmxpbmcgbWVjaGFuaXNtXG4vKipcbiAqIEBwYXJhbSBjb21wb25lbnRcbiAqIEBwYXJhbSBldmVudFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWJibGUoY29tcG9uZW50LCBldmVudCkge1xuXHRjb25zdCBjYWxsYmFja3MgPSBjb21wb25lbnQuJCQuY2FsbGJhY2tzW2V2ZW50LnR5cGVdO1xuXHRpZiAoY2FsbGJhY2tzKSB7XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdGNhbGxiYWNrcy5zbGljZSgpLmZvckVhY2goKGZuKSA9PiBmbi5jYWxsKHRoaXMsIGV2ZW50KSk7XG5cdH1cbn1cbiIsICJpbXBvcnQgeyBydW5fYWxsIH0gZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyBjdXJyZW50X2NvbXBvbmVudCwgc2V0X2N1cnJlbnRfY29tcG9uZW50IH0gZnJvbSAnLi9saWZlY3ljbGUuanMnO1xuXG5leHBvcnQgY29uc3QgZGlydHlfY29tcG9uZW50cyA9IFtdO1xuZXhwb3J0IGNvbnN0IGludHJvcyA9IHsgZW5hYmxlZDogZmFsc2UgfTtcbmV4cG9ydCBjb25zdCBiaW5kaW5nX2NhbGxiYWNrcyA9IFtdO1xuXG5sZXQgcmVuZGVyX2NhbGxiYWNrcyA9IFtdO1xuXG5jb25zdCBmbHVzaF9jYWxsYmFja3MgPSBbXTtcblxuY29uc3QgcmVzb2x2ZWRfcHJvbWlzZSA9IC8qIEBfX1BVUkVfXyAqLyBQcm9taXNlLnJlc29sdmUoKTtcblxubGV0IHVwZGF0ZV9zY2hlZHVsZWQgPSBmYWxzZTtcblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjaGVkdWxlX3VwZGF0ZSgpIHtcblx0aWYgKCF1cGRhdGVfc2NoZWR1bGVkKSB7XG5cdFx0dXBkYXRlX3NjaGVkdWxlZCA9IHRydWU7XG5cdFx0cmVzb2x2ZWRfcHJvbWlzZS50aGVuKGZsdXNoKTtcblx0fVxufVxuXG4vKiogQHJldHVybnMge1Byb21pc2U8dm9pZD59ICovXG5leHBvcnQgZnVuY3Rpb24gdGljaygpIHtcblx0c2NoZWR1bGVfdXBkYXRlKCk7XG5cdHJldHVybiByZXNvbHZlZF9wcm9taXNlO1xufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gYWRkX3JlbmRlcl9jYWxsYmFjayhmbikge1xuXHRyZW5kZXJfY2FsbGJhY2tzLnB1c2goZm4pO1xufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gYWRkX2ZsdXNoX2NhbGxiYWNrKGZuKSB7XG5cdGZsdXNoX2NhbGxiYWNrcy5wdXNoKGZuKTtcbn1cblxuLy8gZmx1c2goKSBjYWxscyBjYWxsYmFja3MgaW4gdGhpcyBvcmRlcjpcbi8vIDEuIEFsbCBiZWZvcmVVcGRhdGUgY2FsbGJhY2tzLCBpbiBvcmRlcjogcGFyZW50cyBiZWZvcmUgY2hpbGRyZW5cbi8vIDIuIEFsbCBiaW5kOnRoaXMgY2FsbGJhY2tzLCBpbiByZXZlcnNlIG9yZGVyOiBjaGlsZHJlbiBiZWZvcmUgcGFyZW50cy5cbi8vIDMuIEFsbCBhZnRlclVwZGF0ZSBjYWxsYmFja3MsIGluIG9yZGVyOiBwYXJlbnRzIGJlZm9yZSBjaGlsZHJlbi4gRVhDRVBUXG4vLyAgICBmb3IgYWZ0ZXJVcGRhdGVzIGNhbGxlZCBkdXJpbmcgdGhlIGluaXRpYWwgb25Nb3VudCwgd2hpY2ggYXJlIGNhbGxlZCBpblxuLy8gICAgcmV2ZXJzZSBvcmRlcjogY2hpbGRyZW4gYmVmb3JlIHBhcmVudHMuXG4vLyBTaW5jZSBjYWxsYmFja3MgbWlnaHQgdXBkYXRlIGNvbXBvbmVudCB2YWx1ZXMsIHdoaWNoIGNvdWxkIHRyaWdnZXIgYW5vdGhlclxuLy8gY2FsbCB0byBmbHVzaCgpLCB0aGUgZm9sbG93aW5nIHN0ZXBzIGd1YXJkIGFnYWluc3QgdGhpczpcbi8vIDEuIER1cmluZyBiZWZvcmVVcGRhdGUsIGFueSB1cGRhdGVkIGNvbXBvbmVudHMgd2lsbCBiZSBhZGRlZCB0byB0aGVcbi8vICAgIGRpcnR5X2NvbXBvbmVudHMgYXJyYXkgYW5kIHdpbGwgY2F1c2UgYSByZWVudHJhbnQgY2FsbCB0byBmbHVzaCgpLiBCZWNhdXNlXG4vLyAgICB0aGUgZmx1c2ggaW5kZXggaXMga2VwdCBvdXRzaWRlIHRoZSBmdW5jdGlvbiwgdGhlIHJlZW50cmFudCBjYWxsIHdpbGwgcGlja1xuLy8gICAgdXAgd2hlcmUgdGhlIGVhcmxpZXIgY2FsbCBsZWZ0IG9mZiBhbmQgZ28gdGhyb3VnaCBhbGwgZGlydHkgY29tcG9uZW50cy4gVGhlXG4vLyAgICBjdXJyZW50X2NvbXBvbmVudCB2YWx1ZSBpcyBzYXZlZCBhbmQgcmVzdG9yZWQgc28gdGhhdCB0aGUgcmVlbnRyYW50IGNhbGwgd2lsbFxuLy8gICAgbm90IGludGVyZmVyZSB3aXRoIHRoZSBcInBhcmVudFwiIGZsdXNoKCkgY2FsbC5cbi8vIDIuIGJpbmQ6dGhpcyBjYWxsYmFja3MgY2Fubm90IHRyaWdnZXIgbmV3IGZsdXNoKCkgY2FsbHMuXG4vLyAzLiBEdXJpbmcgYWZ0ZXJVcGRhdGUsIGFueSB1cGRhdGVkIGNvbXBvbmVudHMgd2lsbCBOT1QgaGF2ZSB0aGVpciBhZnRlclVwZGF0ZVxuLy8gICAgY2FsbGJhY2sgY2FsbGVkIGEgc2Vjb25kIHRpbWU7IHRoZSBzZWVuX2NhbGxiYWNrcyBzZXQsIG91dHNpZGUgdGhlIGZsdXNoKClcbi8vICAgIGZ1bmN0aW9uLCBndWFyYW50ZWVzIHRoaXMgYmVoYXZpb3IuXG5jb25zdCBzZWVuX2NhbGxiYWNrcyA9IG5ldyBTZXQoKTtcblxubGV0IGZsdXNoaWR4ID0gMDsgLy8gRG8gKm5vdCogbW92ZSB0aGlzIGluc2lkZSB0aGUgZmx1c2goKSBmdW5jdGlvblxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gZmx1c2goKSB7XG5cdC8vIERvIG5vdCByZWVudGVyIGZsdXNoIHdoaWxlIGRpcnR5IGNvbXBvbmVudHMgYXJlIHVwZGF0ZWQsIGFzIHRoaXMgY2FuXG5cdC8vIHJlc3VsdCBpbiBhbiBpbmZpbml0ZSBsb29wLiBJbnN0ZWFkLCBsZXQgdGhlIGlubmVyIGZsdXNoIGhhbmRsZSBpdC5cblx0Ly8gUmVlbnRyYW5jeSBpcyBvayBhZnRlcndhcmRzIGZvciBiaW5kaW5ncyBldGMuXG5cdGlmIChmbHVzaGlkeCAhPT0gMCkge1xuXHRcdHJldHVybjtcblx0fVxuXHRjb25zdCBzYXZlZF9jb21wb25lbnQgPSBjdXJyZW50X2NvbXBvbmVudDtcblx0ZG8ge1xuXHRcdC8vIGZpcnN0LCBjYWxsIGJlZm9yZVVwZGF0ZSBmdW5jdGlvbnNcblx0XHQvLyBhbmQgdXBkYXRlIGNvbXBvbmVudHNcblx0XHR0cnkge1xuXHRcdFx0d2hpbGUgKGZsdXNoaWR4IDwgZGlydHlfY29tcG9uZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0Y29uc3QgY29tcG9uZW50ID0gZGlydHlfY29tcG9uZW50c1tmbHVzaGlkeF07XG5cdFx0XHRcdGZsdXNoaWR4Kys7XG5cdFx0XHRcdHNldF9jdXJyZW50X2NvbXBvbmVudChjb21wb25lbnQpO1xuXHRcdFx0XHR1cGRhdGUoY29tcG9uZW50LiQkKTtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHQvLyByZXNldCBkaXJ0eSBzdGF0ZSB0byBub3QgZW5kIHVwIGluIGEgZGVhZGxvY2tlZCBzdGF0ZSBhbmQgdGhlbiByZXRocm93XG5cdFx0XHRkaXJ0eV9jb21wb25lbnRzLmxlbmd0aCA9IDA7XG5cdFx0XHRmbHVzaGlkeCA9IDA7XG5cdFx0XHR0aHJvdyBlO1xuXHRcdH1cblx0XHRzZXRfY3VycmVudF9jb21wb25lbnQobnVsbCk7XG5cdFx0ZGlydHlfY29tcG9uZW50cy5sZW5ndGggPSAwO1xuXHRcdGZsdXNoaWR4ID0gMDtcblx0XHR3aGlsZSAoYmluZGluZ19jYWxsYmFja3MubGVuZ3RoKSBiaW5kaW5nX2NhbGxiYWNrcy5wb3AoKSgpO1xuXHRcdC8vIHRoZW4sIG9uY2UgY29tcG9uZW50cyBhcmUgdXBkYXRlZCwgY2FsbFxuXHRcdC8vIGFmdGVyVXBkYXRlIGZ1bmN0aW9ucy4gVGhpcyBtYXkgY2F1c2Vcblx0XHQvLyBzdWJzZXF1ZW50IHVwZGF0ZXMuLi5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHJlbmRlcl9jYWxsYmFja3MubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRcdGNvbnN0IGNhbGxiYWNrID0gcmVuZGVyX2NhbGxiYWNrc1tpXTtcblx0XHRcdGlmICghc2Vlbl9jYWxsYmFja3MuaGFzKGNhbGxiYWNrKSkge1xuXHRcdFx0XHQvLyAuLi5zbyBndWFyZCBhZ2FpbnN0IGluZmluaXRlIGxvb3BzXG5cdFx0XHRcdHNlZW5fY2FsbGJhY2tzLmFkZChjYWxsYmFjayk7XG5cdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJlbmRlcl9jYWxsYmFja3MubGVuZ3RoID0gMDtcblx0fSB3aGlsZSAoZGlydHlfY29tcG9uZW50cy5sZW5ndGgpO1xuXHR3aGlsZSAoZmx1c2hfY2FsbGJhY2tzLmxlbmd0aCkge1xuXHRcdGZsdXNoX2NhbGxiYWNrcy5wb3AoKSgpO1xuXHR9XG5cdHVwZGF0ZV9zY2hlZHVsZWQgPSBmYWxzZTtcblx0c2Vlbl9jYWxsYmFja3MuY2xlYXIoKTtcblx0c2V0X2N1cnJlbnRfY29tcG9uZW50KHNhdmVkX2NvbXBvbmVudCk7XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmZ1bmN0aW9uIHVwZGF0ZSgkJCkge1xuXHRpZiAoJCQuZnJhZ21lbnQgIT09IG51bGwpIHtcblx0XHQkJC51cGRhdGUoKTtcblx0XHRydW5fYWxsKCQkLmJlZm9yZV91cGRhdGUpO1xuXHRcdGNvbnN0IGRpcnR5ID0gJCQuZGlydHk7XG5cdFx0JCQuZGlydHkgPSBbLTFdO1xuXHRcdCQkLmZyYWdtZW50ICYmICQkLmZyYWdtZW50LnAoJCQuY3R4LCBkaXJ0eSk7XG5cdFx0JCQuYWZ0ZXJfdXBkYXRlLmZvckVhY2goYWRkX3JlbmRlcl9jYWxsYmFjayk7XG5cdH1cbn1cblxuLyoqXG4gKiBVc2VmdWwgZm9yIGV4YW1wbGUgdG8gZXhlY3V0ZSByZW1haW5pbmcgYGFmdGVyVXBkYXRlYCBjYWxsYmFja3MgYmVmb3JlIGV4ZWN1dGluZyBgZGVzdHJveWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9uW119IGZuc1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmbHVzaF9yZW5kZXJfY2FsbGJhY2tzKGZucykge1xuXHRjb25zdCBmaWx0ZXJlZCA9IFtdO1xuXHRjb25zdCB0YXJnZXRzID0gW107XG5cdHJlbmRlcl9jYWxsYmFja3MuZm9yRWFjaCgoYykgPT4gKGZucy5pbmRleE9mKGMpID09PSAtMSA/IGZpbHRlcmVkLnB1c2goYykgOiB0YXJnZXRzLnB1c2goYykpKTtcblx0dGFyZ2V0cy5mb3JFYWNoKChjKSA9PiBjKCkpO1xuXHRyZW5kZXJfY2FsbGJhY2tzID0gZmlsdGVyZWQ7XG59XG4iLCAiaW1wb3J0IHsgaWRlbnRpdHkgYXMgbGluZWFyLCBpc19mdW5jdGlvbiwgbm9vcCwgcnVuX2FsbCB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgbm93IH0gZnJvbSAnLi9lbnZpcm9ubWVudC5qcyc7XG5pbXBvcnQgeyBsb29wIH0gZnJvbSAnLi9sb29wLmpzJztcbmltcG9ydCB7IGNyZWF0ZV9ydWxlLCBkZWxldGVfcnVsZSB9IGZyb20gJy4vc3R5bGVfbWFuYWdlci5qcyc7XG5pbXBvcnQgeyBjdXN0b21fZXZlbnQgfSBmcm9tICcuL2RvbS5qcyc7XG5pbXBvcnQgeyBhZGRfcmVuZGVyX2NhbGxiYWNrIH0gZnJvbSAnLi9zY2hlZHVsZXIuanMnO1xuXG4vKipcbiAqIEB0eXBlIHtQcm9taXNlPHZvaWQ+IHwgbnVsbH1cbiAqL1xubGV0IHByb21pc2U7XG5cbi8qKlxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gKi9cbmZ1bmN0aW9uIHdhaXQoKSB7XG5cdGlmICghcHJvbWlzZSkge1xuXHRcdHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcblx0XHRwcm9taXNlLnRoZW4oKCkgPT4ge1xuXHRcdFx0cHJvbWlzZSA9IG51bGw7XG5cdFx0fSk7XG5cdH1cblx0cmV0dXJuIHByb21pc2U7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge0lOVFJPIHwgT1VUUk8gfCBib29sZWFufSBkaXJlY3Rpb25cbiAqIEBwYXJhbSB7J3N0YXJ0JyB8ICdlbmQnfSBraW5kXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gZGlzcGF0Y2gobm9kZSwgZGlyZWN0aW9uLCBraW5kKSB7XG5cdG5vZGUuZGlzcGF0Y2hFdmVudChjdXN0b21fZXZlbnQoYCR7ZGlyZWN0aW9uID8gJ2ludHJvJyA6ICdvdXRybyd9JHtraW5kfWApKTtcbn1cblxuY29uc3Qgb3V0cm9pbmcgPSBuZXcgU2V0KCk7XG5cbi8qKlxuICogQHR5cGUge091dHJvfVxuICovXG5sZXQgb3V0cm9zO1xuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdyb3VwX291dHJvcygpIHtcblx0b3V0cm9zID0ge1xuXHRcdHI6IDAsXG5cdFx0YzogW10sXG5cdFx0cDogb3V0cm9zIC8vIHBhcmVudCBncm91cFxuXHR9O1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrX291dHJvcygpIHtcblx0aWYgKCFvdXRyb3Mucikge1xuXHRcdHJ1bl9hbGwob3V0cm9zLmMpO1xuXHR9XG5cdG91dHJvcyA9IG91dHJvcy5wO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3ByaXZhdGUuanMnKS5GcmFnbWVudH0gYmxvY2tcbiAqIEBwYXJhbSB7MCB8IDF9IFtsb2NhbF1cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNpdGlvbl9pbihibG9jaywgbG9jYWwpIHtcblx0aWYgKGJsb2NrICYmIGJsb2NrLmkpIHtcblx0XHRvdXRyb2luZy5kZWxldGUoYmxvY2spO1xuXHRcdGJsb2NrLmkobG9jYWwpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLkZyYWdtZW50fSBibG9ja1xuICogQHBhcmFtIHswIHwgMX0gbG9jYWxcbiAqIEBwYXJhbSB7MCB8IDF9IFtkZXRhY2hdXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IFtjYWxsYmFja11cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNpdGlvbl9vdXQoYmxvY2ssIGxvY2FsLCBkZXRhY2gsIGNhbGxiYWNrKSB7XG5cdGlmIChibG9jayAmJiBibG9jay5vKSB7XG5cdFx0aWYgKG91dHJvaW5nLmhhcyhibG9jaykpIHJldHVybjtcblx0XHRvdXRyb2luZy5hZGQoYmxvY2spO1xuXHRcdG91dHJvcy5jLnB1c2goKCkgPT4ge1xuXHRcdFx0b3V0cm9pbmcuZGVsZXRlKGJsb2NrKTtcblx0XHRcdGlmIChjYWxsYmFjaykge1xuXHRcdFx0XHRpZiAoZGV0YWNoKSBibG9jay5kKDEpO1xuXHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdGJsb2NrLm8obG9jYWwpO1xuXHR9IGVsc2UgaWYgKGNhbGxiYWNrKSB7XG5cdFx0Y2FsbGJhY2soKTtcblx0fVxufVxuXG4vKipcbiAqIEB0eXBlIHtpbXBvcnQoJy4uL3RyYW5zaXRpb24vcHVibGljLmpzJykuVHJhbnNpdGlvbkNvbmZpZ31cbiAqL1xuY29uc3QgbnVsbF90cmFuc2l0aW9uID0geyBkdXJhdGlvbjogMCB9O1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudCAmIEVsZW1lbnRDU1NJbmxpbmVTdHlsZX0gbm9kZVxuICogQHBhcmFtIHtUcmFuc2l0aW9uRm59IGZuXG4gKiBAcGFyYW0ge2FueX0gcGFyYW1zXG4gKiBAcmV0dXJucyB7eyBzdGFydCgpOiB2b2lkOyBpbnZhbGlkYXRlKCk6IHZvaWQ7IGVuZCgpOiB2b2lkOyB9fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlX2luX3RyYW5zaXRpb24obm9kZSwgZm4sIHBhcmFtcykge1xuXHQvKipcblx0ICogQHR5cGUge1RyYW5zaXRpb25PcHRpb25zfSAqL1xuXHRjb25zdCBvcHRpb25zID0geyBkaXJlY3Rpb246ICdpbicgfTtcblx0bGV0IGNvbmZpZyA9IGZuKG5vZGUsIHBhcmFtcywgb3B0aW9ucyk7XG5cdGxldCBydW5uaW5nID0gZmFsc2U7XG5cdGxldCBhbmltYXRpb25fbmFtZTtcblx0bGV0IHRhc2s7XG5cdGxldCB1aWQgPSAwO1xuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7dm9pZH0gKi9cblx0ZnVuY3Rpb24gY2xlYW51cCgpIHtcblx0XHRpZiAoYW5pbWF0aW9uX25hbWUpIGRlbGV0ZV9ydWxlKG5vZGUsIGFuaW1hdGlvbl9uYW1lKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7dm9pZH0gKi9cblx0ZnVuY3Rpb24gZ28oKSB7XG5cdFx0Y29uc3Qge1xuXHRcdFx0ZGVsYXkgPSAwLFxuXHRcdFx0ZHVyYXRpb24gPSAzMDAsXG5cdFx0XHRlYXNpbmcgPSBsaW5lYXIsXG5cdFx0XHR0aWNrID0gbm9vcCxcblx0XHRcdGNzc1xuXHRcdH0gPSBjb25maWcgfHwgbnVsbF90cmFuc2l0aW9uO1xuXHRcdGlmIChjc3MpIGFuaW1hdGlvbl9uYW1lID0gY3JlYXRlX3J1bGUobm9kZSwgMCwgMSwgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcsIGNzcywgdWlkKyspO1xuXHRcdHRpY2soMCwgMSk7XG5cdFx0Y29uc3Qgc3RhcnRfdGltZSA9IG5vdygpICsgZGVsYXk7XG5cdFx0Y29uc3QgZW5kX3RpbWUgPSBzdGFydF90aW1lICsgZHVyYXRpb247XG5cdFx0aWYgKHRhc2spIHRhc2suYWJvcnQoKTtcblx0XHRydW5uaW5nID0gdHJ1ZTtcblx0XHRhZGRfcmVuZGVyX2NhbGxiYWNrKCgpID0+IGRpc3BhdGNoKG5vZGUsIHRydWUsICdzdGFydCcpKTtcblx0XHR0YXNrID0gbG9vcCgobm93KSA9PiB7XG5cdFx0XHRpZiAocnVubmluZykge1xuXHRcdFx0XHRpZiAobm93ID49IGVuZF90aW1lKSB7XG5cdFx0XHRcdFx0dGljaygxLCAwKTtcblx0XHRcdFx0XHRkaXNwYXRjaChub2RlLCB0cnVlLCAnZW5kJyk7XG5cdFx0XHRcdFx0Y2xlYW51cCgpO1xuXHRcdFx0XHRcdHJldHVybiAocnVubmluZyA9IGZhbHNlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobm93ID49IHN0YXJ0X3RpbWUpIHtcblx0XHRcdFx0XHRjb25zdCB0ID0gZWFzaW5nKChub3cgLSBzdGFydF90aW1lKSAvIGR1cmF0aW9uKTtcblx0XHRcdFx0XHR0aWNrKHQsIDEgLSB0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJ1bm5pbmc7XG5cdFx0fSk7XG5cdH1cblx0bGV0IHN0YXJ0ZWQgPSBmYWxzZTtcblx0cmV0dXJuIHtcblx0XHRzdGFydCgpIHtcblx0XHRcdGlmIChzdGFydGVkKSByZXR1cm47XG5cdFx0XHRzdGFydGVkID0gdHJ1ZTtcblx0XHRcdGRlbGV0ZV9ydWxlKG5vZGUpO1xuXHRcdFx0aWYgKGlzX2Z1bmN0aW9uKGNvbmZpZykpIHtcblx0XHRcdFx0Y29uZmlnID0gY29uZmlnKG9wdGlvbnMpO1xuXHRcdFx0XHR3YWl0KCkudGhlbihnbyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRnbygpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0aW52YWxpZGF0ZSgpIHtcblx0XHRcdHN0YXJ0ZWQgPSBmYWxzZTtcblx0XHR9LFxuXHRcdGVuZCgpIHtcblx0XHRcdGlmIChydW5uaW5nKSB7XG5cdFx0XHRcdGNsZWFudXAoKTtcblx0XHRcdFx0cnVubmluZyA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnQgJiBFbGVtZW50Q1NTSW5saW5lU3R5bGV9IG5vZGVcbiAqIEBwYXJhbSB7VHJhbnNpdGlvbkZufSBmblxuICogQHBhcmFtIHthbnl9IHBhcmFtc1xuICogQHJldHVybnMge3sgZW5kKHJlc2V0OiBhbnkpOiB2b2lkOyB9fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlX291dF90cmFuc2l0aW9uKG5vZGUsIGZuLCBwYXJhbXMpIHtcblx0LyoqIEB0eXBlIHtUcmFuc2l0aW9uT3B0aW9uc30gKi9cblx0Y29uc3Qgb3B0aW9ucyA9IHsgZGlyZWN0aW9uOiAnb3V0JyB9O1xuXHRsZXQgY29uZmlnID0gZm4obm9kZSwgcGFyYW1zLCBvcHRpb25zKTtcblx0bGV0IHJ1bm5pbmcgPSB0cnVlO1xuXHRsZXQgYW5pbWF0aW9uX25hbWU7XG5cdGNvbnN0IGdyb3VwID0gb3V0cm9zO1xuXHRncm91cC5yICs9IDE7XG5cdC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cblx0bGV0IG9yaWdpbmFsX2luZXJ0X3ZhbHVlO1xuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7dm9pZH0gKi9cblx0ZnVuY3Rpb24gZ28oKSB7XG5cdFx0Y29uc3Qge1xuXHRcdFx0ZGVsYXkgPSAwLFxuXHRcdFx0ZHVyYXRpb24gPSAzMDAsXG5cdFx0XHRlYXNpbmcgPSBsaW5lYXIsXG5cdFx0XHR0aWNrID0gbm9vcCxcblx0XHRcdGNzc1xuXHRcdH0gPSBjb25maWcgfHwgbnVsbF90cmFuc2l0aW9uO1xuXG5cdFx0aWYgKGNzcykgYW5pbWF0aW9uX25hbWUgPSBjcmVhdGVfcnVsZShub2RlLCAxLCAwLCBkdXJhdGlvbiwgZGVsYXksIGVhc2luZywgY3NzKTtcblxuXHRcdGNvbnN0IHN0YXJ0X3RpbWUgPSBub3coKSArIGRlbGF5O1xuXHRcdGNvbnN0IGVuZF90aW1lID0gc3RhcnRfdGltZSArIGR1cmF0aW9uO1xuXHRcdGFkZF9yZW5kZXJfY2FsbGJhY2soKCkgPT4gZGlzcGF0Y2gobm9kZSwgZmFsc2UsICdzdGFydCcpKTtcblxuXHRcdGlmICgnaW5lcnQnIGluIG5vZGUpIHtcblx0XHRcdG9yaWdpbmFsX2luZXJ0X3ZhbHVlID0gLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8gKG5vZGUpLmluZXJ0O1xuXHRcdFx0bm9kZS5pbmVydCA9IHRydWU7XG5cdFx0fVxuXG5cdFx0bG9vcCgobm93KSA9PiB7XG5cdFx0XHRpZiAocnVubmluZykge1xuXHRcdFx0XHRpZiAobm93ID49IGVuZF90aW1lKSB7XG5cdFx0XHRcdFx0dGljaygwLCAxKTtcblx0XHRcdFx0XHRkaXNwYXRjaChub2RlLCBmYWxzZSwgJ2VuZCcpO1xuXHRcdFx0XHRcdGlmICghLS1ncm91cC5yKSB7XG5cdFx0XHRcdFx0XHQvLyB0aGlzIHdpbGwgcmVzdWx0IGluIGBlbmQoKWAgYmVpbmcgY2FsbGVkLFxuXHRcdFx0XHRcdFx0Ly8gc28gd2UgZG9uJ3QgbmVlZCB0byBjbGVhbiB1cCBoZXJlXG5cdFx0XHRcdFx0XHRydW5fYWxsKGdyb3VwLmMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG5vdyA+PSBzdGFydF90aW1lKSB7XG5cdFx0XHRcdFx0Y29uc3QgdCA9IGVhc2luZygobm93IC0gc3RhcnRfdGltZSkgLyBkdXJhdGlvbik7XG5cdFx0XHRcdFx0dGljaygxIC0gdCwgdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBydW5uaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0aWYgKGlzX2Z1bmN0aW9uKGNvbmZpZykpIHtcblx0XHR3YWl0KCkudGhlbigoKSA9PiB7XG5cdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRjb25maWcgPSBjb25maWcob3B0aW9ucyk7XG5cdFx0XHRnbygpO1xuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdGdvKCk7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdGVuZChyZXNldCkge1xuXHRcdFx0aWYgKHJlc2V0ICYmICdpbmVydCcgaW4gbm9kZSkge1xuXHRcdFx0XHRub2RlLmluZXJ0ID0gb3JpZ2luYWxfaW5lcnRfdmFsdWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAocmVzZXQgJiYgY29uZmlnLnRpY2spIHtcblx0XHRcdFx0Y29uZmlnLnRpY2soMSwgMCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAocnVubmluZykge1xuXHRcdFx0XHRpZiAoYW5pbWF0aW9uX25hbWUpIGRlbGV0ZV9ydWxlKG5vZGUsIGFuaW1hdGlvbl9uYW1lKTtcblx0XHRcdFx0cnVubmluZyA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnQgJiBFbGVtZW50Q1NTSW5saW5lU3R5bGV9IG5vZGVcbiAqIEBwYXJhbSB7VHJhbnNpdGlvbkZufSBmblxuICogQHBhcmFtIHthbnl9IHBhcmFtc1xuICogQHBhcmFtIHtib29sZWFufSBpbnRyb1xuICogQHJldHVybnMge3sgcnVuKGI6IDAgfCAxKTogdm9pZDsgZW5kKCk6IHZvaWQ7IH19XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVfYmlkaXJlY3Rpb25hbF90cmFuc2l0aW9uKG5vZGUsIGZuLCBwYXJhbXMsIGludHJvKSB7XG5cdC8qKlxuXHQgKiBAdHlwZSB7VHJhbnNpdGlvbk9wdGlvbnN9ICovXG5cdGNvbnN0IG9wdGlvbnMgPSB7IGRpcmVjdGlvbjogJ2JvdGgnIH07XG5cdGxldCBjb25maWcgPSBmbihub2RlLCBwYXJhbXMsIG9wdGlvbnMpO1xuXHRsZXQgdCA9IGludHJvID8gMCA6IDE7XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtQcm9ncmFtIHwgbnVsbH0gKi9cblx0bGV0IHJ1bm5pbmdfcHJvZ3JhbSA9IG51bGw7XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtQZW5kaW5nUHJvZ3JhbSB8IG51bGx9ICovXG5cdGxldCBwZW5kaW5nX3Byb2dyYW0gPSBudWxsO1xuXHRsZXQgYW5pbWF0aW9uX25hbWUgPSBudWxsO1xuXG5cdC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cblx0bGV0IG9yaWdpbmFsX2luZXJ0X3ZhbHVlO1xuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7dm9pZH0gKi9cblx0ZnVuY3Rpb24gY2xlYXJfYW5pbWF0aW9uKCkge1xuXHRcdGlmIChhbmltYXRpb25fbmFtZSkgZGVsZXRlX3J1bGUobm9kZSwgYW5pbWF0aW9uX25hbWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7UGVuZGluZ1Byb2dyYW19IHByb2dyYW1cblx0ICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uXG5cdCAqIEByZXR1cm5zIHtQcm9ncmFtfVxuXHQgKi9cblx0ZnVuY3Rpb24gaW5pdChwcm9ncmFtLCBkdXJhdGlvbikge1xuXHRcdGNvbnN0IGQgPSAvKiogQHR5cGUge1Byb2dyYW1bJ2QnXX0gKi8gKHByb2dyYW0uYiAtIHQpO1xuXHRcdGR1cmF0aW9uICo9IE1hdGguYWJzKGQpO1xuXHRcdHJldHVybiB7XG5cdFx0XHRhOiB0LFxuXHRcdFx0YjogcHJvZ3JhbS5iLFxuXHRcdFx0ZCxcblx0XHRcdGR1cmF0aW9uLFxuXHRcdFx0c3RhcnQ6IHByb2dyYW0uc3RhcnQsXG5cdFx0XHRlbmQ6IHByb2dyYW0uc3RhcnQgKyBkdXJhdGlvbixcblx0XHRcdGdyb3VwOiBwcm9ncmFtLmdyb3VwXG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0lOVFJPIHwgT1VUUk99IGJcblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRmdW5jdGlvbiBnbyhiKSB7XG5cdFx0Y29uc3Qge1xuXHRcdFx0ZGVsYXkgPSAwLFxuXHRcdFx0ZHVyYXRpb24gPSAzMDAsXG5cdFx0XHRlYXNpbmcgPSBsaW5lYXIsXG5cdFx0XHR0aWNrID0gbm9vcCxcblx0XHRcdGNzc1xuXHRcdH0gPSBjb25maWcgfHwgbnVsbF90cmFuc2l0aW9uO1xuXG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge1BlbmRpbmdQcm9ncmFtfSAqL1xuXHRcdGNvbnN0IHByb2dyYW0gPSB7XG5cdFx0XHRzdGFydDogbm93KCkgKyBkZWxheSxcblx0XHRcdGJcblx0XHR9O1xuXG5cdFx0aWYgKCFiKSB7XG5cdFx0XHQvLyBAdHMtaWdub3JlIHRvZG86IGltcHJvdmUgdHlwaW5nc1xuXHRcdFx0cHJvZ3JhbS5ncm91cCA9IG91dHJvcztcblx0XHRcdG91dHJvcy5yICs9IDE7XG5cdFx0fVxuXG5cdFx0aWYgKCdpbmVydCcgaW4gbm9kZSkge1xuXHRcdFx0aWYgKGIpIHtcblx0XHRcdFx0aWYgKG9yaWdpbmFsX2luZXJ0X3ZhbHVlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHQvLyBhYm9ydGVkL3JldmVyc2VkIG91dHJvIFx1MjAxNCByZXN0b3JlIHByZXZpb3VzIGluZXJ0IHZhbHVlXG5cdFx0XHRcdFx0bm9kZS5pbmVydCA9IG9yaWdpbmFsX2luZXJ0X3ZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvcmlnaW5hbF9pbmVydF92YWx1ZSA9IC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovIChub2RlKS5pbmVydDtcblx0XHRcdFx0bm9kZS5pbmVydCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHJ1bm5pbmdfcHJvZ3JhbSB8fCBwZW5kaW5nX3Byb2dyYW0pIHtcblx0XHRcdHBlbmRpbmdfcHJvZ3JhbSA9IHByb2dyYW07XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGlmIHRoaXMgaXMgYW4gaW50cm8sIGFuZCB0aGVyZSdzIGEgZGVsYXksIHdlIG5lZWQgdG8gZG9cblx0XHRcdC8vIGFuIGluaXRpYWwgdGljayBhbmQvb3IgYXBwbHkgQ1NTIGFuaW1hdGlvbiBpbW1lZGlhdGVseVxuXHRcdFx0aWYgKGNzcykge1xuXHRcdFx0XHRjbGVhcl9hbmltYXRpb24oKTtcblx0XHRcdFx0YW5pbWF0aW9uX25hbWUgPSBjcmVhdGVfcnVsZShub2RlLCB0LCBiLCBkdXJhdGlvbiwgZGVsYXksIGVhc2luZywgY3NzKTtcblx0XHRcdH1cblx0XHRcdGlmIChiKSB0aWNrKDAsIDEpO1xuXHRcdFx0cnVubmluZ19wcm9ncmFtID0gaW5pdChwcm9ncmFtLCBkdXJhdGlvbik7XG5cdFx0XHRhZGRfcmVuZGVyX2NhbGxiYWNrKCgpID0+IGRpc3BhdGNoKG5vZGUsIGIsICdzdGFydCcpKTtcblx0XHRcdGxvb3AoKG5vdykgPT4ge1xuXHRcdFx0XHRpZiAocGVuZGluZ19wcm9ncmFtICYmIG5vdyA+IHBlbmRpbmdfcHJvZ3JhbS5zdGFydCkge1xuXHRcdFx0XHRcdHJ1bm5pbmdfcHJvZ3JhbSA9IGluaXQocGVuZGluZ19wcm9ncmFtLCBkdXJhdGlvbik7XG5cdFx0XHRcdFx0cGVuZGluZ19wcm9ncmFtID0gbnVsbDtcblx0XHRcdFx0XHRkaXNwYXRjaChub2RlLCBydW5uaW5nX3Byb2dyYW0uYiwgJ3N0YXJ0Jyk7XG5cdFx0XHRcdFx0aWYgKGNzcykge1xuXHRcdFx0XHRcdFx0Y2xlYXJfYW5pbWF0aW9uKCk7XG5cdFx0XHRcdFx0XHRhbmltYXRpb25fbmFtZSA9IGNyZWF0ZV9ydWxlKFxuXHRcdFx0XHRcdFx0XHRub2RlLFxuXHRcdFx0XHRcdFx0XHR0LFxuXHRcdFx0XHRcdFx0XHRydW5uaW5nX3Byb2dyYW0uYixcblx0XHRcdFx0XHRcdFx0cnVubmluZ19wcm9ncmFtLmR1cmF0aW9uLFxuXHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRlYXNpbmcsXG5cdFx0XHRcdFx0XHRcdGNvbmZpZy5jc3Ncblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChydW5uaW5nX3Byb2dyYW0pIHtcblx0XHRcdFx0XHRpZiAobm93ID49IHJ1bm5pbmdfcHJvZ3JhbS5lbmQpIHtcblx0XHRcdFx0XHRcdHRpY2soKHQgPSBydW5uaW5nX3Byb2dyYW0uYiksIDEgLSB0KTtcblx0XHRcdFx0XHRcdGRpc3BhdGNoKG5vZGUsIHJ1bm5pbmdfcHJvZ3JhbS5iLCAnZW5kJyk7XG5cdFx0XHRcdFx0XHRpZiAoIXBlbmRpbmdfcHJvZ3JhbSkge1xuXHRcdFx0XHRcdFx0XHQvLyB3ZSdyZSBkb25lXG5cdFx0XHRcdFx0XHRcdGlmIChydW5uaW5nX3Byb2dyYW0uYikge1xuXHRcdFx0XHRcdFx0XHRcdC8vIGludHJvIFx1MjAxNCB3ZSBjYW4gdGlkeSB1cCBpbW1lZGlhdGVseVxuXHRcdFx0XHRcdFx0XHRcdGNsZWFyX2FuaW1hdGlvbigpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdC8vIG91dHJvIFx1MjAxNCBuZWVkcyB0byBiZSBjb29yZGluYXRlZFxuXHRcdFx0XHRcdFx0XHRcdGlmICghLS1ydW5uaW5nX3Byb2dyYW0uZ3JvdXAucikgcnVuX2FsbChydW5uaW5nX3Byb2dyYW0uZ3JvdXAuYyk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJ1bm5pbmdfcHJvZ3JhbSA9IG51bGw7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChub3cgPj0gcnVubmluZ19wcm9ncmFtLnN0YXJ0KSB7XG5cdFx0XHRcdFx0XHRjb25zdCBwID0gbm93IC0gcnVubmluZ19wcm9ncmFtLnN0YXJ0O1xuXHRcdFx0XHRcdFx0dCA9IHJ1bm5pbmdfcHJvZ3JhbS5hICsgcnVubmluZ19wcm9ncmFtLmQgKiBlYXNpbmcocCAvIHJ1bm5pbmdfcHJvZ3JhbS5kdXJhdGlvbik7XG5cdFx0XHRcdFx0XHR0aWNrKHQsIDEgLSB0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuICEhKHJ1bm5pbmdfcHJvZ3JhbSB8fCBwZW5kaW5nX3Byb2dyYW0pO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiB7XG5cdFx0cnVuKGIpIHtcblx0XHRcdGlmIChpc19mdW5jdGlvbihjb25maWcpKSB7XG5cdFx0XHRcdHdhaXQoKS50aGVuKCgpID0+IHtcblx0XHRcdFx0XHRjb25zdCBvcHRzID0geyBkaXJlY3Rpb246IGIgPyAnaW4nIDogJ291dCcgfTtcblx0XHRcdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRcdFx0Y29uZmlnID0gY29uZmlnKG9wdHMpO1xuXHRcdFx0XHRcdGdvKGIpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGdvKGIpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZW5kKCkge1xuXHRcdFx0Y2xlYXJfYW5pbWF0aW9uKCk7XG5cdFx0XHRydW5uaW5nX3Byb2dyYW0gPSBwZW5kaW5nX3Byb2dyYW0gPSBudWxsO1xuXHRcdH1cblx0fTtcbn1cblxuLyoqIEB0eXBlZGVmIHsxfSBJTlRSTyAqL1xuLyoqIEB0eXBlZGVmIHswfSBPVVRSTyAqL1xuLyoqIEB0eXBlZGVmIHt7IGRpcmVjdGlvbjogJ2luJyB8ICdvdXQnIHwgJ2JvdGgnIH19IFRyYW5zaXRpb25PcHRpb25zICovXG4vKiogQHR5cGVkZWYgeyhub2RlOiBFbGVtZW50LCBwYXJhbXM6IGFueSwgb3B0aW9uczogVHJhbnNpdGlvbk9wdGlvbnMpID0+IGltcG9ydCgnLi4vdHJhbnNpdGlvbi9wdWJsaWMuanMnKS5UcmFuc2l0aW9uQ29uZmlnfSBUcmFuc2l0aW9uRm4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPdXRyb1xuICogQHByb3BlcnR5IHtudW1iZXJ9IHJcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb25bXX0gY1xuICogQHByb3BlcnR5IHtPYmplY3R9IHBcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFBlbmRpbmdQcm9ncmFtXG4gKiBAcHJvcGVydHkge251bWJlcn0gc3RhcnRcbiAqIEBwcm9wZXJ0eSB7SU5UUk98T1VUUk99IGJcbiAqIEBwcm9wZXJ0eSB7T3V0cm99IFtncm91cF1cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFByb2dyYW1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBhXG4gKiBAcHJvcGVydHkge0lOVFJPfE9VVFJPfSBiXG4gKiBAcHJvcGVydHkgezF8LTF9IGRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkdXJhdGlvblxuICogQHByb3BlcnR5IHtudW1iZXJ9IHN0YXJ0XG4gKiBAcHJvcGVydHkge251bWJlcn0gZW5kXG4gKiBAcHJvcGVydHkge091dHJvfSBbZ3JvdXBdXG4gKi9cbiIsICJpbXBvcnQgeyB0cmFuc2l0aW9uX2luLCB0cmFuc2l0aW9uX291dCB9IGZyb20gJy4vdHJhbnNpdGlvbnMuanMnO1xuaW1wb3J0IHsgcnVuX2FsbCB9IGZyb20gJy4vdXRpbHMuanMnO1xuXG4vLyBnZW5lcmFsIGVhY2ggZnVuY3Rpb25zOlxuXG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlX2FycmF5X2xpa2UoYXJyYXlfbGlrZV9vcl9pdGVyYXRvcikge1xuXHRyZXR1cm4gYXJyYXlfbGlrZV9vcl9pdGVyYXRvcj8ubGVuZ3RoICE9PSB1bmRlZmluZWRcblx0XHQ/IGFycmF5X2xpa2Vfb3JfaXRlcmF0b3Jcblx0XHQ6IEFycmF5LmZyb20oYXJyYXlfbGlrZV9vcl9pdGVyYXRvcik7XG59XG5cbi8vIGtleWVkIGVhY2ggZnVuY3Rpb25zOlxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKSB7XG5cdGJsb2NrLmQoMSk7XG5cdGxvb2t1cC5kZWxldGUoYmxvY2sua2V5KTtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIG91dHJvX2FuZF9kZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApIHtcblx0dHJhbnNpdGlvbl9vdXQoYmxvY2ssIDEsIDEsICgpID0+IHtcblx0XHRsb29rdXAuZGVsZXRlKGJsb2NrLmtleSk7XG5cdH0pO1xufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gZml4X2FuZF9kZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApIHtcblx0YmxvY2suZigpO1xuXHRkZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApO1xufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gZml4X2FuZF9vdXRyb19hbmRfZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKSB7XG5cdGJsb2NrLmYoKTtcblx0b3V0cm9fYW5kX2Rlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCk7XG59XG5cbi8qKiBAcmV0dXJucyB7YW55W119ICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlX2tleWVkX2VhY2goXG5cdG9sZF9ibG9ja3MsXG5cdGRpcnR5LFxuXHRnZXRfa2V5LFxuXHRkeW5hbWljLFxuXHRjdHgsXG5cdGxpc3QsXG5cdGxvb2t1cCxcblx0bm9kZSxcblx0ZGVzdHJveSxcblx0Y3JlYXRlX2VhY2hfYmxvY2ssXG5cdG5leHQsXG5cdGdldF9jb250ZXh0XG4pIHtcblx0bGV0IG8gPSBvbGRfYmxvY2tzLmxlbmd0aDtcblx0bGV0IG4gPSBsaXN0Lmxlbmd0aDtcblx0bGV0IGkgPSBvO1xuXHRjb25zdCBvbGRfaW5kZXhlcyA9IHt9O1xuXHR3aGlsZSAoaS0tKSBvbGRfaW5kZXhlc1tvbGRfYmxvY2tzW2ldLmtleV0gPSBpO1xuXHRjb25zdCBuZXdfYmxvY2tzID0gW107XG5cdGNvbnN0IG5ld19sb29rdXAgPSBuZXcgTWFwKCk7XG5cdGNvbnN0IGRlbHRhcyA9IG5ldyBNYXAoKTtcblx0Y29uc3QgdXBkYXRlcyA9IFtdO1xuXHRpID0gbjtcblx0d2hpbGUgKGktLSkge1xuXHRcdGNvbnN0IGNoaWxkX2N0eCA9IGdldF9jb250ZXh0KGN0eCwgbGlzdCwgaSk7XG5cdFx0Y29uc3Qga2V5ID0gZ2V0X2tleShjaGlsZF9jdHgpO1xuXHRcdGxldCBibG9jayA9IGxvb2t1cC5nZXQoa2V5KTtcblx0XHRpZiAoIWJsb2NrKSB7XG5cdFx0XHRibG9jayA9IGNyZWF0ZV9lYWNoX2Jsb2NrKGtleSwgY2hpbGRfY3R4KTtcblx0XHRcdGJsb2NrLmMoKTtcblx0XHR9IGVsc2UgaWYgKGR5bmFtaWMpIHtcblx0XHRcdC8vIGRlZmVyIHVwZGF0ZXMgdW50aWwgYWxsIHRoZSBET00gc2h1ZmZsaW5nIGlzIGRvbmVcblx0XHRcdHVwZGF0ZXMucHVzaCgoKSA9PiBibG9jay5wKGNoaWxkX2N0eCwgZGlydHkpKTtcblx0XHR9XG5cdFx0bmV3X2xvb2t1cC5zZXQoa2V5LCAobmV3X2Jsb2Nrc1tpXSA9IGJsb2NrKSk7XG5cdFx0aWYgKGtleSBpbiBvbGRfaW5kZXhlcykgZGVsdGFzLnNldChrZXksIE1hdGguYWJzKGkgLSBvbGRfaW5kZXhlc1trZXldKSk7XG5cdH1cblx0Y29uc3Qgd2lsbF9tb3ZlID0gbmV3IFNldCgpO1xuXHRjb25zdCBkaWRfbW92ZSA9IG5ldyBTZXQoKTtcblx0LyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuXHRmdW5jdGlvbiBpbnNlcnQoYmxvY2spIHtcblx0XHR0cmFuc2l0aW9uX2luKGJsb2NrLCAxKTtcblx0XHRibG9jay5tKG5vZGUsIG5leHQpO1xuXHRcdGxvb2t1cC5zZXQoYmxvY2sua2V5LCBibG9jayk7XG5cdFx0bmV4dCA9IGJsb2NrLmZpcnN0O1xuXHRcdG4tLTtcblx0fVxuXHR3aGlsZSAobyAmJiBuKSB7XG5cdFx0Y29uc3QgbmV3X2Jsb2NrID0gbmV3X2Jsb2Nrc1tuIC0gMV07XG5cdFx0Y29uc3Qgb2xkX2Jsb2NrID0gb2xkX2Jsb2Nrc1tvIC0gMV07XG5cdFx0Y29uc3QgbmV3X2tleSA9IG5ld19ibG9jay5rZXk7XG5cdFx0Y29uc3Qgb2xkX2tleSA9IG9sZF9ibG9jay5rZXk7XG5cdFx0aWYgKG5ld19ibG9jayA9PT0gb2xkX2Jsb2NrKSB7XG5cdFx0XHQvLyBkbyBub3RoaW5nXG5cdFx0XHRuZXh0ID0gbmV3X2Jsb2NrLmZpcnN0O1xuXHRcdFx0by0tO1xuXHRcdFx0bi0tO1xuXHRcdH0gZWxzZSBpZiAoIW5ld19sb29rdXAuaGFzKG9sZF9rZXkpKSB7XG5cdFx0XHQvLyByZW1vdmUgb2xkIGJsb2NrXG5cdFx0XHRkZXN0cm95KG9sZF9ibG9jaywgbG9va3VwKTtcblx0XHRcdG8tLTtcblx0XHR9IGVsc2UgaWYgKCFsb29rdXAuaGFzKG5ld19rZXkpIHx8IHdpbGxfbW92ZS5oYXMobmV3X2tleSkpIHtcblx0XHRcdGluc2VydChuZXdfYmxvY2spO1xuXHRcdH0gZWxzZSBpZiAoZGlkX21vdmUuaGFzKG9sZF9rZXkpKSB7XG5cdFx0XHRvLS07XG5cdFx0fSBlbHNlIGlmIChkZWx0YXMuZ2V0KG5ld19rZXkpID4gZGVsdGFzLmdldChvbGRfa2V5KSkge1xuXHRcdFx0ZGlkX21vdmUuYWRkKG5ld19rZXkpO1xuXHRcdFx0aW5zZXJ0KG5ld19ibG9jayk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHdpbGxfbW92ZS5hZGQob2xkX2tleSk7XG5cdFx0XHRvLS07XG5cdFx0fVxuXHR9XG5cdHdoaWxlIChvLS0pIHtcblx0XHRjb25zdCBvbGRfYmxvY2sgPSBvbGRfYmxvY2tzW29dO1xuXHRcdGlmICghbmV3X2xvb2t1cC5oYXMob2xkX2Jsb2NrLmtleSkpIGRlc3Ryb3kob2xkX2Jsb2NrLCBsb29rdXApO1xuXHR9XG5cdHdoaWxlIChuKSBpbnNlcnQobmV3X2Jsb2Nrc1tuIC0gMV0pO1xuXHRydW5fYWxsKHVwZGF0ZXMpO1xuXHRyZXR1cm4gbmV3X2Jsb2Nrcztcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlX2VhY2hfa2V5cyhjdHgsIGxpc3QsIGdldF9jb250ZXh0LCBnZXRfa2V5KSB7XG5cdGNvbnN0IGtleXMgPSBuZXcgTWFwKCk7XG5cdGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdGNvbnN0IGtleSA9IGdldF9rZXkoZ2V0X2NvbnRleHQoY3R4LCBsaXN0LCBpKSk7XG5cdFx0aWYgKGtleXMuaGFzKGtleSkpIHtcblx0XHRcdGxldCB2YWx1ZSA9ICcnO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dmFsdWUgPSBgd2l0aCB2YWx1ZSAnJHtTdHJpbmcoa2V5KX0nIGA7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdC8vIGNhbid0IHN0cmluZ2lmeVxuXHRcdFx0fVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRgQ2Fubm90IGhhdmUgZHVwbGljYXRlIGtleXMgaW4gYSBrZXllZCBlYWNoOiBLZXlzIGF0IGluZGV4ICR7a2V5cy5nZXQoXG5cdFx0XHRcdFx0a2V5XG5cdFx0XHRcdCl9IGFuZCAke2l9ICR7dmFsdWV9YXJlIGR1cGxpY2F0ZXNgXG5cdFx0XHQpO1xuXHRcdH1cblx0XHRrZXlzLnNldChrZXksIGkpO1xuXHR9XG59XG4iLCAiY29uc3QgX2Jvb2xlYW5fYXR0cmlidXRlcyA9IC8qKiBAdHlwZSB7Y29uc3R9ICovIChbXG5cdCdhbGxvd2Z1bGxzY3JlZW4nLFxuXHQnYWxsb3dwYXltZW50cmVxdWVzdCcsXG5cdCdhc3luYycsXG5cdCdhdXRvZm9jdXMnLFxuXHQnYXV0b3BsYXknLFxuXHQnY2hlY2tlZCcsXG5cdCdjb250cm9scycsXG5cdCdkZWZhdWx0Jyxcblx0J2RlZmVyJyxcblx0J2Rpc2FibGVkJyxcblx0J2Zvcm1ub3ZhbGlkYXRlJyxcblx0J2hpZGRlbicsXG5cdCdpbmVydCcsXG5cdCdpc21hcCcsXG5cdCdsb29wJyxcblx0J211bHRpcGxlJyxcblx0J211dGVkJyxcblx0J25vbW9kdWxlJyxcblx0J25vdmFsaWRhdGUnLFxuXHQnb3BlbicsXG5cdCdwbGF5c2lubGluZScsXG5cdCdyZWFkb25seScsXG5cdCdyZXF1aXJlZCcsXG5cdCdyZXZlcnNlZCcsXG5cdCdzZWxlY3RlZCdcbl0pO1xuXG4vKipcbiAqIExpc3Qgb2YgSFRNTCBib29sZWFuIGF0dHJpYnV0ZXMgKGUuZy4gYDxpbnB1dCBkaXNhYmxlZD5gKS5cbiAqIFNvdXJjZTogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5kaWNlcy5odG1sXG4gKlxuICogQHR5cGUge1NldDxzdHJpbmc+fVxuICovXG5leHBvcnQgY29uc3QgYm9vbGVhbl9hdHRyaWJ1dGVzID0gbmV3IFNldChbLi4uX2Jvb2xlYW5fYXR0cmlidXRlc10pO1xuXG4vKiogQHR5cGVkZWYge3R5cGVvZiBfYm9vbGVhbl9hdHRyaWJ1dGVzW251bWJlcl19IEJvb2xlYW5BdHRyaWJ1dGVzICovXG4iLCAiaW1wb3J0IHtcblx0YWRkX3JlbmRlcl9jYWxsYmFjayxcblx0Zmx1c2gsXG5cdGZsdXNoX3JlbmRlcl9jYWxsYmFja3MsXG5cdHNjaGVkdWxlX3VwZGF0ZSxcblx0ZGlydHlfY29tcG9uZW50c1xufSBmcm9tICcuL3NjaGVkdWxlci5qcyc7XG5pbXBvcnQgeyBjdXJyZW50X2NvbXBvbmVudCwgc2V0X2N1cnJlbnRfY29tcG9uZW50IH0gZnJvbSAnLi9saWZlY3ljbGUuanMnO1xuaW1wb3J0IHsgYmxhbmtfb2JqZWN0LCBpc19lbXB0eSwgaXNfZnVuY3Rpb24sIHJ1biwgcnVuX2FsbCwgbm9vcCB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHtcblx0Y2hpbGRyZW4sXG5cdGRldGFjaCxcblx0c3RhcnRfaHlkcmF0aW5nLFxuXHRlbmRfaHlkcmF0aW5nLFxuXHRnZXRfY3VzdG9tX2VsZW1lbnRzX3Nsb3RzLFxuXHRpbnNlcnQsXG5cdGVsZW1lbnQsXG5cdGF0dHJcbn0gZnJvbSAnLi9kb20uanMnO1xuaW1wb3J0IHsgdHJhbnNpdGlvbl9pbiB9IGZyb20gJy4vdHJhbnNpdGlvbnMuanMnO1xuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gYmluZChjb21wb25lbnQsIG5hbWUsIGNhbGxiYWNrKSB7XG5cdGNvbnN0IGluZGV4ID0gY29tcG9uZW50LiQkLnByb3BzW25hbWVdO1xuXHRpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuXHRcdGNvbXBvbmVudC4kJC5ib3VuZFtpbmRleF0gPSBjYWxsYmFjaztcblx0XHRjYWxsYmFjayhjb21wb25lbnQuJCQuY3R4W2luZGV4XSk7XG5cdH1cbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZV9jb21wb25lbnQoYmxvY2spIHtcblx0YmxvY2sgJiYgYmxvY2suYygpO1xufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gY2xhaW1fY29tcG9uZW50KGJsb2NrLCBwYXJlbnRfbm9kZXMpIHtcblx0YmxvY2sgJiYgYmxvY2subChwYXJlbnRfbm9kZXMpO1xufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gbW91bnRfY29tcG9uZW50KGNvbXBvbmVudCwgdGFyZ2V0LCBhbmNob3IpIHtcblx0Y29uc3QgeyBmcmFnbWVudCwgYWZ0ZXJfdXBkYXRlIH0gPSBjb21wb25lbnQuJCQ7XG5cdGZyYWdtZW50ICYmIGZyYWdtZW50Lm0odGFyZ2V0LCBhbmNob3IpO1xuXHQvLyBvbk1vdW50IGhhcHBlbnMgYmVmb3JlIHRoZSBpbml0aWFsIGFmdGVyVXBkYXRlXG5cdGFkZF9yZW5kZXJfY2FsbGJhY2soKCkgPT4ge1xuXHRcdGNvbnN0IG5ld19vbl9kZXN0cm95ID0gY29tcG9uZW50LiQkLm9uX21vdW50Lm1hcChydW4pLmZpbHRlcihpc19mdW5jdGlvbik7XG5cdFx0Ly8gaWYgdGhlIGNvbXBvbmVudCB3YXMgZGVzdHJveWVkIGltbWVkaWF0ZWx5XG5cdFx0Ly8gaXQgd2lsbCB1cGRhdGUgdGhlIGAkJC5vbl9kZXN0cm95YCByZWZlcmVuY2UgdG8gYG51bGxgLlxuXHRcdC8vIHRoZSBkZXN0cnVjdHVyZWQgb25fZGVzdHJveSBtYXkgc3RpbGwgcmVmZXJlbmNlIHRvIHRoZSBvbGQgYXJyYXlcblx0XHRpZiAoY29tcG9uZW50LiQkLm9uX2Rlc3Ryb3kpIHtcblx0XHRcdGNvbXBvbmVudC4kJC5vbl9kZXN0cm95LnB1c2goLi4ubmV3X29uX2Rlc3Ryb3kpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBFZGdlIGNhc2UgLSBjb21wb25lbnQgd2FzIGRlc3Ryb3llZCBpbW1lZGlhdGVseSxcblx0XHRcdC8vIG1vc3QgbGlrZWx5IGFzIGEgcmVzdWx0IG9mIGEgYmluZGluZyBpbml0aWFsaXNpbmdcblx0XHRcdHJ1bl9hbGwobmV3X29uX2Rlc3Ryb3kpO1xuXHRcdH1cblx0XHRjb21wb25lbnQuJCQub25fbW91bnQgPSBbXTtcblx0fSk7XG5cdGFmdGVyX3VwZGF0ZS5mb3JFYWNoKGFkZF9yZW5kZXJfY2FsbGJhY2spO1xufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gZGVzdHJveV9jb21wb25lbnQoY29tcG9uZW50LCBkZXRhY2hpbmcpIHtcblx0Y29uc3QgJCQgPSBjb21wb25lbnQuJCQ7XG5cdGlmICgkJC5mcmFnbWVudCAhPT0gbnVsbCkge1xuXHRcdGZsdXNoX3JlbmRlcl9jYWxsYmFja3MoJCQuYWZ0ZXJfdXBkYXRlKTtcblx0XHRydW5fYWxsKCQkLm9uX2Rlc3Ryb3kpO1xuXHRcdCQkLmZyYWdtZW50ICYmICQkLmZyYWdtZW50LmQoZGV0YWNoaW5nKTtcblx0XHQvLyBUT0RPIG51bGwgb3V0IG90aGVyIHJlZnMsIGluY2x1ZGluZyBjb21wb25lbnQuJCQgKGJ1dCBuZWVkIHRvXG5cdFx0Ly8gcHJlc2VydmUgZmluYWwgc3RhdGU/KVxuXHRcdCQkLm9uX2Rlc3Ryb3kgPSAkJC5mcmFnbWVudCA9IG51bGw7XG5cdFx0JCQuY3R4ID0gW107XG5cdH1cbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZnVuY3Rpb24gbWFrZV9kaXJ0eShjb21wb25lbnQsIGkpIHtcblx0aWYgKGNvbXBvbmVudC4kJC5kaXJ0eVswXSA9PT0gLTEpIHtcblx0XHRkaXJ0eV9jb21wb25lbnRzLnB1c2goY29tcG9uZW50KTtcblx0XHRzY2hlZHVsZV91cGRhdGUoKTtcblx0XHRjb21wb25lbnQuJCQuZGlydHkuZmlsbCgwKTtcblx0fVxuXHRjb21wb25lbnQuJCQuZGlydHlbKGkgLyAzMSkgfCAwXSB8PSAxIDw8IGkgJSAzMTtcbn1cblxuLy8gVE9ETzogRG9jdW1lbnQgdGhlIG90aGVyIHBhcmFtc1xuLyoqXG4gKiBAcGFyYW0ge1N2ZWx0ZUNvbXBvbmVudH0gY29tcG9uZW50XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9wdWJsaWMuanMnKS5Db21wb25lbnRDb25zdHJ1Y3Rvck9wdGlvbnN9IG9wdGlvbnNcbiAqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi91dGlscy5qcycpWydub3RfZXF1YWwnXX0gbm90X2VxdWFsIFVzZWQgdG8gY29tcGFyZSBwcm9wcyBhbmQgc3RhdGUgdmFsdWVzLlxuICogQHBhcmFtIHsodGFyZ2V0OiBFbGVtZW50IHwgU2hhZG93Um9vdCkgPT4gdm9pZH0gW2FwcGVuZF9zdHlsZXNdIEZ1bmN0aW9uIHRoYXQgYXBwZW5kcyBzdHlsZXMgdG8gdGhlIERPTSB3aGVuIHRoZSBjb21wb25lbnQgaXMgZmlyc3QgaW5pdGlhbGlzZWQuXG4gKiBUaGlzIHdpbGwgYmUgdGhlIGBhZGRfY3NzYCBmdW5jdGlvbiBmcm9tIHRoZSBjb21waWxlZCBjb21wb25lbnQuXG4gKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbml0KFxuXHRjb21wb25lbnQsXG5cdG9wdGlvbnMsXG5cdGluc3RhbmNlLFxuXHRjcmVhdGVfZnJhZ21lbnQsXG5cdG5vdF9lcXVhbCxcblx0cHJvcHMsXG5cdGFwcGVuZF9zdHlsZXMgPSBudWxsLFxuXHRkaXJ0eSA9IFstMV1cbikge1xuXHRjb25zdCBwYXJlbnRfY29tcG9uZW50ID0gY3VycmVudF9jb21wb25lbnQ7XG5cdHNldF9jdXJyZW50X2NvbXBvbmVudChjb21wb25lbnQpO1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9wcml2YXRlLmpzJykuVCQkfSAqL1xuXHRjb25zdCAkJCA9IChjb21wb25lbnQuJCQgPSB7XG5cdFx0ZnJhZ21lbnQ6IG51bGwsXG5cdFx0Y3R4OiBbXSxcblx0XHQvLyBzdGF0ZVxuXHRcdHByb3BzLFxuXHRcdHVwZGF0ZTogbm9vcCxcblx0XHRub3RfZXF1YWwsXG5cdFx0Ym91bmQ6IGJsYW5rX29iamVjdCgpLFxuXHRcdC8vIGxpZmVjeWNsZVxuXHRcdG9uX21vdW50OiBbXSxcblx0XHRvbl9kZXN0cm95OiBbXSxcblx0XHRvbl9kaXNjb25uZWN0OiBbXSxcblx0XHRiZWZvcmVfdXBkYXRlOiBbXSxcblx0XHRhZnRlcl91cGRhdGU6IFtdLFxuXHRcdGNvbnRleHQ6IG5ldyBNYXAob3B0aW9ucy5jb250ZXh0IHx8IChwYXJlbnRfY29tcG9uZW50ID8gcGFyZW50X2NvbXBvbmVudC4kJC5jb250ZXh0IDogW10pKSxcblx0XHQvLyBldmVyeXRoaW5nIGVsc2Vcblx0XHRjYWxsYmFja3M6IGJsYW5rX29iamVjdCgpLFxuXHRcdGRpcnR5LFxuXHRcdHNraXBfYm91bmQ6IGZhbHNlLFxuXHRcdHJvb3Q6IG9wdGlvbnMudGFyZ2V0IHx8IHBhcmVudF9jb21wb25lbnQuJCQucm9vdFxuXHR9KTtcblx0YXBwZW5kX3N0eWxlcyAmJiBhcHBlbmRfc3R5bGVzKCQkLnJvb3QpO1xuXHRsZXQgcmVhZHkgPSBmYWxzZTtcblx0JCQuY3R4ID0gaW5zdGFuY2Vcblx0XHQ/IGluc3RhbmNlKGNvbXBvbmVudCwgb3B0aW9ucy5wcm9wcyB8fCB7fSwgKGksIHJldCwgLi4ucmVzdCkgPT4ge1xuXHRcdFx0XHRjb25zdCB2YWx1ZSA9IHJlc3QubGVuZ3RoID8gcmVzdFswXSA6IHJldDtcblx0XHRcdFx0aWYgKCQkLmN0eCAmJiBub3RfZXF1YWwoJCQuY3R4W2ldLCAoJCQuY3R4W2ldID0gdmFsdWUpKSkge1xuXHRcdFx0XHRcdGlmICghJCQuc2tpcF9ib3VuZCAmJiAkJC5ib3VuZFtpXSkgJCQuYm91bmRbaV0odmFsdWUpO1xuXHRcdFx0XHRcdGlmIChyZWFkeSkgbWFrZV9kaXJ0eShjb21wb25lbnQsIGkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0ICB9KVxuXHRcdDogW107XG5cdCQkLnVwZGF0ZSgpO1xuXHRyZWFkeSA9IHRydWU7XG5cdHJ1bl9hbGwoJCQuYmVmb3JlX3VwZGF0ZSk7XG5cdC8vIGBmYWxzZWAgYXMgYSBzcGVjaWFsIGNhc2Ugb2Ygbm8gRE9NIGNvbXBvbmVudFxuXHQkJC5mcmFnbWVudCA9IGNyZWF0ZV9mcmFnbWVudCA/IGNyZWF0ZV9mcmFnbWVudCgkJC5jdHgpIDogZmFsc2U7XG5cdGlmIChvcHRpb25zLnRhcmdldCkge1xuXHRcdGlmIChvcHRpb25zLmh5ZHJhdGUpIHtcblx0XHRcdHN0YXJ0X2h5ZHJhdGluZygpO1xuXHRcdFx0Ly8gVE9ETzogd2hhdCBpcyB0aGUgY29ycmVjdCB0eXBlIGhlcmU/XG5cdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0XHRjb25zdCBub2RlcyA9IGNoaWxkcmVuKG9wdGlvbnMudGFyZ2V0KTtcblx0XHRcdCQkLmZyYWdtZW50ICYmICQkLmZyYWdtZW50Lmwobm9kZXMpO1xuXHRcdFx0bm9kZXMuZm9yRWFjaChkZXRhY2gpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuXHRcdFx0JCQuZnJhZ21lbnQgJiYgJCQuZnJhZ21lbnQuYygpO1xuXHRcdH1cblx0XHRpZiAob3B0aW9ucy5pbnRybykgdHJhbnNpdGlvbl9pbihjb21wb25lbnQuJCQuZnJhZ21lbnQpO1xuXHRcdG1vdW50X2NvbXBvbmVudChjb21wb25lbnQsIG9wdGlvbnMudGFyZ2V0LCBvcHRpb25zLmFuY2hvcik7XG5cdFx0ZW5kX2h5ZHJhdGluZygpO1xuXHRcdGZsdXNoKCk7XG5cdH1cblx0c2V0X2N1cnJlbnRfY29tcG9uZW50KHBhcmVudF9jb21wb25lbnQpO1xufVxuXG5leHBvcnQgbGV0IFN2ZWx0ZUVsZW1lbnQ7XG5cbmlmICh0eXBlb2YgSFRNTEVsZW1lbnQgPT09ICdmdW5jdGlvbicpIHtcblx0U3ZlbHRlRWxlbWVudCA9IGNsYXNzIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuXHRcdC8qKiBUaGUgU3ZlbHRlIGNvbXBvbmVudCBjb25zdHJ1Y3RvciAqL1xuXHRcdCQkY3Rvcjtcblx0XHQvKiogU2xvdHMgKi9cblx0XHQkJHM7XG5cdFx0LyoqIFRoZSBTdmVsdGUgY29tcG9uZW50IGluc3RhbmNlICovXG5cdFx0JCRjO1xuXHRcdC8qKiBXaGV0aGVyIG9yIG5vdCB0aGUgY3VzdG9tIGVsZW1lbnQgaXMgY29ubmVjdGVkICovXG5cdFx0JCRjbiA9IGZhbHNlO1xuXHRcdC8qKiBDb21wb25lbnQgcHJvcHMgZGF0YSAqL1xuXHRcdCQkZCA9IHt9O1xuXHRcdC8qKiBgdHJ1ZWAgaWYgY3VycmVudGx5IGluIHRoZSBwcm9jZXNzIG9mIHJlZmxlY3RpbmcgY29tcG9uZW50IHByb3BzIGJhY2sgdG8gYXR0cmlidXRlcyAqL1xuXHRcdCQkciA9IGZhbHNlO1xuXHRcdC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgQ3VzdG9tRWxlbWVudFByb3BEZWZpbml0aW9uPn0gUHJvcHMgZGVmaW5pdGlvbiAobmFtZSwgcmVmbGVjdGVkLCB0eXBlIGV0YykgKi9cblx0XHQkJHBfZCA9IHt9O1xuXHRcdC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgRnVuY3Rpb25bXT59IEV2ZW50IGxpc3RlbmVycyAqL1xuXHRcdCQkbCA9IHt9O1xuXHRcdC8qKiBAdHlwZSB7TWFwPEZ1bmN0aW9uLCBGdW5jdGlvbj59IEV2ZW50IGxpc3RlbmVyIHVuc3Vic2NyaWJlIGZ1bmN0aW9ucyAqL1xuXHRcdCQkbF91ID0gbmV3IE1hcCgpO1xuXG5cdFx0Y29uc3RydWN0b3IoJCRjb21wb25lbnRDdG9yLCAkJHNsb3RzLCB1c2Vfc2hhZG93X2RvbSkge1xuXHRcdFx0c3VwZXIoKTtcblx0XHRcdHRoaXMuJCRjdG9yID0gJCRjb21wb25lbnRDdG9yO1xuXHRcdFx0dGhpcy4kJHMgPSAkJHNsb3RzO1xuXHRcdFx0aWYgKHVzZV9zaGFkb3dfZG9tKSB7XG5cdFx0XHRcdHRoaXMuYXR0YWNoU2hhZG93KHsgbW9kZTogJ29wZW4nIH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcblx0XHRcdC8vIFdlIGNhbid0IGRldGVybWluZSB1cGZyb250IGlmIHRoZSBldmVudCBpcyBhIGN1c3RvbSBldmVudCBvciBub3QsIHNvIHdlIGhhdmUgdG9cblx0XHRcdC8vIGxpc3RlbiB0byBib3RoLiBJZiBzb21lb25lIHVzZXMgYSBjdXN0b20gZXZlbnQgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIGEgcmVndWxhclxuXHRcdFx0Ly8gYnJvd3NlciBldmVudCwgdGhpcyBmaXJlcyB0d2ljZSAtIHdlIGNhbid0IGF2b2lkIHRoYXQuXG5cdFx0XHR0aGlzLiQkbFt0eXBlXSA9IHRoaXMuJCRsW3R5cGVdIHx8IFtdO1xuXHRcdFx0dGhpcy4kJGxbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG5cdFx0XHRpZiAodGhpcy4kJGMpIHtcblx0XHRcdFx0Y29uc3QgdW5zdWIgPSB0aGlzLiQkYy4kb24odHlwZSwgbGlzdGVuZXIpO1xuXHRcdFx0XHR0aGlzLiQkbF91LnNldChsaXN0ZW5lciwgdW5zdWIpO1xuXHRcdFx0fVxuXHRcdFx0c3VwZXIuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0cmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuXHRcdFx0c3VwZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucyk7XG5cdFx0XHRpZiAodGhpcy4kJGMpIHtcblx0XHRcdFx0Y29uc3QgdW5zdWIgPSB0aGlzLiQkbF91LmdldChsaXN0ZW5lcik7XG5cdFx0XHRcdGlmICh1bnN1Yikge1xuXHRcdFx0XHRcdHVuc3ViKCk7XG5cdFx0XHRcdFx0dGhpcy4kJGxfdS5kZWxldGUobGlzdGVuZXIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy4kJGxbdHlwZV0pIHtcblx0XHRcdFx0Y29uc3QgaWR4ID0gdGhpcy4kJGxbdHlwZV0uaW5kZXhPZihsaXN0ZW5lcik7XG5cdFx0XHRcdGlmIChpZHggPj0gMCkge1xuXHRcdFx0XHRcdHRoaXMuJCRsW3R5cGVdLnNwbGljZShpZHgsIDEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0YXN5bmMgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG5cdFx0XHR0aGlzLiQkY24gPSB0cnVlO1xuXHRcdFx0aWYgKCF0aGlzLiQkYykge1xuXHRcdFx0XHQvLyBXZSB3YWl0IG9uZSB0aWNrIHRvIGxldCBwb3NzaWJsZSBjaGlsZCBzbG90IGVsZW1lbnRzIGJlIGNyZWF0ZWQvbW91bnRlZFxuXHRcdFx0XHRhd2FpdCBQcm9taXNlLnJlc29sdmUoKTtcblx0XHRcdFx0aWYgKCF0aGlzLiQkY24gfHwgdGhpcy4kJGMpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0ZnVuY3Rpb24gY3JlYXRlX3Nsb3QobmFtZSkge1xuXHRcdFx0XHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHRcdFx0XHRsZXQgbm9kZTtcblx0XHRcdFx0XHRcdGNvbnN0IG9iaiA9IHtcblx0XHRcdFx0XHRcdFx0YzogZnVuY3Rpb24gY3JlYXRlKCkge1xuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtZW50KCdzbG90Jyk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKG5hbWUgIT09ICdkZWZhdWx0Jykge1xuXHRcdFx0XHRcdFx0XHRcdFx0YXR0cihub2RlLCAnbmFtZScsIG5hbWUpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0LyoqXG5cdFx0XHRcdFx0XHRcdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldFxuXHRcdFx0XHRcdFx0XHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBbYW5jaG9yXVxuXHRcdFx0XHRcdFx0XHQgKi9cblx0XHRcdFx0XHRcdFx0bTogZnVuY3Rpb24gbW91bnQodGFyZ2V0LCBhbmNob3IpIHtcblx0XHRcdFx0XHRcdFx0XHRpbnNlcnQodGFyZ2V0LCBub2RlLCBhbmNob3IpO1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRkOiBmdW5jdGlvbiBkZXN0cm95KGRldGFjaGluZykge1xuXHRcdFx0XHRcdFx0XHRcdGlmIChkZXRhY2hpbmcpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGRldGFjaChub2RlKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRyZXR1cm4gb2JqO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29uc3QgJCRzbG90cyA9IHt9O1xuXHRcdFx0XHRjb25zdCBleGlzdGluZ19zbG90cyA9IGdldF9jdXN0b21fZWxlbWVudHNfc2xvdHModGhpcyk7XG5cdFx0XHRcdGZvciAoY29uc3QgbmFtZSBvZiB0aGlzLiQkcykge1xuXHRcdFx0XHRcdGlmIChuYW1lIGluIGV4aXN0aW5nX3Nsb3RzKSB7XG5cdFx0XHRcdFx0XHQkJHNsb3RzW25hbWVdID0gW2NyZWF0ZV9zbG90KG5hbWUpXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yIChjb25zdCBhdHRyaWJ1dGUgb2YgdGhpcy5hdHRyaWJ1dGVzKSB7XG5cdFx0XHRcdFx0Ly8gdGhpcy4kJGRhdGEgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIHRoaXMuYXR0cmlidXRlc1xuXHRcdFx0XHRcdGNvbnN0IG5hbWUgPSB0aGlzLiQkZ19wKGF0dHJpYnV0ZS5uYW1lKTtcblx0XHRcdFx0XHRpZiAoIShuYW1lIGluIHRoaXMuJCRkKSkge1xuXHRcdFx0XHRcdFx0dGhpcy4kJGRbbmFtZV0gPSBnZXRfY3VzdG9tX2VsZW1lbnRfdmFsdWUobmFtZSwgYXR0cmlidXRlLnZhbHVlLCB0aGlzLiQkcF9kLCAndG9Qcm9wJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIFBvcnQgb3ZlciBwcm9wcyB0aGF0IHdlcmUgc2V0IHByb2dyYW1tYXRpY2FsbHkgYmVmb3JlIGNlIHdhcyBpbml0aWFsaXplZFxuXHRcdFx0XHRmb3IgKGNvbnN0IGtleSBpbiB0aGlzLiQkcF9kKSB7XG5cdFx0XHRcdFx0aWYgKCEoa2V5IGluIHRoaXMuJCRkKSAmJiB0aGlzW2tleV0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0dGhpcy4kJGRba2V5XSA9IHRoaXNba2V5XTsgLy8gZG9uJ3QgdHJhbnNmb3JtLCB0aGVzZSB3ZXJlIHNldCB0aHJvdWdoIEphdmFTY3JpcHRcblx0XHRcdFx0XHRcdGRlbGV0ZSB0aGlzW2tleV07IC8vIHJlbW92ZSB0aGUgcHJvcGVydHkgdGhhdCBzaGFkb3dzIHRoZSBnZXR0ZXIvc2V0dGVyXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuJCRjID0gbmV3IHRoaXMuJCRjdG9yKHtcblx0XHRcdFx0XHR0YXJnZXQ6IHRoaXMuc2hhZG93Um9vdCB8fCB0aGlzLFxuXHRcdFx0XHRcdHByb3BzOiB7XG5cdFx0XHRcdFx0XHQuLi50aGlzLiQkZCxcblx0XHRcdFx0XHRcdCQkc2xvdHMsXG5cdFx0XHRcdFx0XHQkJHNjb3BlOiB7XG5cdFx0XHRcdFx0XHRcdGN0eDogW11cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdC8vIFJlZmxlY3QgY29tcG9uZW50IHByb3BzIGFzIGF0dHJpYnV0ZXNcblx0XHRcdFx0Y29uc3QgcmVmbGVjdF9hdHRyaWJ1dGVzID0gKCkgPT4ge1xuXHRcdFx0XHRcdHRoaXMuJCRyID0gdHJ1ZTtcblx0XHRcdFx0XHRmb3IgKGNvbnN0IGtleSBpbiB0aGlzLiQkcF9kKSB7XG5cdFx0XHRcdFx0XHR0aGlzLiQkZFtrZXldID0gdGhpcy4kJGMuJCQuY3R4W3RoaXMuJCRjLiQkLnByb3BzW2tleV1dO1xuXHRcdFx0XHRcdFx0aWYgKHRoaXMuJCRwX2Rba2V5XS5yZWZsZWN0KSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGF0dHJpYnV0ZV92YWx1ZSA9IGdldF9jdXN0b21fZWxlbWVudF92YWx1ZShcblx0XHRcdFx0XHRcdFx0XHRrZXksXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy4kJGRba2V5XSxcblx0XHRcdFx0XHRcdFx0XHR0aGlzLiQkcF9kLFxuXHRcdFx0XHRcdFx0XHRcdCd0b0F0dHJpYnV0ZSdcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0aWYgKGF0dHJpYnV0ZV92YWx1ZSA9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5yZW1vdmVBdHRyaWJ1dGUodGhpcy4kJHBfZFtrZXldLmF0dHJpYnV0ZSB8fCBrZXkpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKHRoaXMuJCRwX2Rba2V5XS5hdHRyaWJ1dGUgfHwga2V5LCBhdHRyaWJ1dGVfdmFsdWUpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuJCRyID0gZmFsc2U7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHRoaXMuJCRjLiQkLmFmdGVyX3VwZGF0ZS5wdXNoKHJlZmxlY3RfYXR0cmlidXRlcyk7XG5cdFx0XHRcdHJlZmxlY3RfYXR0cmlidXRlcygpOyAvLyBvbmNlIGluaXRpYWxseSBiZWNhdXNlIGFmdGVyX3VwZGF0ZSBpcyBhZGRlZCB0b28gbGF0ZSBmb3IgZmlyc3QgcmVuZGVyXG5cblx0XHRcdFx0Zm9yIChjb25zdCB0eXBlIGluIHRoaXMuJCRsKSB7XG5cdFx0XHRcdFx0Zm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLiQkbFt0eXBlXSkge1xuXHRcdFx0XHRcdFx0Y29uc3QgdW5zdWIgPSB0aGlzLiQkYy4kb24odHlwZSwgbGlzdGVuZXIpO1xuXHRcdFx0XHRcdFx0dGhpcy4kJGxfdS5zZXQobGlzdGVuZXIsIHVuc3ViKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy4kJGwgPSB7fTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBXZSBkb24ndCBuZWVkIHRoaXMgd2hlbiB3b3JraW5nIHdpdGhpbiBTdmVsdGUgY29kZSwgYnV0IGZvciBjb21wYXRpYmlsaXR5IG9mIHBlb3BsZSB1c2luZyB0aGlzIG91dHNpZGUgb2YgU3ZlbHRlXG5cdFx0Ly8gYW5kIHNldHRpbmcgYXR0cmlidXRlcyB0aHJvdWdoIHNldEF0dHJpYnV0ZSBldGMsIHRoaXMgaXMgaGVscGZ1bFxuXHRcdGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhhdHRyLCBfb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG5cdFx0XHRpZiAodGhpcy4kJHIpIHJldHVybjtcblx0XHRcdGF0dHIgPSB0aGlzLiQkZ19wKGF0dHIpO1xuXHRcdFx0dGhpcy4kJGRbYXR0cl0gPSBnZXRfY3VzdG9tX2VsZW1lbnRfdmFsdWUoYXR0ciwgbmV3VmFsdWUsIHRoaXMuJCRwX2QsICd0b1Byb3AnKTtcblx0XHRcdHRoaXMuJCRjPy4kc2V0KHsgW2F0dHJdOiB0aGlzLiQkZFthdHRyXSB9KTtcblx0XHR9XG5cblx0XHRkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcblx0XHRcdHRoaXMuJCRjbiA9IGZhbHNlO1xuXHRcdFx0Ly8gSW4gYSBtaWNyb3Rhc2ssIGJlY2F1c2UgdGhpcyBjb3VsZCBiZSBhIG1vdmUgd2l0aGluIHRoZSBET01cblx0XHRcdFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuXHRcdFx0XHRpZiAoIXRoaXMuJCRjbiAmJiB0aGlzLiQkYykge1xuXHRcdFx0XHRcdHRoaXMuJCRjLiRkZXN0cm95KCk7XG5cdFx0XHRcdFx0dGhpcy4kJGMgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdCQkZ19wKGF0dHJpYnV0ZV9uYW1lKSB7XG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRPYmplY3Qua2V5cyh0aGlzLiQkcF9kKS5maW5kKFxuXHRcdFx0XHRcdChrZXkpID0+XG5cdFx0XHRcdFx0XHR0aGlzLiQkcF9kW2tleV0uYXR0cmlidXRlID09PSBhdHRyaWJ1dGVfbmFtZSB8fFxuXHRcdFx0XHRcdFx0KCF0aGlzLiQkcF9kW2tleV0uYXR0cmlidXRlICYmIGtleS50b0xvd2VyQ2FzZSgpID09PSBhdHRyaWJ1dGVfbmFtZSlcblx0XHRcdFx0KSB8fCBhdHRyaWJ1dGVfbmFtZVxuXHRcdFx0KTtcblx0XHR9XG5cdH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBDdXN0b21FbGVtZW50UHJvcERlZmluaXRpb24+fSBwcm9wc19kZWZpbml0aW9uXG4gKiBAcGFyYW0geyd0b0F0dHJpYnV0ZScgfCAndG9Qcm9wJ30gW3RyYW5zZm9ybV1cbiAqL1xuZnVuY3Rpb24gZ2V0X2N1c3RvbV9lbGVtZW50X3ZhbHVlKHByb3AsIHZhbHVlLCBwcm9wc19kZWZpbml0aW9uLCB0cmFuc2Zvcm0pIHtcblx0Y29uc3QgdHlwZSA9IHByb3BzX2RlZmluaXRpb25bcHJvcF0/LnR5cGU7XG5cdHZhbHVlID0gdHlwZSA9PT0gJ0Jvb2xlYW4nICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ2Jvb2xlYW4nID8gdmFsdWUgIT0gbnVsbCA6IHZhbHVlO1xuXHRpZiAoIXRyYW5zZm9ybSB8fCAhcHJvcHNfZGVmaW5pdGlvbltwcm9wXSkge1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fSBlbHNlIGlmICh0cmFuc2Zvcm0gPT09ICd0b0F0dHJpYnV0ZScpIHtcblx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdGNhc2UgJ09iamVjdCc6XG5cdFx0XHRjYXNlICdBcnJheSc6XG5cdFx0XHRcdHJldHVybiB2YWx1ZSA9PSBudWxsID8gbnVsbCA6IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcblx0XHRcdGNhc2UgJ0Jvb2xlYW4nOlxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPyAnJyA6IG51bGw7XG5cdFx0XHRjYXNlICdOdW1iZXInOlxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IG51bGwgOiB2YWx1ZTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRjYXNlICdPYmplY3QnOlxuXHRcdFx0Y2FzZSAnQXJyYXknOlxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgJiYgSlNPTi5wYXJzZSh2YWx1ZSk7XG5cdFx0XHRjYXNlICdCb29sZWFuJzpcblx0XHRcdFx0cmV0dXJuIHZhbHVlOyAvLyBjb252ZXJzaW9uIGFscmVhZHkgaGFuZGxlZCBhYm92ZVxuXHRcdFx0Y2FzZSAnTnVtYmVyJzpcblx0XHRcdFx0cmV0dXJuIHZhbHVlICE9IG51bGwgPyArdmFsdWUgOiB2YWx1ZTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqXG4gKiBUdXJuIGEgU3ZlbHRlIGNvbXBvbmVudCBpbnRvIGEgY3VzdG9tIGVsZW1lbnQuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9wdWJsaWMuanMnKS5Db21wb25lbnRUeXBlfSBDb21wb25lbnQgIEEgU3ZlbHRlIGNvbXBvbmVudCBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBDdXN0b21FbGVtZW50UHJvcERlZmluaXRpb24+fSBwcm9wc19kZWZpbml0aW9uICBUaGUgcHJvcHMgdG8gb2JzZXJ2ZVxuICogQHBhcmFtIHtzdHJpbmdbXX0gc2xvdHMgIFRoZSBzbG90cyB0byBjcmVhdGVcbiAqIEBwYXJhbSB7c3RyaW5nW119IGFjY2Vzc29ycyAgT3RoZXIgYWNjZXNzb3JzIGJlc2lkZXMgdGhlIG9uZXMgZm9yIHByb3BzIHRoZSBjb21wb25lbnQgaGFzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHVzZV9zaGFkb3dfZG9tICBXaGV0aGVyIHRvIHVzZSBzaGFkb3cgRE9NXG4gKiBAcGFyYW0geyhjZTogbmV3ICgpID0+IEhUTUxFbGVtZW50KSA9PiBuZXcgKCkgPT4gSFRNTEVsZW1lbnR9IFtleHRlbmRdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVfY3VzdG9tX2VsZW1lbnQoXG5cdENvbXBvbmVudCxcblx0cHJvcHNfZGVmaW5pdGlvbixcblx0c2xvdHMsXG5cdGFjY2Vzc29ycyxcblx0dXNlX3NoYWRvd19kb20sXG5cdGV4dGVuZFxuKSB7XG5cdGxldCBDbGFzcyA9IGNsYXNzIGV4dGVuZHMgU3ZlbHRlRWxlbWVudCB7XG5cdFx0Y29uc3RydWN0b3IoKSB7XG5cdFx0XHRzdXBlcihDb21wb25lbnQsIHNsb3RzLCB1c2Vfc2hhZG93X2RvbSk7XG5cdFx0XHR0aGlzLiQkcF9kID0gcHJvcHNfZGVmaW5pdGlvbjtcblx0XHR9XG5cdFx0c3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG5cdFx0XHRyZXR1cm4gT2JqZWN0LmtleXMocHJvcHNfZGVmaW5pdGlvbikubWFwKChrZXkpID0+XG5cdFx0XHRcdChwcm9wc19kZWZpbml0aW9uW2tleV0uYXR0cmlidXRlIHx8IGtleSkudG9Mb3dlckNhc2UoKVxuXHRcdFx0KTtcblx0XHR9XG5cdH07XG5cdE9iamVjdC5rZXlzKHByb3BzX2RlZmluaXRpb24pLmZvckVhY2goKHByb3ApID0+IHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xhc3MucHJvdG90eXBlLCBwcm9wLCB7XG5cdFx0XHRnZXQoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLiQkYyAmJiBwcm9wIGluIHRoaXMuJCRjID8gdGhpcy4kJGNbcHJvcF0gOiB0aGlzLiQkZFtwcm9wXTtcblx0XHRcdH0sXG5cdFx0XHRzZXQodmFsdWUpIHtcblx0XHRcdFx0dmFsdWUgPSBnZXRfY3VzdG9tX2VsZW1lbnRfdmFsdWUocHJvcCwgdmFsdWUsIHByb3BzX2RlZmluaXRpb24pO1xuXHRcdFx0XHR0aGlzLiQkZFtwcm9wXSA9IHZhbHVlO1xuXHRcdFx0XHR0aGlzLiQkYz8uJHNldCh7IFtwcm9wXTogdmFsdWUgfSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xuXHRhY2Nlc3NvcnMuZm9yRWFjaCgoYWNjZXNzb3IpID0+IHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xhc3MucHJvdG90eXBlLCBhY2Nlc3Nvciwge1xuXHRcdFx0Z2V0KCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy4kJGM/LlthY2Nlc3Nvcl07XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xuXHRpZiAoZXh0ZW5kKSB7XG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvciAtIGFzc2lnbmluZyBoZXJlIGlzIGZpbmVcblx0XHRDbGFzcyA9IGV4dGVuZChDbGFzcyk7XG5cdH1cblx0Q29tcG9uZW50LmVsZW1lbnQgPSAvKiogQHR5cGUge2FueX0gKi8gKENsYXNzKTtcblx0cmV0dXJuIENsYXNzO1xufVxuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIFN2ZWx0ZSBjb21wb25lbnRzLiBVc2VkIHdoZW4gZGV2PWZhbHNlLlxuICpcbiAqIEB0ZW1wbGF0ZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gW1Byb3BzPWFueV1cbiAqIEB0ZW1wbGF0ZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gW0V2ZW50cz1hbnldXG4gKi9cbmV4cG9ydCBjbGFzcyBTdmVsdGVDb21wb25lbnQge1xuXHQvKipcblx0ICogIyMjIFBSSVZBVEUgQVBJXG5cdCAqXG5cdCAqIERvIG5vdCB1c2UsIG1heSBjaGFuZ2UgYXQgYW55IHRpbWVcblx0ICpcblx0ICogQHR5cGUge2FueX1cblx0ICovXG5cdCQkID0gdW5kZWZpbmVkO1xuXHQvKipcblx0ICogIyMjIFBSSVZBVEUgQVBJXG5cdCAqXG5cdCAqIERvIG5vdCB1c2UsIG1heSBjaGFuZ2UgYXQgYW55IHRpbWVcblx0ICpcblx0ICogQHR5cGUge2FueX1cblx0ICovXG5cdCQkc2V0ID0gdW5kZWZpbmVkO1xuXG5cdC8qKiBAcmV0dXJucyB7dm9pZH0gKi9cblx0JGRlc3Ryb3koKSB7XG5cdFx0ZGVzdHJveV9jb21wb25lbnQodGhpcywgMSk7XG5cdFx0dGhpcy4kZGVzdHJveSA9IG5vb3A7XG5cdH1cblxuXHQvKipcblx0ICogQHRlbXBsYXRlIHtFeHRyYWN0PGtleW9mIEV2ZW50cywgc3RyaW5nPn0gS1xuXHQgKiBAcGFyYW0ge0t9IHR5cGVcblx0ICogQHBhcmFtIHsoKGU6IEV2ZW50c1tLXSkgPT4gdm9pZCkgfCBudWxsIHwgdW5kZWZpbmVkfSBjYWxsYmFja1xuXHQgKiBAcmV0dXJucyB7KCkgPT4gdm9pZH1cblx0ICovXG5cdCRvbih0eXBlLCBjYWxsYmFjaykge1xuXHRcdGlmICghaXNfZnVuY3Rpb24oY2FsbGJhY2spKSB7XG5cdFx0XHRyZXR1cm4gbm9vcDtcblx0XHR9XG5cdFx0Y29uc3QgY2FsbGJhY2tzID0gdGhpcy4kJC5jYWxsYmFja3NbdHlwZV0gfHwgKHRoaXMuJCQuY2FsbGJhY2tzW3R5cGVdID0gW10pO1xuXHRcdGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcblx0XHRyZXR1cm4gKCkgPT4ge1xuXHRcdFx0Y29uc3QgaW5kZXggPSBjYWxsYmFja3MuaW5kZXhPZihjYWxsYmFjayk7XG5cdFx0XHRpZiAoaW5kZXggIT09IC0xKSBjYWxsYmFja3Muc3BsaWNlKGluZGV4LCAxKTtcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7UGFydGlhbDxQcm9wcz59IHByb3BzXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0JHNldChwcm9wcykge1xuXHRcdGlmICh0aGlzLiQkc2V0ICYmICFpc19lbXB0eShwcm9wcykpIHtcblx0XHRcdHRoaXMuJCQuc2tpcF9ib3VuZCA9IHRydWU7XG5cdFx0XHR0aGlzLiQkc2V0KHByb3BzKTtcblx0XHRcdHRoaXMuJCQuc2tpcF9ib3VuZCA9IGZhbHNlO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEN1c3RvbUVsZW1lbnRQcm9wRGVmaW5pdGlvblxuICogQHByb3BlcnR5IHtzdHJpbmd9IFthdHRyaWJ1dGVdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZWZsZWN0XVxuICogQHByb3BlcnR5IHsnU3RyaW5nJ3wnQm9vbGVhbid8J051bWJlcid8J0FycmF5J3wnT2JqZWN0J30gW3R5cGVdXG4gKi9cbiIsICIvLyBnZW5lcmF0ZWQgZHVyaW5nIHJlbGVhc2UsIGRvIG5vdCBtb2RpZnlcblxuLyoqXG4gKiBUaGUgY3VycmVudCB2ZXJzaW9uLCBhcyBzZXQgaW4gcGFja2FnZS5qc29uLlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS1jb21waWxlciNzdmVsdGUtdmVyc2lvblxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IFZFUlNJT04gPSAnNC4yLjIwJztcbmV4cG9ydCBjb25zdCBQVUJMSUNfVkVSU0lPTiA9ICc0JztcbiIsICJpbXBvcnQgeyBQVUJMSUNfVkVSU0lPTiB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC92ZXJzaW9uLmpzJztcblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKVxuXHQvLyBAdHMtaWdub3JlXG5cdCh3aW5kb3cuX19zdmVsdGUgfHwgKHdpbmRvdy5fX3N2ZWx0ZSA9IHsgdjogbmV3IFNldCgpIH0pKS52LmFkZChQVUJMSUNfVkVSU0lPTik7XG4iLCAiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fY3JlYXRlQmluZGluZyA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XHJcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xyXG4gICAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xyXG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIG9bazJdID0gbVtrXTtcclxufSk7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHBvcnRTdGFyKG0sIG8pIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgcCkpIF9fY3JlYXRlQmluZGluZyhvLCBtLCBwKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuLyoqIEBkZXByZWNhdGVkICovXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZCgpIHtcclxuICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuLyoqIEBkZXByZWNhdGVkICovXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZEFycmF5cygpIHtcclxuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xyXG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxyXG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxyXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcclxuICAgIHJldHVybiByO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheSh0bywgZnJvbSwgcGFjaykge1xyXG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XHJcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XHJcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXQodikge1xyXG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxyXG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0RlbGVnYXRvcihvKSB7XHJcbiAgICB2YXIgaSwgcDtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaVtuXSA9IG9bbl0gPyBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBuID09PSBcInJldHVyblwiIH0gOiBmID8gZih2KSA6IHY7IH0gOiBmOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcclxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICByZXR1cm4gY29va2VkO1xyXG59O1xyXG5cclxudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xyXG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydFN0YXIobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xyXG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcclxuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcclxuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRTZXQocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEluKHN0YXRlLCByZWNlaXZlcikge1xyXG4gICAgaWYgKHJlY2VpdmVyID09PSBudWxsIHx8ICh0eXBlb2YgcmVjZWl2ZXIgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHJlY2VpdmVyICE9PSBcImZ1bmN0aW9uXCIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHVzZSAnaW4nIG9wZXJhdG9yIG9uIG5vbi1vYmplY3RcIik7XHJcbiAgICByZXR1cm4gdHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciA9PT0gc3RhdGUgOiBzdGF0ZS5oYXMocmVjZWl2ZXIpO1xyXG59XHJcbiIsICI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBvbk1vdW50LCB0aWNrIH0gZnJvbSBcInN2ZWx0ZVwiO1xuXG5cdGV4cG9ydCBsZXQgaXNGaXJzdDogYm9vbGVhbjtcblx0ZXhwb3J0IGxldCByZW1vdmVJbnB1dDogKGlkOiBudW1iZXIpID0+IHZvaWQ7XG5cdGV4cG9ydCBsZXQgaWQ6IG51bWJlcjtcblxuXHRleHBvcnQgbGV0IHR5cGVWYWw6IHN0cmluZyA9IFwidGV4dFwiO1xuXHRleHBvcnQgbGV0IG5hbWVWYWw6IHN0cmluZyA9IFwiXCI7XG5cdGV4cG9ydCBsZXQgdmFsdWVWYWw6IHN0cmluZyA9IFwiXCI7XG5cblx0bGV0IGlucHV0RWw6IEhUTUxJbnB1dEVsZW1lbnQ7XG5cdGxldCB2YWx1ZUVsOiBIVE1MSW5wdXRFbGVtZW50O1xuXG5cdGxldCBvcHRpb25WYWw6IHN0cmluZ1xuXHQvL0Zvcm0gbmFtZXMgdGllZCB0byBpbnB1dCB0eXBlcy5cblx0Y29uc3Qgb3B0aW9uczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcblx0XHRUZXh0OiBcInN0cmluZ1wiLFxuXHRcdE51bWJlcjogXCJudW1iZXJcIixcblx0XHRDaGVja2JveDogXCJjaGVja2JveFwiLFxuXHRcdERhdGU6IFwiZGF0ZVwiLFxuXHRcdERhdGV0aW1lOiBcImRhdGV0aW1lLWxvY2FsXCIsXG5cdH07XG5cdC8vTWF0Y2ggT2JzaWRpYW4gZGF0YSB0eXBlcyB0byBmb3JtIG5hbWVzLlxuXHRjb25zdCBjb252ZXJ0UHJvcHM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG5cdFx0dGV4dDogXCJUZXh0XCIsXG5cdFx0bXVsdGl0ZXh0OiBcIlRleHRcIixcblx0XHRudW1iZXI6IFwiTnVtYmVyXCIsXG5cdFx0Y2hlY2tib3g6IFwiQ2hlY2tib3hcIixcblx0XHRkYXRlOiBcIkRhdGVcIixcblx0XHRkYXRldGltZTogXCJEYXRldGltZVwiXG5cdH1cblxuXHRvbk1vdW50KGFzeW5jICgpID0+IHtcblx0XHRhd2FpdCB0aWNrKCk7ICAvL0ZvY3VzIHdvbid0IHdvcmsgcmlnaHQgd2l0aG91dCB0aWNrKCkuXG5cdFx0aW5wdXRFbC5mb2N1cygpO1xuXHRcdGlucHV0RWwuc2VsZWN0KCk7XG5cblx0XHRvcHRpb25WYWwgPSBvcHRpb25zW2NvbnZlcnRQcm9wc1t0eXBlVmFsXV0gIC8vTG9hZCBkZWZhdWx0IHR5cGUuXG5cblx0fSk7XG5cblx0ZnVuY3Rpb24gY2hhbmdlVHlwZSh0eXBlOiBzdHJpbmcpe1xuXHRcdHZhbHVlRWwudHlwZSA9IHR5cGVcblx0fVxuPC9zY3JpcHQ+XG5cbjxkaXYgY2xhc3M9XCJtb2RhbC1pbnB1dC1jb250YWluZXJcIj5cblx0PGJ1dHRvblxuXHRcdHR5cGU9XCJidXR0b25cIlxuXHRcdGlkPVwiZGVsLWJ0blwiXG5cdFx0b246Y2xpY2s9eygpID0+IHtcblx0XHRcdGlmICghaXNGaXJzdCkge1xuXHRcdFx0XHRyZW1vdmVJbnB1dChpZCk7XG5cdFx0XHR9XG5cdFx0fX1cblx0XHRjbGFzcz1cImJ0bi1kZWwge2lzRmlyc3QgPyAnYnRuLWluYWN0aXZlJyA6ICcnfVwiXG5cdFx0dGFiaW5kZXg9e2lzRmlyc3QgPyAtMSA6IDB9XG5cdFx0Plg8L2J1dHRvblxuXHQ+XG5cdDxzZWxlY3QgaWQ9XCJ0eXBlLWlucHV0XCIgY2xhc3M9XCJmbGV4LW9ialwiIGJpbmQ6dmFsdWU9e29wdGlvblZhbH0gb246Y2hhbmdlPXsoKSA9PiBjaGFuZ2VUeXBlKG9wdGlvblZhbCl9PlxuXHRcdHsjZWFjaCBPYmplY3Qua2V5cyhvcHRpb25zKSBhcyBrZXl9XG5cdFx0XHQ8b3B0aW9uIHZhbHVlPXtvcHRpb25zW2tleV19PntrZXl9PC9vcHRpb24+XG5cdFx0ey9lYWNofVxuXHQ8L3NlbGVjdD5cblx0PGlucHV0XG5cdFx0aWQ9XCJuYW1lLWlucHV0XCJcblx0XHRiaW5kOnRoaXM9e2lucHV0RWx9XG5cdFx0Y2xhc3M9XCJuYW1lLWlucHV0IGZsZXgtb2JqXCJcblx0XHR0eXBlPVwidGV4dFwiXG5cdFx0bmFtZT1cIm5hbWVbXVwiXG5cdFx0cGxhY2Vob2xkZXI9XCJuYW1lXCJcblx0XHRiaW5kOnZhbHVlPXtuYW1lVmFsfVxuXHRcdHJlcXVpcmVkXG5cdC8+XG5cdDxpbnB1dCBiaW5kOnRoaXM9e3ZhbHVlRWx9XG5cdFx0aWQ9XCJ2YWx1ZS1pbnB1dFwiXG5cdFx0dHlwZT1cInRleHRcIlxuXHRcdG5hbWU9XCJ2YWx1ZVtdXCJcblx0XHRwbGFjZWhvbGRlcj1cInZhbHVlXCJcblx0XHRiaW5kOnZhbHVlPXt2YWx1ZVZhbH1cblx0XHRjbGFzcz1cInZhbHVlLWlucHV0IGZsZXgtb2JqXCJcblx0Lz5cbjwvZGl2PlxuXG48c3R5bGU+XG5cdGlucHV0IHtcblx0XHRtYXgtaGVpZ2h0OiAyNXB4O1xuXHRcdG92ZXJmbG93LXg6IGF1dG87XG5cdH1cblxuXHRzZWxlY3Qge1xuXHRcdGhlaWdodDogMjFweDtcblx0fVxuXG5cdCNuYW1lLWlucHV0IHtcblx0XHRmbGV4LWdyb3c6IDA7XG5cdFx0d2lkdGg6IGF1dG87XG5cdH1cblxuXHQubW9kYWwtaW5wdXQtY29udGFpbmVyIHtcblx0XHR3aWR0aDogOTUlO1xuXHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0ZmxleC1kaXJlY3Rpb246IHJvdztcblx0XHRhbGlnbi1pdGVtczogY2VudGVyO1xuXHRcdGdhcDogMTBweDtcblx0XHRtYXJnaW4tdG9wOiAxMHB4O1xuXHR9XG5cblx0LmJ0bi1pbmFjdGl2ZSB7XG5cdFx0Y3Vyc29yOiBub3QtYWxsb3dlZDtcblx0XHRwb2ludGVyLWV2ZW50czogbm9uZTtcblx0XHRvcGFjaXR5OiAwLjc7XG5cdH1cbjwvc3R5bGU+XG4iLCAiLyoqIFJldHVybiB2YWx1ZSBmcm9tIEhUTUwgaW5wdXQgYmFzZWQgb24gdGhlIGlucHV0J3MgdHlwZS4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlVmFsdWUoaW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQsIHR5cGU6IHN0cmluZykge1xyXG5cdHN3aXRjaCAodHlwZSkge1xyXG5cdFx0Y2FzZSBcIm51bWJlclwiOlxyXG5cdFx0XHRyZXR1cm4gTnVtYmVyKGlucHV0LnZhbHVlKTtcclxuXHRcdGNhc2UgXCJjaGVja2JveFwiOlxyXG5cdFx0XHRyZXR1cm4gQm9vbGVhbihpbnB1dC5jaGVja2VkKTtcclxuXHRcdGRlZmF1bHQ6XHJcblx0XHRcdHJldHVybiBpbnB1dC52YWx1ZTtcclxuXHR9XHJcbn1cclxuXHJcbi8qKiBSZW1vdmUgbGVhZGluZyBhbmQgdHJhaWxpbmcgY29tbWFzLCB0aGVuIHJlcGxhY2UgbXVsdGlwbGUgY29uc2VjdXRpdmUgY29tbWFzIHdpdGggYSBzaW5nbGUgY29tbWEuKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUV4dHJhQ29tbWFzKHN0cjogc3RyaW5nKTogc3RyaW5nIHtcclxuXHRyZXR1cm4gc3RyLnJlcGxhY2UoL14sKiguKj8pLCokL2csIFwiJDFcIikucmVwbGFjZSgvLHsyLH0vZywgXCIsXCIpO1xyXG59XHJcblxyXG4vKiogUmVtb3ZlIGFueSBpbnZhbGlkIHRhZyBjaGFyYWN0ZXJzIGZyb20gc3RyaW5nLiovXHJcbmV4cG9ydCBmdW5jdGlvbiBjbGVhblRhZ3Moc3RyOiBzdHJpbmcpIHtcclxuXHQvL1Rha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL0dvcmt5Y3JlYXRvci9vYnNpZGlhbi1xdWljay10YWdnZXIvXHJcblx0bGV0IGNsZWFuU3RyID0gc3RyO1xyXG5cdGZvciAobGV0IGluZGV4IGluIEtOT1dOX0JBRF9DSEFSQUNURVJTKSB7XHJcblx0XHRjbGVhblN0ciA9IGNsZWFuU3RyLnJlcGxhY2VBbGwoS05PV05fQkFEX0NIQVJBQ1RFUlNbaW5kZXhdLCBcIlwiKTtcclxuXHR9XHJcblx0cmV0dXJuIGNsZWFuU3RyO1xyXG59XHJcblxyXG4vL1Rha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL0dvcmt5Y3JlYXRvci9vYnNpZGlhbi1xdWljay10YWdnZXIvLlxyXG4vL0NvbW1hcyByZW1vdmVkLiAgV2lsbCBpbnN0ZWFkIGJlIGhhbmRsZWQgYnkgcmVtb3ZlRXh0cmFDb21tYXMuXHJcbmNvbnN0IEtOT1dOX0JBRF9DSEFSQUNURVJTID0gW1xyXG5cdFwiXHUyMDEyXCIsXHJcblx0XCJcdTIwMTNcIixcclxuXHRcIlx1MjAxNFwiLFxyXG5cdFwiXHUyMDE1XCIsXHJcblx0XCJcdTIwNEZcIixcclxuXHRcIlx1MjAzRFwiLFxyXG5cdFwiXHUyMDE4XCIsXHJcblx0XCJcdTIwMUFcIixcclxuXHRcIlx1MjAxQlwiLFxyXG5cdFwiXHUyMDM5XCIsXHJcblx0XCJcdTIwM0FcIixcclxuXHRcIlx1MjAxQ1wiLFxyXG5cdFwiXHUyMDFEXCIsXHJcblx0XCJcdTIwMUVcIixcclxuXHRcIlx1MjAxRlwiLFxyXG5cdFwiXHUyMDQ1XCIsXHJcblx0XCJcdTIwNDZcIixcclxuXHRcIlx1MjA0QlwiLFxyXG5cdFwiXHUyMDRFXCIsXHJcblx0XCJcdTIwNTFcIixcclxuXHRcIlx1MjA0NFwiLFxyXG5cdFwiXHUyMDRBXCIsXHJcblx0XCJcdTIwMzBcIixcclxuXHRcIlx1MjAzMVwiLFxyXG5cdFwiXHUyMDUyXCIsXHJcblx0XCJcdTIwMjBcIixcclxuXHRcIlx1MjAyMVwiLFxyXG5cdFwiXHUyMDIyXCIsXHJcblx0XCJcdTIwMjNcIixcclxuXHRcIlx1MjA0M1wiLFxyXG5cdFwiXHUyMDRDXCIsXHJcblx0XCJcdTIwNERcIixcclxuXHRcIlx1MjAzMlwiLFxyXG5cdFwiXHUyMDM1XCIsXHJcblx0XCJcdTIwMzhcIixcclxuXHRcIlx1MjAzQlwiLFxyXG5cdFwiXHUyMDUwXCIsXHJcblx0XCJcdTIwNDFcIixcclxuXHRcIlx1MjA0MlwiLFxyXG5cdFwiXHUyMDE2XCIsXHJcblx0XCJcdTIwMTFcIixcclxuXHRcIlx1MjAzM1wiLFxyXG5cdFwiXHUyMDM0XCIsXHJcblx0XCJcdTIwNTdcIixcclxuXHRcIlx1MjAzNlwiLFxyXG5cdFwiXHUyMDM3XCIsXHJcblx0XCJgXCIsXHJcblx0XCJeXCIsXHJcblx0XCJcdTIwM0VcIixcclxuXHRcIlx1MjAxN1wiLFxyXG5cdFwiXHUyMDUzXCIsXHJcblx0XCI7XCIsXHJcblx0XCI6XCIsXHJcblx0XCIhXCIsXHJcblx0XCJcdTIwM0NcIixcclxuXHRcIlx1MjA0OVwiLFxyXG5cdFwiP1wiLFxyXG5cdFwiXHUyMDQ4XCIsXHJcblx0XCJcdTIwNDdcIixcclxuXHRcIi5cIixcclxuXHRcIlx1MjAyNFwiLFxyXG5cdFwiXHUyMDI1XCIsXHJcblx0XCJcdTIwMjZcIixcclxuXHRcIidcIixcclxuXHQnXCInLFxyXG5cdFwiKFwiLFxyXG5cdFwiKVwiLFxyXG5cdFwiW1wiLFxyXG5cdFwiXVwiLFxyXG5cdFwie1wiLFxyXG5cdFwifVwiLFxyXG5cdFwiQFwiLFxyXG5cdFwiKlwiLFxyXG5cdFwiJlwiLFxyXG5cdFwiJVwiLFxyXG5cdFwiXHUyMDU0XCIsXHJcblx0XCIrXCIsXHJcblx0XCI8XCIsXHJcblx0XCI9XCIsXHJcblx0XCI+XCIsXHJcblx0XCJ8XCIsXHJcblx0XCJ+XCIsXHJcblx0XCIkXCIsXHJcblx0XCJcdTIwNTVcIixcclxuXHRcIlx1MjA1NlwiLFxyXG5cdFwiXHUyMDU4XCIsXHJcblx0XCJcdTIwNTlcIixcclxuXHRcIlx1MjA1QVwiLFxyXG5cdFwiXHUyMDVCXCIsXHJcblx0XCJcdTIwNUNcIixcclxuXHRcIlx1MjA1RFwiLFxyXG5cdFwiXHUyMDVFXCIsXHJcblx0XCJcdTJFMDBcIixcclxuXHRcIlx1MkUwMVwiLFxyXG5cdFwiXHUyRTAyXCIsXHJcblx0XCJcdTJFMDNcIixcclxuXHRcIlx1MkUwNFwiLFxyXG5cdFwiXHUyRTA1XCIsXHJcblx0XCJcdTJFMDZcIixcclxuXHRcIlx1MkUwN1wiLFxyXG5cdFwiXHUyRTA4XCIsXHJcblx0XCJcdTJFMDlcIixcclxuXHRcIlx1MkUwQVwiLFxyXG5cdFwiXHUyRTBCXCIsXHJcblx0XCJcdTJFMENcIixcclxuXHRcIlx1MkUwRFwiLFxyXG5cdFwiXHUyRTBFXCIsXHJcblx0XCJcdTJFMEZcIixcclxuXHRcIlx1MkUxMFwiLFxyXG5cdFwiXHUyRTExXCIsXHJcblx0XCJcdTJFMTJcIixcclxuXHRcIlx1MkUxM1wiLFxyXG5cdFwiXHUyRTE0XCIsXHJcblx0XCJcdTJFMTVcIixcclxuXHRcIlx1MkUxNlwiLFxyXG5cdFwiXHUyRTE3XCIsXHJcblx0XCJcdTJFMUNcIixcclxuXHRcIlx1MkUxRFwiLFxyXG5cdFwiIFwiLFxyXG5cdFwiI1wiLFxyXG5dO1xyXG4iLCAiPHNjcmlwdCBsYW5nPVwidHNcIj5cbiAgaW1wb3J0IHsgb25Nb3VudCwgdGljayB9IGZyb20gXCJzdmVsdGVcIjtcbiAgaW1wb3J0IFByb3BJbnB1dCBmcm9tIFwiLi9BZGRQcm9wSW5wdXQuc3ZlbHRlXCI7XG4gIGltcG9ydCB7IE5ld1Byb3BEYXRhIH0gZnJvbSBcIi4vbWFpblwiO1xuICBpbXBvcnQgeyBjbGVhblRhZ3MsIHBhcnNlVmFsdWUsIHJlbW92ZUV4dHJhQ29tbWFzIH0gZnJvbSBcIi4vaGVscGVyc1wiO1xuICBpbXBvcnQgdHlwZSB7IFByb3BlcnR5VHlwZXMgfSBmcm9tIFwiLi90eXBlcy9jdXN0b21cIjtcblxuICBleHBvcnQgbGV0IHN1Ym1pc3Npb246IChwcm9wczogTWFwPHN0cmluZywgTmV3UHJvcERhdGE+KSA9PiB2b2lkO1xuICBleHBvcnQgbGV0IG92ZXJ3cml0ZTogYm9vbGVhbjtcbiAgZXhwb3J0IGxldCBkZWxpbWl0ZXI6IHN0cmluZztcbiAgZXhwb3J0IGxldCBkZWZhdWx0UHJvcHM6IHsgbmFtZTogc3RyaW5nOyB2YWx1ZTogYW55OyB0eXBlOiBQcm9wZXJ0eVR5cGVzIH1bXTtcbiAgZXhwb3J0IGxldCBjaGFuZ2VCb29sOiAoYm9vbDogYm9vbGVhbikgPT4gdm9pZDtcblxuICBsZXQgY291bnRJbnB1dHMgPSAwOyAvL0NvdWxkIHJlcGxhY2Ugd2l0aCBVVUlELlxuICBsZXQgZm9ybUVsOiBIVE1MRm9ybUVsZW1lbnQ7XG4gIGxldCBlcnJvckVsOiBIVE1MRGl2RWxlbWVudDtcbiAgbGV0IGFsZXJ0VGV4dCA9IFwiLlwiO1xuXG4gIGxldCBpbnB1dEVsczoge1xuICAgIGlkOiBudW1iZXI7XG4gICAgaXNGaXJzdDogYm9vbGVhbjtcbiAgICB0eXBlRGVmOiBQcm9wZXJ0eVR5cGVzO1xuICAgIG5hbWVEZWY6IHN0cmluZztcbiAgICB2YWx1ZURlZjogYW55O1xuICB9W10gPSBbXTtcblxuICBmdW5jdGlvbiBvbkNoZWNrYm94Q2hhbmdlKCkge1xuICAgIG92ZXJ3cml0ZSA9ICFvdmVyd3JpdGU7XG4gICAgY2hhbmdlQm9vbChvdmVyd3JpdGUpO1xuICB9XG5cbiAgb25Nb3VudCgoKSA9PiB7XG4gICAgZGVmYXVsdFByb3BzLmxlbmd0aCA+IDBcbiAgICAgID8gYWRkSW5wdXRzKGRlZmF1bHRQcm9wcylcbiAgICAgIDogYWRkSW5wdXRzKFt7IHR5cGU6IFwidGV4dFwiLCBuYW1lOiBcIlwiLCB2YWx1ZTogXCJcIiB9XSk7XG4gIH0pO1xuXG4gIC8qKiBBZGQgbmV3IGlucHV0IHRvIGlucHV0RWxzICovXG4gIGZ1bmN0aW9uIGFkZElucHV0cyhcbiAgICBpbnB1dHM6IHsgdHlwZTogUHJvcGVydHlUeXBlczsgbmFtZTogc3RyaW5nOyB2YWx1ZTogYW55IH1bXSA9IFtcbiAgICAgIHsgdHlwZTogXCJ0ZXh0XCIsIG5hbWU6IFwiXCIsIHZhbHVlOiBcIlwiIH0sXG4gICAgXVxuICApIHtcbiAgICBsZXQgYXJyID0gW107XG4gICAgZm9yIChsZXQgaW5wdXQgb2YgaW5wdXRzKSB7XG4gICAgICBjb3VudElucHV0cysrO1xuICAgICAgYXJyLnB1c2goe1xuICAgICAgICBpZDogY291bnRJbnB1dHMsXG4gICAgICAgIGlzRmlyc3Q6IGNvdW50SW5wdXRzID09PSAxID8gdHJ1ZSA6IGZhbHNlLFxuICAgICAgICB0eXBlRGVmOiBpbnB1dC50eXBlLFxuICAgICAgICBuYW1lRGVmOiBpbnB1dC5uYW1lLFxuICAgICAgICB2YWx1ZURlZjogaW5wdXQudmFsdWUsXG4gICAgICB9KTtcbiAgICB9XG4gICAgaW5wdXRFbHMgPSBbLi4uaW5wdXRFbHMsIC4uLmFycl07XG4gIH1cblxuICAvKiogUmVtb3ZlIGlucHV0IGZyb20gaW5wdXRFbHMgKi9cbiAgYXN5bmMgZnVuY3Rpb24gcmVtb3ZlSW5wdXQoaWQ6IG51bWJlcikge1xuICAgIGlucHV0RWxzID0gaW5wdXRFbHMuZmlsdGVyKChpbnB1dCkgPT4gaW5wdXQuaWQgIT09IGlkKTtcbiAgICBhd2FpdCB0aWNrKCk7XG5cbiAgICAvL1NldCBmb2N1cyB0byBwcmV2aW91cyBpbnB1dC5cbiAgICBsZXQgaW5wdXRzOiBOb2RlTGlzdE9mPEhUTUxJbnB1dEVsZW1lbnQ+ID0gZm9ybUVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbnB1dFwiKTtcbiAgICBpZiAoIWlucHV0cykgcmV0dXJuO1xuXG4gICAgaW5wdXRzW2lucHV0cy5sZW5ndGggLSAyXS5mb2N1cygpO1xuICB9XG5cbiAgLyoqIFNlZSBpZiB0aGVyZSBhcmUgZHVwbGljYXRlIHByb3BlcnR5IG5hbWVzLiovXG4gIGZ1bmN0aW9uIGNoZWNrRHVwbGljYXRlTmFtZXMoKSB7XG4gICAgbGV0IHNldCA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGxldCBpbnB1dCBvZiBpbnB1dEVscykgc2V0LmFkZChpbnB1dC5uYW1lRGVmKTtcblxuICAgIGlmIChzZXQuc2l6ZSA8IGlucHV0RWxzLmxlbmd0aCkgcmV0dXJuIHRydWU7XG4gICAgZWxzZSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKiogRGlzcGxheSBhbiBlcnJvciBtZXNzYWdlLiAqL1xuICBmdW5jdGlvbiBydW5FcnJvcihlcnJvclRleHQ6IHN0cmluZykge1xuICAgIGFsZXJ0VGV4dCA9IGVycm9yVGV4dDtcbiAgICBlcnJvckVsLmNsYXNzTGlzdC5yZW1vdmUoXCJoaWRkZW5cIik7IC8vU2hvdWxkIEkgaGF2ZSB0aGlzIGVycm9yIG1lc3NhZ2UgZmFkZSBhd2F5P1xuICB9XG5cbiAgLyoqIFNlYXJjaCBmb3IgYWxsIGxhYmVscyBhbmQgdmFsdWVzLCBhZGQgdGhlbSB0byBhIG1hcCwgdGhlbiBwYXNzIHRoZW0gYmFjayB0byBtb2RhbC4qL1xuICBmdW5jdGlvbiBvblN1Ym1pdCgpIHtcbiAgICAvL01ha2Ugc3VyZSB0aGVyZSBhcmUgbm8gZHVwbGljYXRlIG5hbWVzLlxuICAgIGlmIChjaGVja0R1cGxpY2F0ZU5hbWVzKCkpIHtcbiAgICAgIHJ1bkVycm9yKFwiRHVwbGljYXRlIHByb3BlcnR5IG5hbWVzIGFyZSBub3QgYWxsb3dlZC5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IG9iajogTWFwPHN0cmluZywgTmV3UHJvcERhdGE+ID0gbmV3IE1hcCgpO1xuXG4gICAgbGV0IGlucHV0czogTm9kZUxpc3RPZjxIVE1MSW5wdXRFbGVtZW50PiA9IGZvcm1FbC5xdWVyeVNlbGVjdG9yQWxsKFxuICAgICAgJ2lucHV0W25hbWVePVwibmFtZVtdXCJdJ1xuICAgICk7XG5cbiAgICBpbnB1dHMuZm9yRWFjaCgoaW5wdXQpID0+IHtcbiAgICAgIC8vQ2hlY2sgZm9yIHByb3BlciBpbnB1dHMgYmVpbmcgbmV4dCB0byBlYWNoIG90aGVyLlxuICAgICAgaWYgKCEoaW5wdXQubmV4dEVsZW1lbnRTaWJsaW5nIGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCkpIHJldHVybjtcbiAgICAgIGlmICghKGlucHV0LnByZXZpb3VzRWxlbWVudFNpYmxpbmcgaW5zdGFuY2VvZiBIVE1MU2VsZWN0RWxlbWVudCkpIHJldHVybjtcbiAgICAgIGlmIChcbiAgICAgICAgIShpbnB1dC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLmNoaWxkcmVuWzBdIGluc3RhbmNlb2YgSFRNTE9wdGlvbkVsZW1lbnQpXG4gICAgICApXG4gICAgICAgIHJldHVybjtcbiAgICAgIC8vVE9ETzogSW1wbGVtZW50IGVycm9yIGhhbmRsaW5nIGlmIGlucHV0cyBhcmUgaW5hY2N1cmF0ZT9cbiAgICAgIC8vVGhlIGVudGlyZSBmb3JtIGlzIGRlcGVuZGVudCBvbiB0aGlzIHN0cnVjdHVyZSwgdGhvdWdoLlxuXG4gICAgICAvL0dldCBuYW1lLCB2YWx1ZSBhbmQgdHlwZSBmcm9tIGlucHV0cy5cbiAgICAgIGxldCBuYW1lID0gaW5wdXQudmFsdWU7XG4gICAgICBpZiAobmFtZSA9PT0gXCJcIikge1xuICAgICAgICBpbnB1dC5yZXBvcnRWYWxpZGl0eSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNlbGVjdEVsID0gaW5wdXQucHJldmlvdXNFbGVtZW50U2libGluZyBhcyBIVE1MU2VsZWN0RWxlbWVudDtcbiAgICAgIGNvbnN0IGh0bWxUeXBlID0gc2VsZWN0RWwudmFsdWU7XG5cbiAgICAgIGNvbnN0IHJldmVyc2VPcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBQcm9wZXJ0eVR5cGVzPiA9IHtcbiAgICAgICAgXCJzdHJpbmdcIjogXCJ0ZXh0XCIsXG4gICAgICAgIFwibnVtYmVyXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiY2hlY2tib3hcIjogXCJjaGVja2JveFwiLFxuICAgICAgICBcImRhdGVcIjogXCJkYXRlXCIsXG4gICAgICAgIFwiZGF0ZXRpbWUtbG9jYWxcIjogXCJkYXRldGltZVwiXG4gICAgICB9XG4gICAgICBjb25zdCBvYnNpZGlhblR5cGUgPSByZXZlcnNlT3B0aW9uc1todG1sVHlwZV0gPz8gJ3RleHQnO1xuXG4gICAgICBsZXQgdmFsdWU6IGFueSA9IHBhcnNlVmFsdWUoXG4gICAgICAgIGlucHV0Lm5leHRFbGVtZW50U2libGluZyxcbiAgICAgICAgaW5wdXQubmV4dEVsZW1lbnRTaWJsaW5nLnR5cGVcbiAgICAgICk7XG4gICAgICAvL0NoZWNrIGZvciB0YWdzLiAgQ2xlYW4gdGhlbSBvZiBhbnkgaW52YWxpZCBjaGFyYWN0ZXJzLCB0aGVuIHNwbGl0IGJ5IGNvbW1hLlxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAobmFtZSA9PT0gXCJ0YWdzXCIpIHtcbiAgICAgICAgICB2YWx1ZSA9IGNsZWFuVGFncyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUuaW5jbHVkZXMoXCIsXCIpKSB7XG4gICAgICAgICAgbGV0IHN0ciA9IHJlbW92ZUV4dHJhQ29tbWFzKHZhbHVlKTtcbiAgICAgICAgICB2YWx1ZSA9IHN0ci5zcGxpdChkZWxpbWl0ZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPT09IFwiXCIpIHZhbHVlID0gbnVsbDtcblxuICAgICAgLy9TdG9yZSBkYXRhIGludG8gb2JqZWN0LlxuICAgICAgbGV0IHByb3BPYmo6IE5ld1Byb3BEYXRhID0ge1xuICAgICAgICB0eXBlOiBvYnNpZGlhblR5cGUsXG4gICAgICAgIGRhdGE6IHZhbHVlLFxuICAgICAgICBvdmVyd3JpdGU6IGZhbHNlLFxuICAgICAgICBkZWxpbWl0ZXI6IGRlbGltaXRlcixcbiAgICAgIH07XG5cbiAgICAgIG9iai5zZXQobmFtZSwgcHJvcE9iaik7XG4gICAgfSk7XG5cbiAgICAvL1RPRE86IEVycm9yIGhhbmRsaW5nIGZvciB3aGVuIHVzZXIgc3VibWl0cyB3aXRoIGFuIGVtcHR5IG5hbWUuXG4gICAgLy9JbnB1dCB2YWxpZGF0aW9uIGRvZXNuJ3QgdHJpZ2dlciB1bmxlc3MgdGhpcyBjb2RlIGlzIGluLiAgV2h5PyAgSSBkaWRuJ3QgbmVlZCB0aGlzIGJlZm9yZS5cbiAgICBpZiAob2JqLnNpemUgPCBpbnB1dHMubGVuZ3RoKSByZXR1cm47XG5cbiAgICBjb25zb2xlLmxvZyhvYmopO1xuXG4gICAgc3VibWlzc2lvbihvYmopO1xuICB9XG48L3NjcmlwdD5cblxuPGRpdiBpZD1cIm11bHRpLXByb3BlcnRpZXMtbW9kYWxcIiBjbGFzcz1cIm1vZGFsLWNvbnRlbnRcIj5cbiAgPGRpdiBpZD1cImFsZXJ0LWNvbnRhaW5lclwiIGNsYXNzPVwiYWxlcnQtY29udGFpbmVyIGhpZGRlblwiIGJpbmQ6dGhpcz17ZXJyb3JFbH0+XG4gICAgPGRpdj5FUlJPUjwvZGl2PlxuICAgIDxkaXYgaWQ9XCJhbGVydC10ZXh0XCI+e2FsZXJ0VGV4dH08L2Rpdj5cbiAgPC9kaXY+XG4gIDxwPlxuICAgIFR5cGUgaW4gYSBwcm9wZXJ0eSBuYW1lLCB0aGVuIHZhbHVlLiBVc2UgdGhlIGRyb3Bib3ggdG8gY2hvb3NlIHdoYXQgdHlwZSBvZlxuICAgIGRhdGEgeW91IHdpc2ggdG8gc3RvcmUuXG4gIDwvcD5cbiAgPHA+XG4gICAgSWYgeW91IHdhbnQgdG8gbWFrZSBhIExpc3QgcHJvcGVydHksIHVzZSB0aGUgVGV4dCBkYXRhIHR5cGUgYW5kIHNlcGFyYXRlXG4gICAgZWFjaCB2YWx1ZSB3aXRoIGEgXCJ7ZGVsaW1pdGVyfVwiLlxuICA8L3A+XG4gIDxwPklmIHlvdSB3YW50IHRvIGFkZCBUYWdzLCB1c2UgdGhlIG5hbWUgXCJ0YWdzXCIuPC9wPlxuICA8Zm9ybSBvbjpzdWJtaXR8cHJldmVudERlZmF1bHQgYmluZDp0aGlzPXtmb3JtRWx9PlxuICAgIDxsYWJlbFxuICAgICAgPjxpbnB1dFxuICAgICAgICB0eXBlPVwiY2hlY2tib3hcIlxuICAgICAgICBjaGVja2VkPXtvdmVyd3JpdGV9XG4gICAgICAgIG9uOmNoYW5nZT17b25DaGVja2JveENoYW5nZX1cbiAgICAgIC8+e1wiT3ZlcndyaXRlIGV4aXN0aW5nIHByb3BlcnRpZXNcIn08L2xhYmVsXG4gICAgPlxuICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1pbnB1dHMtY29udGFpbmVyXCI+XG4gICAgICB7I2VhY2ggaW5wdXRFbHMgYXMgaW5wdXQgKGlucHV0LmlkKX1cbiAgICAgICAgPFByb3BJbnB1dFxuICAgICAgICAgIGlzRmlyc3Q9e2lucHV0LmlzRmlyc3R9XG4gICAgICAgICAgaWQ9e2lucHV0LmlkfVxuICAgICAgICAgIGJpbmQ6dHlwZVZhbD17aW5wdXQudHlwZURlZn1cbiAgICAgICAgICBiaW5kOm5hbWVWYWw9e2lucHV0Lm5hbWVEZWZ9XG4gICAgICAgICAgYmluZDp2YWx1ZVZhbD17aW5wdXQudmFsdWVEZWZ9XG4gICAgICAgICAge3JlbW92ZUlucHV0fVxuICAgICAgICAvPlxuICAgICAgey9lYWNofVxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1hZGQtY29udGFpbmVyXCI+XG4gICAgICA8YnV0dG9uXG4gICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICBvbjpjbGljaz17KCkgPT4gYWRkSW5wdXRzKFt7IHR5cGU6IFwidGV4dFwiLCBuYW1lOiBcIlwiLCB2YWx1ZTogXCJcIiB9XSl9XG4gICAgICAgIGNsYXNzPVwiYS1idG5cIlxuICAgICAgICA+QWRkPC9idXR0b25cbiAgICAgID5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwibW9kYWwtYnV0dG9uLWNvbnRhaW5lclwiPlxuICAgICAgPGJ1dHRvbiBvbjpjbGljaz17b25TdWJtaXR9IGNsYXNzPVwiYnRuLXN1Ym1pdFwiPlN1Ym1pdDwvYnV0dG9uPlxuICAgIDwvZGl2PlxuICA8L2Zvcm0+XG48L2Rpdj5cblxuPHN0eWxlPlxuICAubW9kYWwtaW5wdXRzLWNvbnRhaW5lciB7XG4gICAgaGVpZ2h0OiAyMDBweDtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBvdmVyZmxvdy15OiBzY3JvbGw7XG4gICAgYm9yZGVyLXJhZGl1czogNXB4O1xuICAgIGJvcmRlci1zdHlsZTogc29saWQ7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIH1cblxuICAubW9kYWwtYWRkLWNvbnRhaW5lciB7XG4gICAgbWFyZ2luLXRvcDogMTBweDtcbiAgfVxuICAuYWxlcnQtY29udGFpbmVyIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICBtYXJnaW4tYm90dG9tOiAxMHB4O1xuICAgIGJhY2tncm91bmQtY29sb3I6IHJlZDtcbiAgICBmb250LXdlaWdodDogYm9sZDtcbiAgfVxuICAuaGlkZGVuIHtcbiAgICBkaXNwbGF5OiBub25lO1xuICB9XG48L3N0eWxlPlxuIiwgIi8qKiBNb2RhbCB0byBob2xkIGZvcm0gdGhhdCBsZXRzIHVzZXIgcmVtb3ZlIHByb3BzIGZyb20gc2VsZWN0aW9uLiAqL1xuXG5pbXBvcnQgeyBNb2RhbCwgQXBwLCBOb3RpY2UgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCBBZGRDb25maXJtRm9ybSBmcm9tIFwiLi9BZGRDb25maXJtRm9ybS5zdmVsdGVcIjtcbmltcG9ydCB7IE5ld1Byb3BEYXRhIH0gZnJvbSBcIi4vbWFpblwiO1xuXG4vKiogTG9hZHMgYSBtb2RhbCBhbmQgaGFuZGxlcyBmb3JtIHN1Ym1pc3Npb25zLiAqL1xuZXhwb3J0IGNsYXNzIEFkZENvbmZpcm1Nb2RhbCBleHRlbmRzIE1vZGFsIHtcblx0cHJvcHM6IE1hcDxzdHJpbmcsIE5ld1Byb3BEYXRhPjtcblx0c3VibWlzc2lvbjogKGJvb2w6IGJvb2xlYW4pID0+IFByb21pc2U8dm9pZD47XG5cdG92ZXJ3cml0ZTogYm9vbGVhbjtcblx0Y29tcG9uZW50OiBBZGRDb25maXJtRm9ybTtcblxuXHRjb25zdHJ1Y3Rvcihcblx0XHRhcHA6IEFwcCxcblx0XHRwcm9wczogTWFwPHN0cmluZywgTmV3UHJvcERhdGE+LFxuXHRcdG92ZXJ3cml0ZTogYm9vbGVhbixcblx0XHRzdWJtaXNzaW9uOiAoYm9vbDogYm9vbGVhbikgPT4gUHJvbWlzZTx2b2lkPlxuXHQpIHtcblx0XHRzdXBlcihhcHApO1xuXHRcdHRoaXMucHJvcHMgPSBwcm9wcztcblx0XHR0aGlzLm92ZXJ3cml0ZSA9IG92ZXJ3cml0ZTtcblx0XHR0aGlzLnN1Ym1pc3Npb24gPSBzdWJtaXNzaW9uO1xuXHR9XG5cdGFzeW5jIG9uU3VibWl0KCkge1xuXHRcdGF3YWl0IHRoaXMuc3VibWlzc2lvbih0cnVlKTtcblx0XHR0aGlzLmNsb3NlKCk7XG5cdH1cblxuXHRvbkNhbmNlbCgpIHtcblx0XHR0aGlzLnN1Ym1pc3Npb24oZmFsc2UpO1xuXHRcdHRoaXMuY2xvc2UoKTtcblx0fVxuXG5cdG9uT3BlbigpOiB2b2lkIHtcblx0XHR0aGlzLnRpdGxlRWwuY3JlYXRlRWwoXCJoMlwiLCB7IHRleHQ6IFwiQWRkIFByb3BlcnRpZXNcIiB9KTtcblxuXHRcdHRoaXMuY29tcG9uZW50ID0gbmV3IEFkZENvbmZpcm1Gb3JtKHtcblx0XHRcdHRhcmdldDogdGhpcy5jb250ZW50RWwsXG5cdFx0XHRwcm9wczoge1xuXHRcdFx0XHRwcm9wczogdGhpcy5wcm9wcyxcblx0XHRcdFx0b3ZlcndyaXRlOiB0aGlzLm92ZXJ3cml0ZSxcblx0XHRcdFx0c3VibWlzc2lvbjogdGhpcy5vblN1Ym1pdC5iaW5kKHRoaXMpLFxuXHRcdFx0XHRjYW5jZWw6IHRoaXMub25DYW5jZWwuYmluZCh0aGlzKSxcblx0XHRcdH0sXG5cdFx0fSk7XG5cdH1cbn1cbiIsICI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxyXG5cdGltcG9ydCB7IG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XHJcblx0aW1wb3J0IHsgTmV3UHJvcERhdGEgfSBmcm9tIFwiLi9tYWluXCI7XHJcblxyXG5cdGV4cG9ydCBsZXQgcHJvcHM6IE1hcDxzdHJpbmcsIE5ld1Byb3BEYXRhPjtcclxuXHRleHBvcnQgbGV0IG92ZXJ3cml0ZTogYm9vbGVhbiA9IHRydWU7XHJcblx0ZXhwb3J0IGxldCBzdWJtaXNzaW9uOiAoKSA9PiB2b2lkO1xyXG5cdGV4cG9ydCBsZXQgY2FuY2VsOiAoKSA9PiB2b2lkO1xyXG5cclxuXHRsZXQgYnRuQ2FuY2VsOiBIVE1MQnV0dG9uRWxlbWVudDtcclxuXHJcblx0Y29uc3QgbXNnID0gb3ZlcndyaXRlXHJcblx0XHQ/IFwiQW55IHByZS1leGlzdGluZyB0ZXh0IHByb3BzIHdpbGwgaGF2ZSB0aGVpciB2YWx1ZXMgb3ZlcndyaXR0ZW4uXCJcclxuXHRcdDogXCJBbnkgcHJlLWV4aXN0aW5nIHRleHQgcHJvcHMgd2lsbCBoYXZlIHRoZWlyIHZhbHVlcyBiZSBhcHBlbmRlZCB0by5cIjtcclxuXHJcblx0Ly9Gb2N1cyBvbiBjYW5jZWwgdG8gbWFrZSBzdXJlIHVzZXIgZG9lcyBub3QgZWFzaWx5IHN1Ym1pdCBjaGFuZ2VzLlxyXG5cdG9uTW91bnQoKCkgPT4ge1xyXG5cdFx0YnRuQ2FuY2VsLmZvY3VzKCk7XHJcblx0fSk7XHJcbjwvc2NyaXB0PlxyXG5cclxuPGRpdj5cclxuXHQ8Zm9ybSBvbjpzdWJtaXR8cHJldmVudERlZmF1bHQ9e3N1Ym1pc3Npb259PlxyXG5cdFx0PHAgY2xhc3M9XCJtc2dcIj57bXNnfTwvcD5cclxuXHRcdDxwPlRoZSBmb2xsb3dpbmcgcHJvcHMgd2lsbCBiZSBhZGRlZDo8L3A+XHJcblx0XHQ8dWw+XHJcblx0XHRcdHsjZWFjaCBbLi4ucHJvcHNdIGFzIFtwcm9wTmFtZSwgcHJvcF19XHJcblx0XHRcdFx0PGxpPlxyXG5cdFx0XHRcdFx0e3Byb3BOYW1lfToge3Byb3AuZGF0YX1cclxuXHRcdFx0XHQ8L2xpPlxyXG5cdFx0XHR7L2VhY2h9XHJcblx0XHQ8L3VsPlxyXG5cdFx0PHA+QXJlIHlvdSBzdXJlIHlvdSB3aXNoIHRvIHByb2NlZWQ/PC9wPlxyXG5cdFx0PGJ1dHRvbiBjbGFzcz1cIm1vZC13YXJuaW5nXCIgdHlwZT1cInN1Ym1pdFwiPkNvbmZpcm08L2J1dHRvbj5cclxuXHRcdDxidXR0b24gb246Y2xpY2s9e2NhbmNlbH0gYmluZDp0aGlzPXtidG5DYW5jZWx9PkNhbmNlbDwvYnV0dG9uPlxyXG5cdDwvZm9ybT5cclxuPC9kaXY+XHJcblxyXG48c3R5bGU+XHJcblx0Lm1zZyB7XHJcblx0XHRmb250LXdlaWdodDogYm9sZDtcclxuXHRcdHBhZGRpbmctYm90dG9tOiAxMHB4O1xyXG5cdH1cclxuPC9zdHlsZT5cclxuIiwgImltcG9ydCB7IEFwcCwgU3VnZ2VzdE1vZGFsIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgeyBTdWdnZXN0aW9uTWFuYWdlciwgU2VsZWN0YWJsZUl0ZW0gfSBmcm9tIFwiLi9TdWdnZXN0aW9uTWFuYWdlclwiO1xuXG5leHBvcnQgY2xhc3MgTXVsdGlTZWxlY3RTdWdnZXN0TW9kYWwgZXh0ZW5kcyBTdWdnZXN0TW9kYWw8U2VsZWN0YWJsZUl0ZW0+IHtcbiAgICBwcml2YXRlIHN1Z2dlc3Rpb25NYW5hZ2VyOiBTdWdnZXN0aW9uTWFuYWdlcjtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBhcHA6IEFwcCxcbiAgICAgICAgYXZhaWxhYmxlVmFsdWVzOiBzdHJpbmdbXSxcbiAgICAgICAgcHJlc2VsZWN0ZWQ6IHN0cmluZ1tdID0gW10sXG4gICAgICAgIHByaXZhdGUgb25TdWJtaXQ6IChzZWxlY3RlZDogc3RyaW5nW10pID0+IHZvaWQsXG4gICAgICAgIHByaXZhdGUgYWxsb3dOZXdWYWx1ZXMgPSB0cnVlXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKGFwcCk7XG4gICAgICAgIHRoaXMuc3VnZ2VzdGlvbk1hbmFnZXIgPSBuZXcgU3VnZ2VzdGlvbk1hbmFnZXIoYXZhaWxhYmxlVmFsdWVzLCBwcmVzZWxlY3RlZCk7XG4gICAgICAgIHRoaXMuc2V0UGxhY2Vob2xkZXIoJ1R5cGUgdG8gc2VhcmNoLCBFbnRlciB0byBzZWxlY3QvZGVzZWxlY3QsIFNoaWZ0K0VudGVyIHRvIGZpbmlzaCcpO1xuICAgICAgICB0aGlzLnNldEluc3RydWN0aW9ucyhbXG4gICAgICAgICAgICB7IGNvbW1hbmQ6ICdFbnRlcicsIHB1cnBvc2U6ICdUb2dnbGUgc2VsZWN0aW9uJyB9LFxuICAgICAgICAgICAgeyBjb21tYW5kOiAnU2hpZnQrRW50ZXInLCBwdXJwb3NlOiAnQ29uZmlybSBzZWxlY3Rpb24nIH0sXG4gICAgICAgICAgICB7IGNvbW1hbmQ6ICdFc2NhcGUnLCBwdXJwb3NlOiAnQ2FuY2VsJyB9XG4gICAgICAgIF0pO1xuICAgIH1cblxuICAgIGdldFN1Z2dlc3Rpb25zKHF1ZXJ5OiBzdHJpbmcpOiBTZWxlY3RhYmxlSXRlbVtdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VnZ2VzdGlvbk1hbmFnZXIuZ2V0U3VnZ2VzdGlvbnMocXVlcnksIHRoaXMuYWxsb3dOZXdWYWx1ZXMpO1xuICAgIH1cblxuICAgIHJlbmRlclN1Z2dlc3Rpb24oaXRlbTogU2VsZWN0YWJsZUl0ZW0sIGVsOiBIVE1MRWxlbWVudCkge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSBlbC5jcmVhdGVEaXYoeyBjbHM6ICdtdWx0aS1zZWxlY3Qtc3VnZ2VzdGlvbicgfSk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBjaGVja2JveCA9IGNvbnRhaW5lci5jcmVhdGVTcGFuKHsgXG4gICAgICAgICAgICBjbHM6IGl0ZW0uc2VsZWN0ZWQgPyAnY2hlY2tib3gtY2hlY2tlZCcgOiAnY2hlY2tib3gtdW5jaGVja2VkJyxcbiAgICAgICAgICAgIHRleHQ6IGl0ZW0uc2VsZWN0ZWQgPyAnXHUyNjExXHVGRTBGJyA6ICdcdTI2MTAnXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgdGV4dCA9IGNvbnRhaW5lci5jcmVhdGVTcGFuKHsgXG4gICAgICAgICAgICB0ZXh0OiBpdGVtLnZhbHVlLFxuICAgICAgICAgICAgY2xzOiBpdGVtLnNlbGVjdGVkID8gJ3NlbGVjdGVkLWl0ZW0nIDogJydcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGl0ZW0uc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5hZGRDbGFzcygnaXMtc2VsZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uQ2hvb3NlU3VnZ2VzdGlvbihpdGVtOiBTZWxlY3RhYmxlSXRlbSwgZXZ0OiBNb3VzZUV2ZW50IHwgS2V5Ym9hcmRFdmVudCkge1xuICAgICAgICBsZXQgdmFsdWVUb1N1Ym1pdDogc3RyaW5nO1xuXG4gICAgICAgIGlmIChpdGVtLnZhbHVlLnN0YXJ0c1dpdGgoJ0NyZWF0ZTogXCInKSkge1xuICAgICAgICAgICAgdmFsdWVUb1N1Ym1pdCA9IGl0ZW0udmFsdWUucmVwbGFjZSgnQ3JlYXRlOiBcIicsICcnKS5yZXBsYWNlKCdcIicsICcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlVG9TdWJtaXQgPSBpdGVtLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBTdWJtaXQgdGhlIHNpbmdsZSBzZWxlY3RlZCB2YWx1ZSBpbW1lZGlhdGVseVxuICAgICAgICB0aGlzLm9uU3VibWl0KFt2YWx1ZVRvU3VibWl0XSk7XG4gICAgICAgIC8vIE5vIG5lZWQgdG8gcmVmcmVzaCBzdWdnZXN0aW9ucywgYXMgdGhlIG1vZGFsIHdpbGwgY2xvc2VcbiAgICB9XG5cbiAgICBwcml2YXRlIHJlZnJlc2hTdWdnZXN0aW9ucygpIHtcbiAgICAgICAgY29uc3QgaW5wdXRFbCA9IHRoaXMuaW5wdXRFbDtcbiAgICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gaW5wdXRFbC52YWx1ZTtcbiAgICAgICAgaW5wdXRFbC52YWx1ZSA9IGN1cnJlbnRWYWx1ZSArICcgJztcbiAgICAgICAgaW5wdXRFbC52YWx1ZSA9IGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgaW5wdXRFbC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnaW5wdXQnKSk7XG4gICAgfVxuXG4gICAgLy8gRXhwb3NlIGZvciB0ZXN0aW5nXG4gICAgZ2V0U2VsZWN0ZWRJdGVtcygpOiBzdHJpbmdbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1Z2dlc3Rpb25NYW5hZ2VyLmdldFNlbGVjdGVkVmFsdWVzKCk7XG4gICAgfVxufVxuIiwgImV4cG9ydCBpbnRlcmZhY2UgU2VsZWN0YWJsZUl0ZW0ge1xuICAgIHZhbHVlOiBzdHJpbmc7XG4gICAgc2VsZWN0ZWQ6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjbGFzcyBTdWdnZXN0aW9uTWFuYWdlciB7XG4gIHByaXZhdGUgaXRlbXM6IFNlbGVjdGFibGVJdGVtW10gPSBbXTtcbiAgcHJpdmF0ZSBzZWxlY3RlZEl0ZW1zID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cbiAgY29uc3RydWN0b3IoYXZhaWxhYmxlVmFsdWVzOiBzdHJpbmdbXSwgcHJlc2VsZWN0ZWQ6IHN0cmluZ1tdID0gW10pIHtcbiAgICB0aGlzLml0ZW1zID0gYXZhaWxhYmxlVmFsdWVzLm1hcCh2YWx1ZSA9PiAoe1xuICAgICAgdmFsdWUsXG4gICAgICBzZWxlY3RlZDogcHJlc2VsZWN0ZWQuaW5jbHVkZXModmFsdWUpXG4gICAgfSkpO1xuICAgIHByZXNlbGVjdGVkLmZvckVhY2goaXRlbSA9PiB0aGlzLnNlbGVjdGVkSXRlbXMuYWRkKGl0ZW0pKTtcbiAgfVxuXG4gIHRvZ2dsZVNlbGVjdGlvbih2YWx1ZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuaXRlbXMuZmluZChpID0+IGkudmFsdWUgPT09IHZhbHVlKTtcbiAgICBpZiAoIWl0ZW0pIHJldHVybiBmYWxzZTtcblxuICAgIGl0ZW0uc2VsZWN0ZWQgPSAhaXRlbS5zZWxlY3RlZDtcbiAgICBpZiAoaXRlbS5zZWxlY3RlZCkge1xuICAgICAgdGhpcy5zZWxlY3RlZEl0ZW1zLmFkZCh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VsZWN0ZWRJdGVtcy5kZWxldGUodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbS5zZWxlY3RlZDtcbiAgfVxuXG4gIGdldFNlbGVjdGVkVmFsdWVzKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnNlbGVjdGVkSXRlbXMpO1xuICB9XG5cbiAgZ2V0U3VnZ2VzdGlvbnMocXVlcnk6IHN0cmluZywgYWxsb3dOZXdWYWx1ZXM6IGJvb2xlYW4pOiBTZWxlY3RhYmxlSXRlbVtdIHtcbiAgICBjb25zdCBmaWx0ZXJlZCA9IHRoaXMuaXRlbXMuZmlsdGVyKGl0ZW0gPT5cbiAgICAgIGl0ZW0udmFsdWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhxdWVyeS50b0xvd2VyQ2FzZSgpKVxuICAgICk7XG5cbiAgICBpZiAoYWxsb3dOZXdWYWx1ZXMgJiYgcXVlcnkgJiYgXG4gICAgICAgICF0aGlzLml0ZW1zLnNvbWUoaXRlbSA9PiBpdGVtLnZhbHVlLnRvTG93ZXJDYXNlKCkgPT09IHF1ZXJ5LnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgIGZpbHRlcmVkLnVuc2hpZnQoe1xuICAgICAgICAgICAgdmFsdWU6IGBDcmVhdGU6IFwiJHtxdWVyeX1cImAsXG4gICAgICAgICAgICBzZWxlY3RlZDogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbHRlcmVkO1xuICB9XG5cbiAgaGFuZGxlU3VibWlzc2lvbihldnQ6IEtleWJvYXJkRXZlbnQsIG9uU3VibWl0OiAodmFsdWVzOiBzdHJpbmdbXSkgPT4gdm9pZCk6IGJvb2xlYW4ge1xuICAgIGlmIChldnQuc2hpZnRLZXkgJiYgZXZ0LmtleSA9PT0gJ0VudGVyJykge1xuICAgICAgb25TdWJtaXQodGhpcy5nZXRTZWxlY3RlZFZhbHVlcygpKTtcbiAgICAgIHJldHVybiB0cnVlOyAvLyBJbmRpY2F0ZXMgc3VibWlzc2lvbiBvY2N1cnJlZFxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjcmVhdGVOZXdWYWx1ZSh2YWx1ZTogc3RyaW5nKSB7XG4gICAgaWYgKCF0aGlzLml0ZW1zLnNvbWUoaXRlbSA9PiBpdGVtLnZhbHVlID09PSB2YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5pdGVtcy5wdXNoKHsgdmFsdWUsIHNlbGVjdGVkOiB0cnVlIH0pO1xuICAgICAgICB0aGlzLnNlbGVjdGVkSXRlbXMuYWRkKHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBQbHVnaW5TZXR0aW5nVGFiLCBBcHAsIFNldHRpbmcsIE5vdGljZSB9IGZyb20gXCJvYnNpZGlhblwiO1xuXG5pbXBvcnQgTXVsdGlQcm9wUGx1Z2luIGZyb20gXCIuL21haW5cIjtcblxuZXhwb3J0IGNsYXNzIFNldHRpbmdUYWIgZXh0ZW5kcyBQbHVnaW5TZXR0aW5nVGFiIHtcbiAgcGx1Z2luOiBNdWx0aVByb3BQbHVnaW47XG5cbiAgY29uc3RydWN0b3IoYXBwOiBBcHAsIHBsdWdpbjogTXVsdGlQcm9wUGx1Z2luKSB7XG4gICAgc3VwZXIoYXBwLCBwbHVnaW4pO1xuICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xuICB9XG5cbiAgZGlzcGxheSgpIHtcbiAgICBsZXQgeyBjb250YWluZXJFbCB9ID0gdGhpcztcbiAgICBjb250YWluZXJFbC5lbXB0eSgpO1xuXG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAuc2V0TmFtZShcIk92ZXJ3cml0ZSBleGlzdGluZyB0ZXh0XCIpXG4gICAgICAuc2V0RGVzYyhcbiAgICAgICAgXCJXaGVuIGFkZGluZyBhIHByb3BlcnR5IHdpdGggYSBuYW1lIHRoYXQgYWxyZWFkeSBleGlzdHMsIHRoZSB0ZXh0IHdpbGwgb3ZlcndyaXRlIHRoZSBwcm9wJ3MgZXhpc3RpbmcgdmFsdWUuICBJZiBsZWZ0IGRpc2FibGVkLCB0aGUgbmV3IHZhbHVlIHdpbGwgYmUgYXBwZW5kZWQgdG8gdGhlIG9sZCBhcyBhIExpc3QuXCJcbiAgICAgIClcbiAgICAgIC5hZGRUb2dnbGUoKHRvZ2dsZTogYW55KSA9PiB7XG4gICAgICAgIHRvZ2dsZS5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5vdmVyd3JpdGUpO1xuICAgICAgICB0b2dnbGUub25DaGFuZ2UoYXN5bmMgKHZhbHVlOiBib29sZWFuKSA9PiB7XG4gICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Mub3ZlcndyaXRlID0gdmFsdWU7XG4gICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgIC5zZXROYW1lKFwiUmVjdXJzaXZlIEl0ZXJhdGlvblwiKVxuICAgICAgLnNldERlc2MoXG4gICAgICAgIFwiV2hlbiB0b2dnbGVkIG9uLCB3aGlsZSBsb29waW5nIHRocm91Z2ggYWxsIGZpbGVzIGluIGEgZm9sZGVyLCB5b3Ugd2lsbCBhbHNvIGxvb3AgdGhyb3VnaCBhbnkgc3ViLWZvbGRlcnMuXCJcbiAgICAgIClcbiAgICAgIC5hZGRUb2dnbGUoKHRvZ2dsZTogYW55KSA9PiB7XG4gICAgICAgIHRvZ2dsZS5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5yZWN1cnNpdmUpO1xuICAgICAgICB0b2dnbGUub25DaGFuZ2UoYXN5bmMgKHZhbHVlOiBib29sZWFuKSA9PiB7XG4gICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MucmVjdXJzaXZlID0gdmFsdWU7XG4gICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgIC5zZXROYW1lKFwiTGlzdCBEZWxpbWl0ZXJcIilcbiAgICAgIC5zZXREZXNjKFxuICAgICAgICBcIlNldCBkZWxpbWl0ZXIgdG8gdXNlIHdoZW4gY3JlYXRpbmcgYSBsaXN0LiAgQ29tbWFzKCwpIGFyZSB1c2VkIGJ5IGRlZmF1bHQuXCJcbiAgICAgIClcbiAgICAgIC5hZGRUZXh0KCh0ZXh0OiBhbnkpID0+IHtcbiAgICAgICAgdGV4dC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5kZWxpbWl0ZXIpO1xuICAgICAgICB0ZXh0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRleHQuc2V0VmFsdWUodmFsdWVbMF0pO1xuICAgICAgICAgICAgbmV3IE5vdGljZShcIkRlbGltaXRlciBtdXN0IGJlIGEgc2luZ2xlIGNoYXJhY3Rlci5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmRlbGltaXRlciA9IHZhbHVlO1xuICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAuc2V0TmFtZShcIkRlZmF1bHQgUHJvcHMgRmlsZVwiKVxuICAgICAgLnNldERlc2MoXG4gICAgICAgIFwiU2VsZWN0IGEgZmlsZSB3aXRoIHByb3BlcnRpZXMgdGhhdCB5b3Ugd2FudCB0byBsb2FkIGludG8gdGhlIE11bHRpIFByb3BlcnRpZXMgZm9ybSBieSBkZWZhdWx0LiAgVHlwZSBpbiB0aGUgZnVsbCBwYXRoIG9mIHRoZSBkZXNpcmVkIGZpbGUuKGV4LiBUZW1wbGF0ZXMvUHJvcEZpbGUgMSlcIlxuICAgICAgKVxuICAgICAgLmFkZFRleHQoKHRleHQ6IGFueSkgPT4ge1xuICAgICAgICB0ZXh0LnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmRlZmF1bHRQcm9wUGF0aCk7XG4gICAgICAgIHRleHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5kZWZhdWx0UHJvcFBhdGggPSB2YWx1ZTtcbiAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIE11bHRpUHJvcFNldHRpbmdzIHtcbiAgb3ZlcndyaXRlOiBib29sZWFuO1xuICByZWN1cnNpdmU6IGJvb2xlYW47XG4gIGRlbGltaXRlcjogc3RyaW5nO1xuICBkZWZhdWx0UHJvcFBhdGg6IHN0cmluZztcbn1cbiIsICIvKiogTW9kYWwgdG8gaG9sZCBmb3JtIHRoYXQgbGV0cyB1c2VyIHJlbW92ZSBwcm9wcyBmcm9tIHNlbGVjdGlvbi4gKi9cblxuaW1wb3J0IHsgTW9kYWwsIEFwcCwgTm90aWNlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgUmVtb3ZlUHJvcEZvcm0gZnJvbSBcIi4vUmVtb3ZlUHJvcEZvcm0uc3ZlbHRlXCI7XG5pbXBvcnQgeyBSZW1vdmVDb25maXJtTW9kYWwgfSBmcm9tIFwiLi9SZW1vdmVDb25maXJtTW9kYWxcIjtcblxuLyoqIExvYWRzIGEgbW9kYWwgYW5kIGhhbmRsZXMgZm9ybSBzdWJtaXNzaW9ucy4gKi9cbmV4cG9ydCBjbGFzcyBSZW1vdmVNb2RhbCBleHRlbmRzIE1vZGFsIHtcbiAgbmFtZXM6IHN0cmluZ1tdO1xuICBwcm9wczogc3RyaW5nW107XG4gIHN1Ym1pc3Npb246IChjdXN0b21Qcm9wczogc3RyaW5nW10pID0+IFByb21pc2U8dm9pZD47XG4gIGNvbXBvbmVudDogUmVtb3ZlUHJvcEZvcm07XG5cbiAgY29uc3RydWN0b3IoXG4gICAgYXBwOiBBcHAsXG4gICAgbmFtZXM6IHN0cmluZ1tdLFxuICAgIHN1Ym1pc3Npb246IChjdXN0b21Qcm9wczogc3RyaW5nW10pID0+IFByb21pc2U8dm9pZD5cbiAgKSB7XG4gICAgaWYgKCFuYW1lcyB8fCBuYW1lcy5sZW5ndGggPT09IDApIHtcbiAgICAgIG5ldyBOb3RpY2UoXCJObyBwcm9wZXJ0aWVzIHRvIHJlbW92ZVwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIoYXBwKTtcbiAgICB0aGlzLm5hbWVzID0gbmFtZXM7XG4gICAgdGhpcy5zdWJtaXNzaW9uID0gc3VibWlzc2lvbjtcbiAgfVxuXG4gIGFzeW5jIG9uQ29uZmlybShib29sOiBib29sZWFuKSB7XG4gICAgaWYgKGJvb2wpIHtcbiAgICAgIGF3YWl0IHRoaXMuc3VibWlzc2lvbih0aGlzLnByb3BzKTtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9XG4gIH1cblxuICBvblN1Ym1pdChwcm9wczogc3RyaW5nW10pIHtcbiAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgbmV3IFJlbW92ZUNvbmZpcm1Nb2RhbChcbiAgICAgIHRoaXMuYXBwLFxuICAgICAgdGhpcy5wcm9wcyxcbiAgICAgIHRoaXMub25Db25maXJtLmJpbmQodGhpcylcbiAgICApLm9wZW4oKTtcbiAgfVxuXG4gIG9uT3BlbigpOiB2b2lkIHtcbiAgICB0aGlzLnRpdGxlRWwuY3JlYXRlRWwoXCJoMlwiLCB7IHRleHQ6IFwiUmVtb3ZlIFByb3BlcnRpZXNcIiB9KTtcblxuICAgIHRoaXMuY29tcG9uZW50ID0gbmV3IFJlbW92ZVByb3BGb3JtKHtcbiAgICAgIHRhcmdldDogdGhpcy5jb250ZW50RWwsXG4gICAgICBwcm9wczoge1xuICAgICAgICBuYW1lczogdGhpcy5uYW1lcyxcbiAgICAgICAgc3VibWlzc2lvbjogdGhpcy5vblN1Ym1pdC5iaW5kKHRoaXMpLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxufVxuIiwgIjxzY3JpcHQgbGFuZz1cInRzXCI+XHJcbiAgZXhwb3J0IGxldCBuYW1lczogc3RyaW5nW10gPSBbXTtcclxuICBleHBvcnQgbGV0IHN1Ym1pc3Npb246IChwcm9wczogc3RyaW5nW10pID0+IHZvaWQ7XHJcblxyXG4gIGxldCBlcnJvckVsOiBIVE1MRGl2RWxlbWVudDtcclxuICBsZXQgYWxlcnRUZXh0ID0gXCIuXCI7XHJcbiAgLy9sZXQgcHJvcE5hbWVzOiBzdHJpbmdbXSA9IFtdO1xyXG5cclxuICBsZXQgY2hlY2tDb3VudCA9IDA7XHJcbiAgJDogaXNNYXhDaGVja2VkID0gY2hlY2tDb3VudCA+PSBuYW1lcy5sZW5ndGg7XHJcbiAgJDogY29uc29sZS5sb2coaXNNYXhDaGVja2VkKTtcclxuXHJcbiAgbGV0IGlucHV0czogeyBuYW1lOiBzdHJpbmc7IGlzQ2hlY2tlZDogYm9vbGVhbiB9W10gPSBbXTtcclxuICBmb3IgKGxldCBuYW1lIG9mIG5hbWVzKSB7XHJcbiAgICBpbnB1dHMucHVzaCh7IG5hbWUsIGlzQ2hlY2tlZDogZmFsc2UgfSk7XHJcbiAgfVxyXG5cclxuICBuYW1lcy5zb3J0KCk7XHJcblxyXG4gIC8vIGZ1bmN0aW9uIGhhbmRsZUNoZWNrYm94Q2hhbmdlKGV2ZW50OiBhbnksIHN0cmluZzogc3RyaW5nKSB7XHJcbiAgLy8gXHRjb25zdCBpc0NoZWNrZWQgPSBldmVudC50YXJnZXQuY2hlY2tlZDtcclxuICAvLyBcdGlmIChpc0NoZWNrZWQpIHtcclxuICAvLyBcdFx0cHJvcE5hbWVzID0gWy4uLnByb3BOYW1lcywgc3RyaW5nXTtcclxuICAvLyBcdH0gZWxzZSB7XHJcbiAgLy8gXHRcdHByb3BOYW1lcyA9IHByb3BOYW1lcy5maWx0ZXIoKHNlbGVjdGVkKSA9PiBzZWxlY3RlZCAhPT0gc3RyaW5nKTtcclxuICAvLyBcdH1cclxuICAvLyB9XHJcblxyXG4gIGZ1bmN0aW9uIG9uQ2hlY2tib3hDaGFuZ2UoZXZlbnQ6IGFueSkge1xyXG4gICAgbGV0IGNoZWNrZWQgPSBldmVudC50YXJnZXQuY2hlY2tlZDtcclxuICAgIGNoZWNrZWQgPyBjaGVja0NvdW50KysgOiBjaGVja0NvdW50LS07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB0b2dnbGVBbGwoKSB7XHJcbiAgICBpZiAoaXNNYXhDaGVja2VkKSB7XHJcbiAgICAgIGlucHV0cyA9IGlucHV0cy5tYXAoKGlucHV0KSA9PiAoeyAuLi5pbnB1dCwgaXNDaGVja2VkOiBmYWxzZSB9KSk7XHJcbiAgICAgIGNoZWNrQ291bnQgPSAwO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaW5wdXRzID0gaW5wdXRzLm1hcCgoaW5wdXQpID0+ICh7IC4uLmlucHV0LCBpc0NoZWNrZWQ6IHRydWUgfSkpO1xyXG4gICAgICBjaGVja0NvdW50ID0gbmFtZXMubGVuZ3RoO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gb25TdWJtaXQoKSB7XHJcbiAgICBpZiAoY2hlY2tDb3VudCA9PT0gMCkge1xyXG4gICAgICBhbGVydFRleHQgPSBcIlBsZWFzZSBzZWxlY3QgYXQgbGVhc3Qgb25lIHByb3BlcnR5IHRvIHJlbW92ZS5cIjtcclxuICAgICAgZXJyb3JFbC5jbGFzc0xpc3QucmVtb3ZlKFwiaGlkZGVuXCIpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBsZXQgcHJvcE5hbWVzID0gaW5wdXRzXHJcbiAgICAgIC5maWx0ZXIoKGlucHV0KSA9PiBpbnB1dC5pc0NoZWNrZWQpXHJcbiAgICAgIC5tYXAoKGlucHV0KSA9PiBpbnB1dC5uYW1lKTtcclxuICAgIHN1Ym1pc3Npb24ocHJvcE5hbWVzKTtcclxuICB9XHJcbjwvc2NyaXB0PlxyXG5cclxuPGRpdj5cclxuICA8ZGl2IGlkPVwiYWxlcnQtY29udGFpbmVyXCIgY2xhc3M9XCJhbGVydC1jb250YWluZXIgaGlkZGVuXCIgYmluZDp0aGlzPXtlcnJvckVsfT5cclxuICAgIDxkaXY+RVJST1I8L2Rpdj5cclxuICAgIDxkaXYgaWQ9XCJhbGVydC10ZXh0XCI+e2FsZXJ0VGV4dH08L2Rpdj5cclxuICA8L2Rpdj5cclxuICA8cD5TZWxlY3QgdGhlIHByb3BlcnRpZXMgeW91IHdpc2ggdG8gcmVtb3ZlIGZyb20gdGhlIGZpbGUgc2VsZWN0aW9uLjwvcD5cclxuICA8Zm9ybSBvbjpzdWJtaXR8cHJldmVudERlZmF1bHQ+XHJcbiAgICA8ZGl2IGNsYXNzPVwibmFtZS1jb250YWluZXJcIj5cclxuICAgICAgeyNlYWNoIGlucHV0cyBhcyBpbnB1dH1cclxuICAgICAgICA8bGFiZWw+XHJcbiAgICAgICAgICA8aW5wdXRcclxuICAgICAgICAgICAgdHlwZT1cImNoZWNrYm94XCJcclxuICAgICAgICAgICAgYmluZDp2YWx1ZT17aW5wdXQubmFtZX1cclxuICAgICAgICAgICAgYmluZDpjaGVja2VkPXtpbnB1dC5pc0NoZWNrZWR9XHJcbiAgICAgICAgICAgIG9uOmNoYW5nZT17KGV2ZW50KSA9PiBvbkNoZWNrYm94Q2hhbmdlKGV2ZW50KX1cclxuICAgICAgICAgIC8+XHJcbiAgICAgICAgICB7aW5wdXQubmFtZX1cclxuICAgICAgICA8L2xhYmVsPlxyXG4gICAgICB7L2VhY2h9XHJcbiAgICA8L2Rpdj5cclxuICAgIDxkaXYgY2xhc3M9XCJidXR0b24tY29udGFpbmVyXCI+XHJcbiAgICAgIDxidXR0b24gb246Y2xpY2s9e29uU3VibWl0fSB0eXBlPVwic3VibWl0XCI+Q29uZmlybTwvYnV0dG9uPlxyXG4gICAgICA8YnV0dG9uIG9uOmNsaWNrPXt0b2dnbGVBbGx9XHJcbiAgICAgICAgPntpc01heENoZWNrZWQgPyBcIlVuY2hlY2sgQWxsXCIgOiBcIkNoZWNrIEFsbFwifTwvYnV0dG9uXHJcbiAgICAgID5cclxuICAgIDwvZGl2PlxyXG4gIDwvZm9ybT5cclxuPC9kaXY+XHJcblxyXG48c3R5bGU+XHJcbiAgLm5hbWUtY29udGFpbmVyIHtcclxuICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xyXG4gICAgZ2FwOiA1cHg7XHJcbiAgICBtYXJnaW4tdG9wOiAxMHB4O1xyXG4gICAgbWFyZ2luLWJvdHRvbTogMjBweDtcclxuICB9XHJcbiAgLmFsZXJ0LWNvbnRhaW5lciB7XHJcbiAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcclxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XHJcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcclxuICAgIG1hcmdpbi1ib3R0b206IDEwcHg7XHJcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZWQ7XHJcbiAgICBmb250LXdlaWdodDogYm9sZDtcclxuICB9XHJcblxyXG4gIC5idXR0b24tY29udGFpbmVyIHtcclxuICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xyXG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xyXG4gIH1cclxuICAuaGlkZGVuIHtcclxuICAgIGRpc3BsYXk6IG5vbmU7XHJcbiAgfVxyXG48L3N0eWxlPlxyXG4iLCAiLyoqIE1vZGFsIHRvIGhvbGQgZm9ybSB0aGF0IGxldHMgdXNlciByZW1vdmUgcHJvcHMgZnJvbSBzZWxlY3Rpb24uICovXG5cbmltcG9ydCB7IE1vZGFsLCBBcHAsIE5vdGljZSB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IFJlbW92ZUNvbmZpcm1Gb3JtIGZyb20gXCIuL1JlbW92ZUNvbmZpcm1Gb3JtLnN2ZWx0ZVwiO1xuaW1wb3J0IE11bHRpUHJvcFBsdWdpbiBmcm9tIFwiLi9tYWluXCI7XG5cbi8qKiBMb2FkcyBhIG1vZGFsIGFuZCBoYW5kbGVzIGZvcm0gc3VibWlzc2lvbnMuICovXG5leHBvcnQgY2xhc3MgUmVtb3ZlQ29uZmlybU1vZGFsIGV4dGVuZHMgTW9kYWwge1xuICBuYW1lczogc3RyaW5nW107XG4gIHN1Ym1pc3Npb246IChib29sOiBib29sZWFuKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBjb21wb25lbnQ6IFJlbW92ZUNvbmZpcm1Gb3JtO1xuXG4gIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBuYW1lczogc3RyaW5nW10sIHN1Ym1pc3Npb246IChib29sOiBib29sZWFuKSA9PiBQcm9taXNlPHZvaWQ+KSB7XG4gICAgc3VwZXIoYXBwKTtcbiAgICB0aGlzLm5hbWVzID0gbmFtZXM7XG4gICAgdGhpcy5zdWJtaXNzaW9uID0gc3VibWlzc2lvbjtcbiAgfVxuXG4gIGFzeW5jIG9uU3VibWl0KCkge1xuICAgIGF3YWl0IHRoaXMuc3VibWlzc2lvbih0cnVlKTtcbiAgICB0aGlzLmNsb3NlKCk7XG4gIH1cblxuICBvbkNhbmNlbCgpIHtcbiAgICB0aGlzLnN1Ym1pc3Npb24oZmFsc2UpO1xuICAgIHRoaXMuY2xvc2UoKTtcbiAgfVxuXG4gIG9uT3BlbigpOiB2b2lkIHtcbiAgICAvL1ByZXZlbnQgbW9kYWwgZnJvbSBvcGVuaW5nIGlmIG5vIG5hbWVzIGFyZSBwYXNzZWQuXG4gICAgaWYgKCF0aGlzLm5hbWVzIHx8IHRoaXMubmFtZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBuZXcgTm90aWNlKFwiUGxlYXNlIGNoZWNrIGF0IGxlYXN0IG9uZSBwcm9wZXJ0eSB0byByZW1vdmUuXCIpO1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH1cbiAgICB0aGlzLnRpdGxlRWwuY3JlYXRlRWwoXCJoMlwiLCB7IHRleHQ6IFwiUmVtb3ZlIFByb3BlcnRpZXNcIiB9KTtcblxuICAgIHRoaXMuY29tcG9uZW50ID0gbmV3IFJlbW92ZUNvbmZpcm1Gb3JtKHtcbiAgICAgIHRhcmdldDogdGhpcy5jb250ZW50RWwsXG4gICAgICBwcm9wczoge1xuICAgICAgICBuYW1lczogdGhpcy5uYW1lcyxcbiAgICAgICAgc3VibWlzc2lvbjogdGhpcy5vblN1Ym1pdC5iaW5kKHRoaXMpLFxuICAgICAgICBjYW5jZWw6IHRoaXMub25DYW5jZWwuYmluZCh0aGlzKSxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cbn1cbiIsICI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxyXG5cdGltcG9ydCB7IG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XHJcblxyXG5cdGV4cG9ydCBsZXQgbmFtZXM6IHN0cmluZ1tdID0gW1widGVzdFwiLCBcInRlc3QyXCJdO1xyXG5cdGV4cG9ydCBsZXQgc3VibWlzc2lvbjogKCkgPT4gdm9pZDtcclxuXHRleHBvcnQgbGV0IGNhbmNlbDogKCkgPT4gdm9pZDtcclxuXHJcblx0bGV0IGJ0bkNhbmNlbDogSFRNTEJ1dHRvbkVsZW1lbnQ7XHJcblxyXG5cdGNvbnN0IHdvcmQgPSBuYW1lcy5sZW5ndGggPiAxID8gXCJwcm9wZXJ0aWVzXCIgOiBcInByb3BlcnR5XCI7XHJcblxyXG5cdC8vRm9jdXMgb24gY2FuY2VsIHRvIG1ha2Ugc3VyZSB1c2VyIGRvZXMgbm90IGVhc2lseSBzdWJtaXQgY2hhbmdlcy5cclxuXHRvbk1vdW50KCgpID0+IHtcclxuXHRcdGJ0bkNhbmNlbC5mb2N1cygpO1xyXG5cdH0pO1xyXG48L3NjcmlwdD5cclxuXHJcbjxkaXY+XHJcblx0PGZvcm0gb246c3VibWl0fHByZXZlbnREZWZhdWx0PXtzdWJtaXNzaW9ufT5cclxuXHRcdDxwPlRoZSBmb2xsb3dpbmcge3dvcmR9IHdpbGwgYmUgcmVtb3ZlZDo8L3A+XHJcblx0XHQ8dWw+XHJcblx0XHRcdHsjZWFjaCBuYW1lcyBhcyBuYW1lfVxyXG5cdFx0XHRcdDxsaT5cclxuXHRcdFx0XHRcdHtuYW1lfVxyXG5cdFx0XHRcdDwvbGk+XHJcblx0XHRcdHsvZWFjaH1cclxuXHRcdDwvdWw+XHJcblx0XHQ8cD5BcmUgeW91IHN1cmUgeW91IHdpc2ggdG8gcHJvY2VlZD88L3A+XHJcblx0XHQ8YnV0dG9uIGNsYXNzPVwibW9kLXdhcm5pbmdcIiB0eXBlPVwic3VibWl0XCI+RGVsZXRlPC9idXR0b24+XHJcblx0XHQ8YnV0dG9uIG9uOmNsaWNrPXtjYW5jZWx9IGJpbmQ6dGhpcz17YnRuQ2FuY2VsfT5DYW5jZWw8L2J1dHRvbj5cclxuXHQ8L2Zvcm0+XHJcbjwvZGl2PlxyXG4iLCAiaW1wb3J0IHsgQXBwLCBURmlsZSB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHsgTmV3UHJvcERhdGEgfSBmcm9tIFwiLi9tYWluXCI7XG5cbnR5cGUgRmlsZVByb2Nlc3NvciA9IChmaWxlOiBURmlsZSwgY2FsbGJhY2s6IChmcm9udG1hdHRlcjogYW55KSA9PiB2b2lkKSA9PiBQcm9taXNlPHZvaWQ+IHwgdm9pZDtcblxuLyoqIEFkZCBwcm9wZXJ0aWVzIGZyb20gYSBNYXAgdG8gYSBub3RlLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYWRkUHJvcGVydGllcyhcbiAgZmlsZVByb2Nlc3NvcjogRmlsZVByb2Nlc3NvcixcbiAgZmlsZTogVEZpbGUsXG4gIHByb3BzOiBNYXA8c3RyaW5nLCBOZXdQcm9wRGF0YT4sXG4gIG92ZXJ3cml0ZTogYm9vbGVhbixcbiAgcHJvcENhY2hlOiBhbnlcbikge1xuICBhd2FpdCBmaWxlUHJvY2Vzc29yKGZpbGUsIChmcm9udG1hdHRlcjogYW55KSA9PiB7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgcHJvcHMpIHtcbiAgICAgIGlmIChrZXkgPT09IFwidGFnc1wiKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nVGFncyA9IGZyb250bWF0dGVyW2tleV0gfHwgW107XG4gICAgICAgIGNvbnN0IG5ld1RhZ3MgPSBBcnJheS5pc0FycmF5KHZhbHVlLmRhdGEpID8gdmFsdWUuZGF0YSA6IFt2YWx1ZS5kYXRhXTtcbiAgICAgICAgZnJvbnRtYXR0ZXJba2V5XSA9IFsuLi5uZXcgU2V0KFsuLi5leGlzdGluZ1RhZ3MsIC4uLm5ld1RhZ3NdKV07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWZyb250bWF0dGVyW2tleV0gfHwgb3ZlcndyaXRlKSB7XG4gICAgICAgIGZyb250bWF0dGVyW2tleV0gPSB2YWx1ZS5kYXRhO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy9Db21wYXJlIHR5cGVzIHRvIHNlZSBpZiB0aGV5IGNhbiBiZSBhcHBlbmRlZC5cbiAgICAgIGxldCB0eXBlMSA9IHZhbHVlLnR5cGU7XG4gICAgICBsZXQgdHlwZTIgPSBwcm9wQ2FjaGVba2V5LnRvTG93ZXJDYXNlKCldLnR5cGU7XG5cbiAgICAgIGlmIChjYW5CZUFwcGVuZGVkKHR5cGUxLCB0eXBlMikpIHtcbiAgICAgICAgaWYgKGZyb250bWF0dGVyW2tleV0gPT09IHZhbHVlLmRhdGEpIGNvbnRpbnVlOyAvL0xlYXZlIGlkZW50aWNhbCB2YWx1ZXMgYWxvbmUuXG4gICAgICAgIGlmICghdmFsdWUuZGF0YSkgY29udGludWU7IC8vRG8gbm90IG1lcmdlIGVtcHR5IHZhbHVlcy5cblxuICAgICAgICBsZXQgYXJyID0gbWVyZ2VJbnRvQXJyYXlzKGZyb250bWF0dGVyW2tleV0sIHZhbHVlLmRhdGEpO1xuICAgICAgICBmcm9udG1hdHRlcltrZXldID0gYXJyO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZyb250bWF0dGVyW2tleV0gPSB2YWx1ZS5kYXRhO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG4vKiogSXRlcmF0ZSB0aHJvdWdoIGFsbCBwcm9wcyBpbiBhIGxpc3QgYW5kIGFkZCB0aGVtIHRvIGFuIGV4aXN0aW5nIHNldC4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhZGRQcm9wVG9TZXQoZmlsZVByb2Nlc3NvcjogRmlsZVByb2Nlc3Nvciwgc2V0OiBTZXQ8c3RyaW5nPiwgZmlsZTogVEZpbGUpIHtcbiAgYXdhaXQgZmlsZVByb2Nlc3NvcihmaWxlLCAoZnJvbnRtYXR0ZXI6IGFueSkgPT4ge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGZyb250bWF0dGVyKSB7XG4gICAgICBjb25zb2xlLmxvZyh7IGtleSB9KTtcbiAgICAgIHNldC5hZGQoa2V5KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gc2V0O1xufVxuXG4vKiogUmVtb3ZlIHByb3BlcnRpZXMgZnJvbSBhIG5vdGUuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVtb3ZlUHJvcGVydGllcyhmaWxlUHJvY2Vzc29yOiBGaWxlUHJvY2Vzc29yLCBmaWxlOiBURmlsZSwgcHJvcHM6IHN0cmluZ1tdKSB7XG4gIGF3YWl0IGZpbGVQcm9jZXNzb3IoZmlsZSwgKGZyb250bWF0dGVyOiBhbnkpID0+IHtcbiAgICBmb3IgKGNvbnN0IHByb3Agb2YgcHJvcHMpIHtcbiAgICAgIC8vZGVsZXRlIGZyb250bWF0dGVyW3Byb3BdO1xuICAgICAgZnJvbnRtYXR0ZXJbcHJvcF0gPSB1bmRlZmluZWQ7IC8vXCJIYWNreVwiIHdvcmthcm91bmQsIGNvbW1lbnRlZCBjb2RlIHdpbGwgd29yayBpbiBsYXRlciB2ZXJzaW9uLlwiXG4gICAgfVxuICB9KTtcbn1cblxuLyoqIENoZWNrIGlmIHR3byB0eXBlcyBjYW4gYmUgYXBwZW5kZWQgdG8gZWFjaCBvdGhlci4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYW5CZUFwcGVuZGVkKHN0cjE6IHN0cmluZywgc3RyMjogc3RyaW5nKSB7XG4gIGxldCBhcnIgPSBbXCJudW1iZXJcIiwgXCJkYXRlXCIsIFwiZGF0ZXRpbWVcIiwgXCJjaGVja2JveFwiXTsgLy9UaGVzZSB2YWx1ZXMgc2hvdWxkIG5vdCBiZSBhcHBlbmRlZC5cbiAgaWYgKGFyci5pbmNsdWRlcyhzdHIxKSB8fCBhcnIuaW5jbHVkZXMoc3RyMikpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKiBDb252ZXJ0IHN0cmluZ3MgYW5kIGFycmF5cyBpbnRvIHNpbmdsZSBhcnJheS4gKi9cbmZ1bmN0aW9uIG1lcmdlSW50b0FycmF5cyguLi5hcmdzOiAoc3RyaW5nIHwgc3RyaW5nW10pW10pOiBzdHJpbmdbXSB7XG4gIGNvbnN0IGFycmF5cyA9IGFyZ3MubWFwKChhcmcpID0+IChBcnJheS5pc0FycmF5KGFyZykgPyBhcmcgOiBbYXJnXSkpO1xuXG4gIC8vIEZsYXR0ZW4gdGhlIGFycmF5XG4gIGNvbnN0IGZsYXR0ZW5lZCA9IGFycmF5cy5mbGF0KCk7XG5cbiAgLy8gUmVtb3ZlIGR1cGxpY2F0ZXMgdXNpbmcgU2V0IGFuZCBzcHJlYWQgaXQgaW50byBhbiBhcnJheVxuICBjb25zdCB1bmlxdWUgPSBbLi4ubmV3IFNldChmbGF0dGVuZWQpXTtcblxuICByZXR1cm4gdW5pcXVlO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYWRkVmFsdWVUb1Byb3BlcnR5KFxuICBmaWxlUHJvY2Vzc29yOiBGaWxlUHJvY2Vzc29yLFxuICBmaWxlOiBURmlsZSxcbiAgcHJvcGVydHk6IHN0cmluZyxcbiAgdmFsdWU6IHN0cmluZ1xuKSB7XG4gIGF3YWl0IGZpbGVQcm9jZXNzb3IoZmlsZSwgKGZyb250bWF0dGVyOiBhbnkpID0+IHtcbiAgICBjb25zdCBleGlzdGluZ1ZhbHVlcyA9IGZyb250bWF0dGVyW3Byb3BlcnR5XTtcbiAgICBcbiAgICBpZiAoZXhpc3RpbmdWYWx1ZXMpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZXMgPSBBcnJheS5pc0FycmF5KGV4aXN0aW5nVmFsdWVzKVxuICAgICAgICA/IGV4aXN0aW5nVmFsdWVzXG4gICAgICAgIDogW2V4aXN0aW5nVmFsdWVzXTtcbiAgICAgIC8vIFVzZSBhIFNldCB0byBlbnN1cmUgdGhlIG5ldyB2YWx1ZSBpcyB1bmlxdWVcbiAgICAgIGNvbnN0IG5ld1ZhbHVlcyA9IFsuLi5uZXcgU2V0KFsuLi5jdXJyZW50VmFsdWVzLCB2YWx1ZV0pXTtcbiAgICAgIGZyb250bWF0dGVyW3Byb3BlcnR5XSA9IG5ld1ZhbHVlcztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgdGhlIHByb3BlcnR5IGRvZXNuJ3QgZXhpc3QsIGNyZWF0ZSBpdCB3aXRoIHRoZSBuZXcgdmFsdWUgaW4gYSBsaXN0XG4gICAgICBmcm9udG1hdHRlcltwcm9wZXJ0eV0gPSBbdmFsdWVdO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZW1vdmVWYWx1ZXNGcm9tUHJvcGVydHkoXG4gIGZpbGVQcm9jZXNzb3I6IEZpbGVQcm9jZXNzb3IsXG4gIGZpbGU6IFRGaWxlLFxuICBwcm9wZXJ0eTogc3RyaW5nLFxuICB2YWx1ZXNUb1JlbW92ZTogc3RyaW5nW11cbikge1xuICBhd2FpdCBmaWxlUHJvY2Vzc29yKGZpbGUsIChmcm9udG1hdHRlcjogYW55KSA9PiB7XG4gICAgaWYgKGZyb250bWF0dGVyW3Byb3BlcnR5XSAmJiBBcnJheS5pc0FycmF5KGZyb250bWF0dGVyW3Byb3BlcnR5XSkpIHtcbiAgICAgIGZyb250bWF0dGVyW3Byb3BlcnR5XSA9IGZyb250bWF0dGVyW3Byb3BlcnR5XS5maWx0ZXIoXG4gICAgICAgICh2YWx1ZTogc3RyaW5nKSA9PiAhdmFsdWVzVG9SZW1vdmUuaW5jbHVkZXModmFsdWUpXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRVbmlxdWVWYWx1ZXMoXG4gIGFwcDogQXBwLFxuICBmaWxlczogVEZpbGVbXSxcbiAgcHJvcGVydHk6IHN0cmluZ1xuKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICBjb25zdCB2YWx1ZXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgZm9yIChjb25zdCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgYXdhaXQgYXBwLmZpbGVNYW5hZ2VyLnByb2Nlc3NGcm9udE1hdHRlcihmaWxlLCAoZnJvbnRtYXR0ZXI6IGFueSkgPT4ge1xuICAgICAgaWYgKGZyb250bWF0dGVyW3Byb3BlcnR5XSAmJiBBcnJheS5pc0FycmF5KGZyb250bWF0dGVyW3Byb3BlcnR5XSkpIHtcbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBmcm9udG1hdHRlcltwcm9wZXJ0eV0pIHtcbiAgICAgICAgICB2YWx1ZXMuYWRkKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBbLi4udmFsdWVzXTtcbn0iLCAiaW1wb3J0IHsgQXBwLCBTdWdnZXN0TW9kYWwgfSBmcm9tIFwib2JzaWRpYW5cIjtcblxuZXhwb3J0IGNsYXNzIFNpbmdsZVNlbGVjdFN1Z2dlc3RNb2RhbCBleHRlbmRzIFN1Z2dlc3RNb2RhbDxzdHJpbmc+IHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgYXBwOiBBcHAsXG4gICAgICAgIHByaXZhdGUgYXZhaWxhYmxlVmFsdWVzOiBzdHJpbmdbXSxcbiAgICAgICAgcHJpdmF0ZSBvblN1Ym1pdDogKHNlbGVjdGVkOiBzdHJpbmcpID0+IHZvaWRcbiAgICApIHtcbiAgICAgICAgc3VwZXIoYXBwKTtcbiAgICAgICAgdGhpcy5zZXRQbGFjZWhvbGRlcignVHlwZSB0byBzZWFyY2guLi4nKTtcbiAgICB9XG5cbiAgICBnZXRTdWdnZXN0aW9ucyhxdWVyeTogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5hdmFpbGFibGVWYWx1ZXMuZmlsdGVyKHZhbHVlID0+XG4gICAgICAgICAgICB2YWx1ZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHF1ZXJ5LnRvTG93ZXJDYXNlKCkpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcmVuZGVyU3VnZ2VzdGlvbih2YWx1ZTogc3RyaW5nLCBlbDogSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgZWwudGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBvbkNob29zZVN1Z2dlc3Rpb24oaXRlbTogc3RyaW5nLCBldnQ6IE1vdXNlRXZlbnQgfCBLZXlib2FyZEV2ZW50KSB7XG4gICAgICAgIHRoaXMub25TdWJtaXQoaXRlbSk7XG4gICAgfVxufVxuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUEsbUJBQTJHOzs7QUNBM0csSUFBQUMsbUJBQTJCOzs7QUNDcEIsU0FBUyxPQUFPO0FB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LEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O01Dd0NtQixJQUFLLEVBQUEsRUFBQzs7OztNQUNYLElBQUssRUFBQSxFQUFDOzs7Ozs7Ozs7SUFDSSxJQUFLLEVBQUEsRUFBQyxZQUFPO0lBQUE7O0lBQWIsSUFBSyxFQUFBLEVBQUM7Ozs7SUFDTixJQUFLLEVBQUEsRUFBQyxZQUFPO0lBQUE7O0lBQWIsSUFBSyxFQUFBLEVBQUM7Ozs7SUFDTCxJQUFLLEVBQUEsRUFBQyxhQUFRO0lBQUE7O0lBQWQsSUFBSyxFQUFBLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztNQUpaLElBQUssRUFBQSxFQUFDOzs7TUFDWCxJQUFLLEVBQUEsRUFBQzs7Ozs7UUFDSSxJQUFLLEVBQUEsRUFBQzs7Ozs7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QWMsS0FBSyxJQUFJLFlBQVksbUJBQW1CLEtBQUssS0FBSyxJQUFJLFdBQVcsR0FBRyxNQUFNLE9BQU8sS0FBSyxTQUFTLFdBQVcsS0FBSyxJQUFJLGNBQWMsb0JBQW9CLENBQUM7QUFBQSxJQUM1SztBQUFBLEVBQ0Y7QUFBQSxFQUVBLG9CQUFvQixPQUFZO0FBQzlCLFdBQU8sT0FBTyxTQUFnQjtBQUM1QixZQUFNLGlCQUFpQixLQUFLLElBQUksWUFBWSxtQkFBbUIsS0FBSyxLQUFLLElBQUksV0FBVyxHQUFHLE1BQU0sS0FBSztBQUFBLElBQ3hHO0FBQUEsRUFDRjtBQUNGOyIsCiAgIm5hbWVzIjogWyJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImVsZW1lbnQiLCAiX2EiLCAiZWxlbWVudCIsICJ0ZXh0IiwgImVsZW1lbnQiLCAiZGV0YWNoIiwgImNyZWF0ZV9lYWNoX2Jsb2NrIiwgImluc2VydCIsICJpbnN0YW5jZSIsICJjcmVhdGVfZnJhZ21lbnQiLCAiYXBwZW5kX3N0eWxlcyIsICJhdHRyIiwgImN0eCIsICJjdHgiLCAiY3R4IiwgImltcG9ydF9vYnNpZGlhbiIsICJ0ZXh0IiwgImltcG9ydF9vYnNpZGlhbiIsICJ0ZXh0IiwgImltcG9ydF9vYnNpZGlhbiIsICJjdHgiLCAiaW1wb3J0X29ic2lkaWFuIiwgImN0eCIsICJpbXBvcnRfb2JzaWRpYW4iXQp9Cg==
