/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => EmacsTextEditorPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var insertableSpecialKeys = [
  "Comma",
  "Period",
  "Slash",
  "Semicolon",
  "Quote",
  "BracketLeft",
  "BracketRight",
  "Backslash",
  "Backquote",
  "Minus",
  "Equal"
];
function isEventInterruptSelection(e) {
  return e.code == "Backspace" || e.code == "Delete" || Boolean(e.code.match(/^Key[A-Z]$/)) || Boolean(e.code.match(/^Digit[0-9]$/)) || Boolean(e.code.match(/^Numpad[0-9]$/)) || insertableSpecialKeys.includes(e.code);
}
var EmacsTextEditorPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.pluginTriggerSelection = false;
    this.disableSelectionWhenPossible = false;
  }
  onload() {
    console.log("loading plugin: Emacs text editor");
    document.addEventListener("keydown", (e) => {
      if (isEventInterruptSelection(e)) {
        this.disableSelectionWhenPossible = true;
        this.pluginTriggerSelection = false;
      }
    });
    this.addCommand({
      id: "forward-char",
      name: "Forward char",
      editorCallback: (editor, _) => {
        this.withSelectionUpdate(editor, () => {
          editor.exec("goRight");
        });
      }
    });
    this.addCommand({
      id: "backward-char",
      name: "Backward char",
      editorCallback: (editor, _) => {
        this.withSelectionUpdate(editor, () => {
          editor.exec("goLeft");
        });
      }
    });
    this.addCommand({
      id: "next-line",
      name: "Next line",
      editorCallback: (editor, _) => {
        this.withSelectionUpdate(editor, () => {
          editor.exec("goDown");
        });
      }
    });
    this.addCommand({
      id: "previous-line",
      name: "Previous line",
      editorCallback: (editor, _) => {
        this.withSelectionUpdate(editor, () => {
          editor.exec("goUp");
        });
      }
    });
    this.addCommand({
      id: "forward-word",
      name: "Forward word",
      editorCallback: (editor, _) => {
        this.withSelectionUpdate(editor, () => {
          editor.exec("goWordRight");
        });
      }
    });
    this.addCommand({
      id: "backward-word",
      name: "Backward word",
      editorCallback: (editor, _) => {
        this.withSelectionUpdate(editor, () => {
          editor.exec("goWordLeft");
        });
      }
    });
    this.addCommand({
      id: "move-end-of-line",
      name: "Move end of line",
      editorCallback: (editor, _) => {
        this.withSelectionUpdate(editor, () => {
          const cursor = editor.getCursor();
          const lineContent = editor.getLine(cursor.line);
          editor.setCursor({
            line: cursor.line,
            ch: lineContent.length
          });
        });
      }
    });
    this.addCommand({
      id: "move-beginning-of-line",
      name: "Move cursor to beginning of line",
      editorCallback: (editor, _) => {
        this.withSelectionUpdate(editor, () => {
          const cursor = editor.getCursor();
          editor.setCursor({ line: cursor.line, ch: 0 });
        });
      }
    });
    this.addCommand({
      id: "beginning-of-buffer",
      name: "Beginning of buffer",
      editorCallback: (editor, _) => {
        this.withSelectionUpdate(editor, () => {
          editor.exec("goStart");
        });
      }
    });
    this.addCommand({
      id: "end-of-buffer",
      name: "End of buffer",
      editorCallback: (editor, _) => {
        this.withSelectionUpdate(editor, () => {
          editor.exec("goEnd");
        });
      }
    });
    this.addCommand({
      id: "kill-line",
      name: "Kill line",
      editorCallback: (editor, _) => {
        this.disableSelection(editor);
        const cursor = editor.getCursor();
        const lineContent = editor.getLine(cursor.line);
        if (lineContent === "") {
          editor.exec("deleteLine");
        } else {
          editor.setSelection(cursor, {
            line: cursor.line,
            ch: lineContent.length
          });
          this.putSelectionInClipboard(editor, 1 /* Cut */);
          editor.setCursor(cursor);
        }
      }
    });
    this.addCommand({
      id: "delete-char",
      name: "Delete char",
      editorCallback: (editor, _) => {
        this.disableSelection(editor);
        this.withDeleteInText(editor, () => {
          editor.exec("goRight");
        });
      }
    });
    this.addCommand({
      id: "kill-word",
      name: "Kill word",
      editorCallback: (editor, _) => {
        this.withDeleteInText(editor, () => {
          editor.exec("goWordRight");
        });
      }
    });
    this.addCommand({
      id: "backward-kill-word",
      name: "Backward kill word",
      editorCallback: (editor, _) => {
        this.withDeleteInText(editor, () => {
          editor.exec("goWordLeft");
        });
      }
    });
    this.addCommand({
      id: "kill-ring-save",
      name: "Kill ring save",
      editorCallback: (editor, _) => {
        this.putSelectionInClipboard(editor, 0 /* Copy */);
      }
    });
    this.addCommand({
      id: "kill-region",
      name: "Kill region",
      editorCallback: (editor, _) => {
        this.putSelectionInClipboard(editor, 1 /* Cut */);
      }
    });
    this.addCommand({
      id: "yank",
      name: "Yank",
      editorCallback: async (editor, _) => {
        const clipboardContent = await navigator.clipboard.readText();
        const cursor = editor.getCursor();
        if (!this.getCurrentSelectionStart(editor)) {
          editor.replaceRange(clipboardContent, cursor);
        } else {
          editor.replaceSelection(clipboardContent);
          this.disableSelection(editor);
        }
        editor.setCursor(
          cursor.line,
          cursor.ch + clipboardContent.length
        );
        document.dispatchEvent(new ClipboardEvent("paste"));
      }
    });
    this.addCommand({
      id: "set-mark-command",
      name: "Set mark command",
      editorCallback: (editor, _) => {
        if (this.pluginTriggerSelection) {
          this.disableSelection(editor);
        } else {
          this.pluginTriggerSelection = true;
        }
        this.disableSelectionWhenPossible = false;
      }
    });
    this.addCommand({
      id: "keyboard-quit",
      name: "Keyboard-quit",
      editorCallback: (editor, _) => {
        this.disableSelection(editor);
      }
    });
    this.addCommand({
      id: "undo",
      name: "Undo",
      editorCallback: (editor, _) => {
        editor.undo();
      }
    });
    this.addCommand({
      id: "redo",
      name: "Redo",
      editorCallback: (editor, _) => {
        editor.redo();
      }
    });
    this.addCommand({
      id: "recenter-top-bottom",
      name: "Recenter",
      editorCallback: (editor, _) => {
        const cursor = editor.getCursor();
        const range = {
          from: { line: cursor.line, ch: cursor.ch },
          to: { line: cursor.line, ch: cursor.ch }
        };
        editor.scrollIntoView(range, true);
      }
    });
    this.addCommand({
      id: "forward-paragraph",
      name: "Forward paragraph",
      editorCallback: async (editor, _) => {
        this.withSelectionUpdate(editor, () => {
          this.moveToNextParagraph(editor, 0 /* Forward */);
        });
      }
    });
    this.addCommand({
      id: "backward-paragraph",
      name: "Backward paragraph",
      editorCallback: async (editor, _) => {
        this.withSelectionUpdate(editor, () => {
          this.moveToNextParagraph(editor, 1 /* Backward */);
        });
      }
    });
  }
  onunload() {
    console.log("unloading plugin: Emacs text editor");
  }
  disableSelection(editor) {
    editor.setSelection(editor.getCursor(), editor.getCursor());
    this.pluginTriggerSelection = false;
    this.disableSelectionWhenPossible = false;
  }
  withSelectionUpdate(editor, callback) {
    if (this.disableSelectionWhenPossible) {
      this.disableSelection(editor);
    }
    const currentSelectionStart = this.getCurrentSelectionStart(editor);
    if (currentSelectionStart) {
      editor.setSelection(editor.getCursor());
    }
    callback();
    if (currentSelectionStart) {
      editor.setSelection(currentSelectionStart, editor.getCursor());
    }
  }
  getCurrentSelectionStart(editor) {
    const selections = editor.listSelections();
    if (selections.length == 0) {
      return void 0;
    }
    if (selections[0].anchor.line !== selections[0].head.line || selections[0].anchor.ch !== selections[0].head.ch) {
      return selections[0].anchor;
    }
    if (this.pluginTriggerSelection) {
      return selections[0].anchor;
    }
    return void 0;
  }
  withDeleteInText(editor, callback) {
    const cursorBefore = editor.getCursor();
    callback();
    const cursorAfter = editor.getCursor();
    editor.setSelection(cursorBefore, cursorAfter);
    this.putSelectionInClipboard(editor, 1 /* Cut */);
  }
  putSelectionInClipboard(editor, mode) {
    if (!this.getCurrentSelectionStart(editor)) {
      return;
    }
    navigator.clipboard.writeText(editor.getSelection());
    if (mode == 0 /* Copy */) {
      document.dispatchEvent(new ClipboardEvent("copy"));
    } else if (mode == 1 /* Cut */) {
      editor.replaceSelection("");
      document.dispatchEvent(new ClipboardEvent("cut"));
    }
    this.disableSelection(editor);
  }
  moveToNextParagraph(editor, direction) {
    const cursor = editor.getCursor();
    const value = editor.getValue();
    const maxOffset = value.length;
    const currentOffset = editor.posToOffset(cursor);
    if (direction === 0 /* Forward */ && currentOffset >= maxOffset || direction === 1 /* Backward */ && currentOffset === 0) {
      return;
    }
    let nextParagraphOffset = direction === 0 /* Forward */ ? maxOffset : 0;
    let foundText = false;
    let foundFirstBreak = false;
    function isNewLine(position, direction2) {
      if (direction2 === 0 /* Forward */) {
        return value[position] === "\n" || value[position] === "\r" && value[position + 1] === "\n";
      } else {
        return value[position] === "\n" || position > 0 && value[position - 1] === "\r" && value[position] === "\n";
      }
    }
    const step = direction === 0 /* Forward */ ? 1 : -1;
    let i = currentOffset;
    while (direction === 0 /* Forward */ && i < maxOffset || direction === 1 /* Backward */ && i > 0) {
      if (foundText && isNewLine(i, direction)) {
        if (foundFirstBreak) {
          nextParagraphOffset = direction === 0 /* Forward */ ? i : i + 1;
          if (direction === 0 /* Forward */ && value[i] === "\r" || direction === 1 /* Backward */ && i > 0 && value[i - 1] === "\r") {
            nextParagraphOffset += direction === 0 /* Forward */ ? 1 : -1;
          }
          break;
        } else {
          foundFirstBreak = true;
          i += step;
          continue;
        }
      } else {
        foundFirstBreak = false;
      }
      if (value[i] !== "\n" && value[i] !== "\r" && value[i] !== " ") {
        foundText = true;
      }
      i += step;
    }
    const newPos = editor.offsetToPos(nextParagraphOffset);
    editor.setCursor(newPos);
  }
};
