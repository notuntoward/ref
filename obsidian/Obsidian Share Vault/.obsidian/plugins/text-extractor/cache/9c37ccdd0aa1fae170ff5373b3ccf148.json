{"path":"lit/lit_notes_OLD_PARTIAL/Toloka23optTechniqueLLM.pdf","text":"LLMs Optimization Techniques: Prompt Tuning and Prompt Engineering Nov 16, 2023 Fine-tuning is regarded as one of the optimal options for improving the performance of AI foundation models. However, there are other more cost-effective and efficient means of customizing large language models (LLMs), such as prompt tuning or prompt engineering. In this article, we will delve into the concept of such techniques and how they can empower data scientists to tackle the full potential of AI models for various applications. by Toloka Team Understanding Options for Tailoring a Pre-Trained Model for a Designated Task Large Language Models 4/24/24, 12:57 PM LLMs Optimization Techniques: Prompt Tuning and Prompt Engineering chrome-extension://mpiodijhokgodhhofbcjdecpffjipkle/src/ui/pages/editor.html 1/6 Prompt tuning and engineering are the processes that focus on crafting a specific input or instruction (a prompt) for an AI model to obtain desired outputs. These approaches are essential because, despite their remarkable capabilities, AI models like LLMs can be unpredictable and may not always generate the pertinent response without precise guidance. So, basically, these techniques are employed to improve the performance of pre-trained LLMs to adapt it to downstream tasks. Let's take a closer look at all the basic optimization techniques that exist to customize the model for a particular task. One of the most prominent and effective methods to improve the capabilities of LLMs is a fine-tuning process. During fine-tuning, models receive additional training data that consists of labeled examples of the desired future output of the large language model. However, while fine-tuning most often requires a significant amount of new data, the process is much easier than training a new large language model. Other easier-to- perform alternatives of this approach include prompt tuning and prompt engineering. Prompt tuning and engineering allow enhancing LLM performance to handle highly specialized tasks without collecting a huge amount of labeled data as in the case of fine-tuning. These techniques may prove to be particularly valuable tools, for example, for businesses that possess limited data collection. Let's take a closer look at both of these approaches. Prompt engineering is a process that allows to engineer guidelines for a pre-trained model to implement a narrow task. A human engineer's instructions are fed to an LLM for it to accomplish a specific task. These instructions are called hard prompts. Fine-Tuning Prompt Tuning and Engineering Prompt Engineering 4/24/24, 12:57 PM LLMs Optimization Techniques: Prompt Tuning and Prompt Engineering chrome-extension://mpiodijhokgodhhofbcjdecpffjipkle/src/ui/pages/editor.html 2/6 Hard prompts are described as static and well-defined guidelines for an LLM. They can be thought of as templates that are used in generative AI applications. These hard prompts consist of manually handcrafted text prompts with discrete input tokens. They may represent some extra words, instructions, or examples for a model written by a human. They compel an LLM to retrieve an appropriate and relevant output from its already huge amount of knowledge. Some tasks require just one or two of such instructions for the model to successfully perform the task. But there are also more demanding tasks, which may need dozens of such hard prompts. It's hard to write all of them manually, so that's why a more effective and fast approach known as prompt tuning appeared. AI-crafted soft prompts used in prompt tuning tend to outperform human-engineered hard prompts. LLMs with billions of parameters can be quite demanding to fine-tune for specific tasks due to their size and complexity. Traditional methods of task-specific fine- tuning might require significant computational resources and labeled data. Prompt tuning provides a more efficient way to adapt these LLMs to various tasks. The so-called soft prompts are fed to LLM in the process of prompt tuning so that the model would understand the task-specific context. More commonly they represent an AI-generated number that is added to an embedding layer of deep learning models. Unlike hard prompts, soft prompts cannot be recognized or edited by a human, because they consist of an embedding that is a string of numbers. Such lists of numbers are generated by a small trainable model before the LMM is involved in the process. They are created through the text prompt encoding process. Then this small model creates task-specific virtual tokens that correspond to the embedding consisting of a string of numbers. The tokens are then added to the prompt that is fed to the model. According to , as model parameters scale, prompt tuning tends to keep up with the performance of a traditional method of tuning a model. The main disadvantage of soft prompts compared to hard prompt parameters consists in the fact that they are less likely to be interpreted. This lack of interpretability does not allow us to fully understand how or why the AI language model chooses the specific soft prompt for a particular task. Prompt Tuning research 4/24/24, 12:57 PM LLMs Optimization Techniques: Prompt Tuning and Prompt Engineering chrome-extension://mpiodijhokgodhhofbcjdecpffjipkle/src/ui/pages/editor.html 3/6 Moreover, the model itself is not capable of sharing insights into its inner process of choosing these task-specific virtual tokens. Simply put, AI-designed soft prompts are not transparent just the same as the intricate layers of deep learning models themselves. There is also a technique that is similar to prompt tuning and engineering which is referred to as prefix tuning. It also represents a streamlined substitute for full tuning in the context of natural language generation tasks. This approach maintains the existing language model weights frozen without further adjustments but focuses on optimizing a compact, specialized vector referred to as the \"prefix.\" Instead of just changing words or instructions in the input, prefix tuning adds some extra information right at the beginning of the prompt. This extra information helps the language model understand your request better. Introducing hard or soft prompts to an LLM may be a less expensive and more effective approach to induce a pre-trained model to undertake a specific task than fine-tuning. For example, a good language classifier prompt can substitute a vast amount of additional training data and guide the model to the accurate desired output. Certain advantages make prompt optimization techniques stand out in comparison to traditional methods of improving the capabilities of LLMs: It's possible to craft prompts to suit various tasks, making them versatile for a wide range of applications, from question answering to content generation and more. Optimization techniques enable you to personalize your interactions with AI models, ensuring that responses are tailored to your goals and objectives. When prompts are accurately tuned or engineered, AI performance becomes more efficient. The need for post-processing or manual editing is minimized, saving valuable time and resources. Both prompt tuning and engineering provide efficient ways to customize LLMs. They allow users to adapt existing models to specific tasks Why Optimization Techniques Matter Customization Efficiency 4/24/24, 12:57 PM LLMs Optimization Techniques: Prompt Tuning and Prompt Engineering chrome-extension://mpiodijhokgodhhofbcjdecpffjipkle/src/ui/pages/editor.html 4/6 without the need for thorough large-scale retraining or fine-tuning. This efficiency saves time and computational resources. These methods are parameter-efficient. They don't require the creation of a whole new large base model or modification of the entire model but focus on specific components, such as prompts or prefixes. They also don't require any additional datasets. This means they can work effectively even with limited computational resources and restricted labeled data. Prompt tuning and engineering can reduce the data dependency of pre-trained language models. They allow models to perform well with relatively small amounts of data, which can be especially important for specialized tasks with limited training examples. Prompt tuning and engineering help to find new applications for trained models and solve a variety of tasks. This reduces the need to maintain separate models for each specific application, thus saving on data storage and computational costs. Prompt tuning and engineering are artificial intelligence model optimization techniques that facilitate efficient and flexible refinement of language models. They make LLMs more user-friendly and adaptable to a wide variety of different specific tasks. In a nutshell, itâ€™s a simple yet powerful way to make large language models more intelligent and multifunctional. In certain cases, when, for example, the amount of labeled data or computational resources is limited, they may prove to work better than older additional training techniques. Prompt tuning can optimize LLMs through the introduction of AI-generated soft prompts, while prompt engineering, on the other hand, provides a sense of control, Parameter Efficiency Reduced Data Dependency Reusable Models Conclusion 4/24/24, 12:57 PM LLMs Optimization Techniques: Prompt Tuning and Prompt Engineering chrome-extension://mpiodijhokgodhhofbcjdecpffjipkle/src/ui/pages/editor.html 5/6 enabling users to craft precise hard prompts for desired outcomes. Although soft prompts are prone to outperform human-generated hard prompts, the implementation of hard prompts is sufficient for the successful completion of certain trivial tasks. As AI technology continues to evolve, prompt tuning and engineering will likely remain critical skills for those looking to leverage AI for various applications, from content generation to problem-solving and beyond. Updated: Mar 26, 2024 | ArticleÂ writtenÂ by: Toloka Team 4/24/24, 12:57 PM LLMs Optimization Techniques: Prompt Tuning and Prompt Engineering chrome-extension://mpiodijhokgodhhofbcjdecpffjipkle/src/ui/pages/editor.html 6/6","libVersion":"0.3.2","langs":""}